# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# NyaPuma <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-25 14:15+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: NyaPuma <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid ":mod:`!statistics` --- Mathematical statistics functions"
msgstr ":mod:`!statistics` --- Funções de estatística matemática"

msgid "**Source code:** :source:`Lib/statistics.py`"
msgstr "**Código-fonte:** :source:`Lib/statistics.py`"

msgid ""
"This module provides functions for calculating mathematical statistics of "
"numeric (:class:`~numbers.Real`-valued) data."
msgstr ""
"Este módulo fornece funções para calcular estatísticas matemáticas de dados "
"numéricos (com valores :class:`~numbers.Real`)."

msgid ""
"The module is not intended to be a competitor to third-party libraries such "
"as `NumPy <https://numpy.org>`_, `SciPy <https://scipy.org/>`_, or "
"proprietary full-featured statistics packages aimed at professional "
"statisticians such as Minitab, SAS and Matlab. It is aimed at the level of "
"graphing and scientific calculators."
msgstr ""
"Este módulo não é destinado a competir com bibliotecas de terceiros como "
"`NumPy <https://numpy.org>`_, `SciPy <https://scipy.org/>`_, ou pacotes "
"estatísticos completos e proprietários destinados a estatísticos "
"profissionais, como Minitab, SAS e Matlab. É direcionado para o nível de "
"gráficos e calculadoras científicas."

msgid ""
"Unless explicitly noted, these functions support :class:`int`, :class:"
"`float`, :class:`~decimal.Decimal` and :class:`~fractions.Fraction`. "
"Behaviour with other types (whether in the numeric tower or not) is "
"currently unsupported.  Collections with a mix of types are also undefined "
"and implementation-dependent.  If your input data consists of mixed types, "
"you may be able to use :func:`map` to ensure a consistent result, for "
"example: ``map(float, input_data)``."
msgstr ""
"A menos que seja explicitamente indicado, estas funções suportam :class:"
"`int`, :class:`float`, :class:`~decimal.Decimal` e :class:`~fractions."
"Fraction`. O comportamento com outros tipos (sejam ou não da torre numérica) "
"não é atualmente suportado. Coleções com uma mistura de tipos também são "
"indefinidas e dependentes da implementação. Se os seus dados de entrada "
"forem compostos por tipos mistos, pode usar :func:`map` para garantir um "
"resultado consistente, por exemplo: ``map(float, input_data)``."

msgid ""
"Some datasets use ``NaN`` (not a number) values to represent missing data. "
"Since NaNs have unusual comparison semantics, they cause surprising or "
"undefined behaviors in the statistics functions that sort data or that count "
"occurrences.  The functions affected are ``median()``, ``median_low()``, "
"``median_high()``, ``median_grouped()``, ``mode()``, ``multimode()``, and "
"``quantiles()``.  The ``NaN`` values should be stripped before calling these "
"functions::"
msgstr ""
"Alguns conjuntos de dados usam valores ``NaN`` (*not a number*) para "
"representar dados em falta. Uma vez que os NaNs têm semânticas de comparação "
"invulgares, causam comportamentos surpreendentes ou indefinidos nas funções "
"estatísticas que ordenam dados ou contam ocorrências. As funções afetadas "
"são ``median()``, ``median_low()``, ``median_high()``, ``median_grouped()``, "
"``mode()``, ``multimode()``, e ``quantiles()``. Os valores ``NaN`` devem ser "
"removidos antes de chamar estas funções:"

msgid ""
">>> from statistics import median\n"
">>> from math import isnan\n"
">>> from itertools import filterfalse\n"
"\n"
">>> data = [20.7, float('NaN'),19.2, 18.3, float('NaN'), 14.4]\n"
">>> sorted(data)  # This has surprising behavior\n"
"[20.7, nan, 14.4, 18.3, 19.2, nan]\n"
">>> median(data)  # This result is unexpected\n"
"16.35\n"
"\n"
">>> sum(map(isnan, data))    # Number of missing values\n"
"2\n"
">>> clean = list(filterfalse(isnan, data))  # Strip NaN values\n"
">>> clean\n"
"[20.7, 19.2, 18.3, 14.4]\n"
">>> sorted(clean)  # Sorting now works as expected\n"
"[14.4, 18.3, 19.2, 20.7]\n"
">>> median(clean)       # This result is now well defined\n"
"18.75"
msgstr ""
">>> from statistics import median\n"
">>> from math import isnan\n"
">>> from itertools import filterfalse\n"
"\n"
">>> data = [20.7, float('NaN'), 19.2, 18.3, float('NaN'), 14.4]\n"
">>> sorted(data)  # Este comportamento é surpreendente\n"
"[20.7, nan, 14.4, 18.3, 19.2, nan]\n"
">>> median(data)  # Este resultado é inesperado\n"
"16.35\n"
"\n"
">>> sum(map(isnan, data))    # Número de valores em falta\n"
"2\n"
">>> clean = list(filterfalse(isnan, data))  # Remove valores NaN\n"
">>> clean\n"
"[20.7, 19.2, 18.3, 14.4]\n"
">>> sorted(clean)  # A ordenação agora funciona como esperado\n"
"[14.4, 18.3, 19.2, 20.7]\n"
">>> median(clean)       # Este resultado está agora bem definido\n"
"18.75"

msgid "Averages and measures of central location"
msgstr "Médias e medidas de localização central"

msgid ""
"These functions calculate an average or typical value from a population or "
"sample."
msgstr ""
"Estas funções calculam uma média ou valor típico a partir de uma população "
"ou amostra."

msgid ":func:`mean`"
msgstr ":func:`mean`"

msgid "Arithmetic mean (\"average\") of data."
msgstr "Média aritmética (\"média\") dos dados."

msgid ":func:`fmean`"
msgstr ":func:`fmean`"

msgid "Fast, floating-point arithmetic mean, with optional weighting."
msgstr "Média aritmética rápida em vírgula flutuante, com ponderação opcional."

msgid ":func:`geometric_mean`"
msgstr ":func:`geometric_mean`"

msgid "Geometric mean of data."
msgstr "Média geométrica dos dados."

msgid ":func:`harmonic_mean`"
msgstr ":func:`harmonic_mean`"

msgid "Harmonic mean of data."
msgstr "Média harmónica dos dados."

msgid ":func:`kde`"
msgstr ":func:`kde`"

msgid "Estimate the probability density distribution of the data."
msgstr "Estima a distribuição de densidade de probabilidade dos dados."

msgid ":func:`kde_random`"
msgstr ":func:`kde_random`"

msgid "Random sampling from the PDF generated by kde()."
msgstr "Amostragem aleatória da PDF gerada por kde()."

msgid ":func:`median`"
msgstr ":func:`median`"

msgid "Median (middle value) of data."
msgstr "Mediana (valor médio) dos dados."

msgid ":func:`median_low`"
msgstr ":func:`median_low`"

msgid "Low median of data."
msgstr "Mediana baixa dos dados."

msgid ":func:`median_high`"
msgstr ":func:`median_high`"

msgid "High median of data."
msgstr "Mediana alta dos dados."

msgid ":func:`median_grouped`"
msgstr ":func:`median_grouped`"

msgid "Median (50th percentile) of grouped data."
msgstr "Mediana (percentil 50) de dados agrupados."

msgid ":func:`mode`"
msgstr ":func:`mode`"

msgid "Single mode (most common value) of discrete or nominal data."
msgstr "Moda única (valor mais comum) de dados discretos ou nominais."

msgid ":func:`multimode`"
msgstr ":func:`multimode`"

msgid "List of modes (most common values) of discrete or nominal data."
msgstr "Lista de modas (valores mais comuns) de dados discretos ou nominais."

msgid ":func:`quantiles`"
msgstr ":func:`quantiles`"

msgid "Divide data into intervals with equal probability."
msgstr "Divide os dados em intervalos com probabilidade igual."

msgid "Measures of spread"
msgstr "Medidas de dispersão"

msgid ""
"These functions calculate a measure of how much the population or sample "
"tends to deviate from the typical or average values."
msgstr ""
"Estas funções calculam uma medida de quanto a população ou amostra tende a "
"desviar-se dos valores típicos ou médios."

msgid ":func:`pstdev`"
msgstr ":func:`pstdev`"

msgid "Population standard deviation of data."
msgstr "Desvio padrão populacional dos dados."

msgid ":func:`pvariance`"
msgstr ":func:`pvariance`"

msgid "Population variance of data."
msgstr "Variância populacional dos dados."

msgid ":func:`stdev`"
msgstr ":func:`stdev`"

msgid "Sample standard deviation of data."
msgstr "Desvio padrão amostral dos dados."

msgid ":func:`variance`"
msgstr ":func:`variance`"

msgid "Sample variance of data."
msgstr "Variância amostral dos dados."

msgid "Statistics for relations between two inputs"
msgstr "Estatísticas para relações entre duas entradas"

msgid ""
"These functions calculate statistics regarding relations between two inputs."
msgstr ""
"Estas funções calculam estatísticas relativas a relações entre duas entradas."

msgid ":func:`covariance`"
msgstr ":func:`covariance`"

msgid "Sample covariance for two variables."
msgstr "Covariância amostral para duas variáveis."

msgid ":func:`correlation`"
msgstr ":func:`correlation`"

msgid "Pearson and Spearman's correlation coefficients."
msgstr "Coeficientes de correlação de Pearson e Spearman."

msgid ":func:`linear_regression`"
msgstr ":func:`linear_regression`"

msgid "Slope and intercept for simple linear regression."
msgstr "Declive e interceção para regressão linear simples."

msgid "Function details"
msgstr "Detalhes das funções"

msgid ""
"Note: The functions do not require the data given to them to be sorted. "
"However, for reading convenience, most of the examples show sorted sequences."
msgstr ""
"Nota: As funções não exigem que os dados fornecidos estejam ordenados. No "
"entanto, por conveniência de leitura, a maioria dos exemplos mostra "
"sequências ordenadas."

msgid ""
"Return the sample arithmetic mean of *data* which can be a sequence or "
"iterable."
msgstr ""
"Devolve a média aritmética amostral de *data*, que pode ser uma sequência ou "
"iterável."

msgid ""
"The arithmetic mean is the sum of the data divided by the number of data "
"points.  It is commonly called \"the average\", although it is only one of "
"many different mathematical averages.  It is a measure of the central "
"location of the data."
msgstr ""
"A média aritmética é a soma dos dados dividida pelo número de pontos de "
"dados. É comumente chamada de \"média\", embora seja apenas uma das muitas "
"médias matemáticas diferentes. É uma medida da localização central dos dados."

msgid "If *data* is empty, :exc:`StatisticsError` will be raised."
msgstr "Se *data* estiver vazio, será levantado :exc:`StatisticsError`."

msgid "Some examples of use:"
msgstr "Alguns exemplos de utilização:"

msgid ""
">>> mean([1, 2, 3, 4, 4])\n"
"2.8\n"
">>> mean([-1.0, 2.5, 3.25, 5.75])\n"
"2.625\n"
"\n"
">>> from fractions import Fraction as F\n"
">>> mean([F(3, 7), F(1, 21), F(5, 3), F(1, 3)])\n"
"Fraction(13, 21)\n"
"\n"
">>> from decimal import Decimal as D\n"
">>> mean([D(\"0.5\"), D(\"0.75\"), D(\"0.625\"), D(\"0.375\")])\n"
"Decimal('0.5625')"
msgstr ""
">>> mean([1, 2, 3, 4, 4])\n"
"2.8\n"
">>> mean([-1.0, 2.5, 3.25, 5.75])\n"
"2.625\n"
"\n"
">>> from fractions import Fraction as F\n"
">>> mean([F(3, 7), F(1, 21), F(5, 3), F(1, 3)])\n"
"Fraction(13, 21)\n"
"\n"
">>> from decimal import Decimal as D\n"
">>> mean([D(\"0.5\"), D(\"0.75\"), D(\"0.625\"), D(\"0.375\")])\n"
"Decimal('0.5625')"

msgid ""
"The mean is strongly affected by `outliers <https://en.wikipedia.org/wiki/"
"Outlier>`_ and is not necessarily a typical example of the data points. For "
"a more robust, although less efficient, measure of `central tendency "
"<https://en.wikipedia.org/wiki/Central_tendency>`_, see :func:`median`."
msgstr ""
"A média é fortemente afetada por `valores atípicos <https://en.wikipedia.org/"
"wiki/Outlier>`_ e não é necessariamente um exemplo típico dos pontos de "
"dados. Para uma medida mais robusta, embora menos eficiente, de `tendência "
"central <https://en.wikipedia.org/wiki/Central_tendency>`_, veja :func:"
"`median`."

msgid ""
"The sample mean gives an unbiased estimate of the true population mean, so "
"that when taken on average over all the possible samples, ``mean(sample)`` "
"converges on the true mean of the entire population.  If *data* represents "
"the entire population rather than a sample, then ``mean(data)`` is "
"equivalent to calculating the true population mean μ."
msgstr ""
"A média amostral fornece uma estimativa não enviesada da média populacional "
"verdadeira, de modo que, quando considerada em média sobre todas as amostras "
"possíveis, ``mean(sample)`` converge para a média verdadeira de toda a "
"população. Se *data* representar toda a população em vez de uma amostra, "
"então ``mean(data)`` é equivalente a calcular a média populacional "
"verdadeira μ."

msgid "Convert *data* to floats and compute the arithmetic mean."
msgstr "Converte *data* para floats e calcula a média aritmética."

msgid ""
"This runs faster than the :func:`mean` function and it always returns a :"
"class:`float`.  The *data* may be a sequence or iterable.  If the input "
"dataset is empty, raises a :exc:`StatisticsError`."
msgstr ""
"Esta função é mais rápida do que a função :func:`mean` e sempre devolve um :"
"class:`float`. Os *data* podem ser uma sequência ou iterável. Se o conjunto "
"de dados de entrada estiver vazio, levanta um :exc:`StatisticsError`."

msgid ""
">>> fmean([3.5, 4.0, 5.25])\n"
"4.25"
msgstr ""
">>> fmean([3.5, 4.0, 5.25])\n"
"4.25"

msgid ""
"Optional weighting is supported.  For example, a professor assigns a grade "
"for a course by weighting quizzes at 20%, homework at 20%, a midterm exam at "
"30%, and a final exam at 30%:"
msgstr ""
"É suportada ponderação opcional. Por exemplo, um professor atribui uma nota "
"para um curso ponderando os questionários em 20%, os trabalhos de casa em "
"20%, um exame intermédio em 30% e um exame final em 30%:"

msgid ""
">>> grades = [85, 92, 83, 91]\n"
">>> weights = [0.20, 0.20, 0.30, 0.30]\n"
">>> fmean(grades, weights)\n"
"87.6"
msgstr ""
">>> grades = [85, 92, 83, 91]\n"
">>> weights = [0.20, 0.20, 0.30, 0.30]\n"
">>> fmean(grades, weights)\n"
"87.6"

msgid ""
"If *weights* is supplied, it must be the same length as the *data* or a :exc:"
"`ValueError` will be raised."
msgstr ""
"Se *weights* for fornecido, deve ter o mesmo comprimento que *data*, ou será "
"levantado um :exc:`ValueError`."

msgid "Added support for *weights*."
msgstr "Adicionado suporte para *weights*."

msgid "Convert *data* to floats and compute the geometric mean."
msgstr "Converte *data* para floats e calcula a média geométrica."

msgid ""
"The geometric mean indicates the central tendency or typical value of the "
"*data* using the product of the values (as opposed to the arithmetic mean "
"which uses their sum)."
msgstr ""
"A média geométrica indica a tendência central ou valor típico dos *data* "
"usando o produto dos valores (em oposição à média aritmética, que usa a sua "
"soma)."

msgid ""
"Raises a :exc:`StatisticsError` if the input dataset is empty, if it "
"contains a zero, or if it contains a negative value. The *data* may be a "
"sequence or iterable."
msgstr ""
"Levanta um :exc:`StatisticsError` se o conjunto de dados de entrada estiver "
"vazio, se contiver um zero ou se contiver um valor negativo. Os *data* podem "
"ser uma sequência ou iterável."

msgid ""
"No special efforts are made to achieve exact results. (However, this may "
"change in the future.)"
msgstr ""
"Não são feitos esforços especiais para obter resultados exatos. (No entanto, "
"isto pode mudar no futuro.)"

msgid ""
">>> round(geometric_mean([54, 24, 36]), 1)\n"
"36.0"
msgstr ""
">>> round(geometric_mean([54, 24, 36]), 1)\n"
"36.0"

msgid ""
"Return the harmonic mean of *data*, a sequence or iterable of real-valued "
"numbers.  If *weights* is omitted or ``None``, then equal weighting is "
"assumed."
msgstr ""
"Devolve a média harmónica de *data*, uma sequência ou iterável de números "
"reais. Se *weights* for omitido ou ``None``, assume-se ponderação igual."

msgid ""
"The harmonic mean is the reciprocal of the arithmetic :func:`mean` of the "
"reciprocals of the data. For example, the harmonic mean of three values *a*, "
"*b* and *c* will be equivalent to ``3/(1/a + 1/b + 1/c)``.  If one of the "
"values is zero, the result will be zero."
msgstr ""
"A média harmónica é o inverso da média aritmética (:func:`mean`) dos "
"inversos dos dados. Por exemplo, a média harmónica de três valores *a*, *b* "
"e *c* será equivalente a ``3/(1/a + 1/b + 1/c)``. Se um dos valores for "
"zero, o resultado será zero."

msgid ""
"The harmonic mean is a type of average, a measure of the central location of "
"the data.  It is often appropriate when averaging ratios or rates, for "
"example speeds."
msgstr ""
"A média harmónica é um tipo de média, uma medida da localização central dos "
"dados. É frequentemente apropriada ao calcular médias de rácios ou taxas, "
"por exemplo, velocidades."

msgid ""
"Suppose a car travels 10 km at 40 km/hr, then another 10 km at 60 km/hr. "
"What is the average speed?"
msgstr ""
"Suponha que um carro viaja 10 km a 40 km/h e depois mais 10 km a 60 km/h. "
"Qual é a velocidade média?"

msgid ""
">>> harmonic_mean([40, 60])\n"
"48.0"
msgstr ""
">>> harmonic_mean([40, 60])\n"
"48.0"

msgid ""
"Suppose a car travels 40 km/hr for 5 km, and when traffic clears, speeds-up "
"to 60 km/hr for the remaining 30 km of the journey. What is the average "
"speed?"
msgstr ""
"Suponha que um carro viaja a 40 km/h durante 5 km e, quando o trânsito "
"desimpede, acelera para 60 km/h durante os restantes 30 km da viagem. Qual é "
"a velocidade média?"

msgid ""
">>> harmonic_mean([40, 60], weights=[5, 30])\n"
"56.0"
msgstr ""
">>> harmonic_mean([40, 60], weights=[5, 30])\n"
"56.0"

msgid ""
":exc:`StatisticsError` is raised if *data* is empty, any element is less "
"than zero, or if the weighted sum isn't positive."
msgstr ""
"É levantado :exc:`StatisticsError` se *data* estiver vazio, se algum "
"elemento for menor que zero, ou se a soma ponderada não for positiva."

msgid ""
"The current algorithm has an early-out when it encounters a zero in the "
"input.  This means that the subsequent inputs are not tested for validity.  "
"(This behavior may change in the future.)"
msgstr ""
"O algoritmo atual tem uma saída antecipada quando encontra um zero na "
"entrada. Isto significa que as entradas subsequentes não são testadas quanto "
"à validade. (Este comportamento pode mudar no futuro.)"

msgid ""
"`Kernel Density Estimation (KDE) <https://www.itm-conferences.org/articles/"
"itmconf/pdf/2018/08/itmconf_sam2018_00037.pdf>`_: Create a continuous "
"probability density function or cumulative distribution function from "
"discrete samples."
msgstr ""
"`Estimação de Densidade do Núcleo (KDE) <https://www.itm-conferences.org/"
"articles/itmconf/pdf/2018/08/itmconf_sam2018_00037.pdf>`_: Cria uma função "
"de densidade de probabilidade contínua ou uma função de distribuição "
"cumulativa a partir de amostras discretas."

msgid ""
"The basic idea is to smooth the data using `a kernel function <https://en."
"wikipedia.org/wiki/Kernel_(statistics)>`_. to help draw inferences about a "
"population from a sample."
msgstr ""
"A ideia básica é suavizar os dados usando `uma função núcleo <https://en."
"wikipedia.org/wiki/Kernel_(statistics)>`_ para ajudar a tirar inferências "
"sobre uma população a partir de uma amostra."

msgid ""
"The degree of smoothing is controlled by the scaling parameter *h* which is "
"called the bandwidth.  Smaller values emphasize local features while larger "
"values give smoother results."
msgstr ""
"O grau de suavização é controlado pelo parâmetro de escala *h*, chamado "
"largura de banda. Valores menores enfatizam características locais, enquanto "
"valores maiores dão resultados mais suaves."

msgid ""
"The *kernel* determines the relative weights of the sample data points.  "
"Generally, the choice of kernel shape does not matter as much as the more "
"influential bandwidth smoothing parameter."
msgstr ""
"O *kernel* determina os pesos relativos dos pontos de dados da amostra. "
"Geralmente, a escolha da forma do núcleo não é tão importante quanto o "
"parâmetro de suavização da largura de banda, mais influente."

msgid ""
"Kernels that give some weight to every sample point include *normal* "
"(*gauss*), *logistic*, and *sigmoid*."
msgstr ""
"Núcleos que atribuem algum peso a cada ponto da amostra incluem *normal* "
"(*gauss*), *logístico* e *sigmoide*."

msgid ""
"Kernels that only give weight to sample points within the bandwidth include "
"*rectangular* (*uniform*), *triangular*, *parabolic* (*epanechnikov*), "
"*quartic* (*biweight*), *triweight*, and *cosine*."
msgstr ""
"Núcleos que atribuem peso apenas a pontos da amostra dentro da largura de "
"banda incluem *retangular* (*uniform*), *triangular*, *parabólico* "
"(*epanechnikov*), *quártico* (*biweight*), *triweight* e *coseno*."

msgid ""
"If *cumulative* is true, will return a cumulative distribution function."
msgstr ""
"Se *cumulative* for verdadeiro, devolverá uma função de distribuição "
"cumulativa."

msgid ""
"A :exc:`StatisticsError` will be raised if the *data* sequence is empty."
msgstr ""
"Será levantado um :exc:`StatisticsError` se a sequência *data* estiver vazia."

msgid ""
"`Wikipedia has an example <https://en.wikipedia.org/wiki/"
"Kernel_density_estimation#Example>`_ where we can use :func:`kde` to "
"generate and plot a probability density function estimated from a small "
"sample:"
msgstr ""
"`A Wikipedia tem um exemplo <https://en.wikipedia.org/wiki/"
"Kernel_density_estimation#Example>`_ onde podemos usar :func:`kde` para "
"gerar e traçar uma função de densidade de probabilidade estimada a partir de "
"uma pequena amostra:"

msgid ""
">>> sample = [-2.1, -1.3, -0.4, 1.9, 5.1, 6.2]\n"
">>> f_hat = kde(sample, h=1.5)\n"
">>> xarr = [i/100 for i in range(-750, 1100)]\n"
">>> yarr = [f_hat(x) for x in xarr]"
msgstr ""
">>> sample = [-2.1, -1.3, -0.4, 1.9, 5.1, 6.2]\n"
">>> f_hat = kde(sample, h=1.5)\n"
">>> xarr = [i/100 for i in range(-750, 1100)]\n"
">>> yarr = [f_hat(x) for x in xarr]"

msgid "The points in ``xarr`` and ``yarr`` can be used to make a PDF plot:"
msgstr ""
"Os pontos em ``xarr`` e ``yarr`` podem ser usados para criar um gráfico PDF:"

msgid "Scatter plot of the estimated probability density function."
msgstr "Gráfico de dispersão da função de densidade de probabilidade estimada."

msgid ""
"Return a function that makes a random selection from the estimated "
"probability density function produced by ``kde(data, h, kernel)``."
msgstr ""
"Devolve uma função que faz uma seleção aleatória a partir da função de "
"densidade de probabilidade estimada produzida por ``kde(data, h, kernel)``."

msgid ""
"Providing a *seed* allows reproducible selections. In the future, the values "
"may change slightly as more accurate kernel inverse CDF estimates are "
"implemented.  The seed may be an integer, float, str, or bytes."
msgstr ""
"Fornecer uma *seed* permite seleções reprodutíveis. No futuro, os valores "
"podem mudar ligeiramente à medida que estimativas mais precisas da CDF "
"inversa do núcleo forem implementadas. A *seed* pode ser um inteiro, float, "
"str ou bytes."

msgid ""
"Continuing the example for :func:`kde`, we can use :func:`kde_random` to "
"generate new random selections from an estimated probability density "
"function:"
msgstr ""
"Continuando o exemplo para :func:`kde`, podemos usar :func:`kde_random` para "
"gerar novas seleções aleatórias a partir de uma função de densidade de "
"probabilidade estimada:"

msgid ""
"Return the median (middle value) of numeric data, using the common \"mean of "
"middle two\" method.  If *data* is empty, :exc:`StatisticsError` is raised. "
"*data* can be a sequence or iterable."
msgstr ""
"Devolve a mediana (valor médio) de dados numéricos, usando o método comum de "
"\"média dos dois do meio\". Se *data* estiver vazio, é levantado :exc:"
"`StatisticsError`. *data* pode ser uma sequência ou iterável."

msgid ""
"The median is a robust measure of central location and is less affected by "
"the presence of outliers.  When the number of data points is odd, the middle "
"data point is returned:"
msgstr ""
"A mediana é uma medida robusta de localização central e é menos afetada pela "
"presença de valores atípicos. Quando o número de pontos de dados é ímpar, o "
"ponto de dados do meio é devolvido:"

msgid ""
">>> median([1, 3, 5])\n"
"3"
msgstr ""
">>> median([1, 3, 5])\n"
"3"

msgid ""
"When the number of data points is even, the median is interpolated by taking "
"the average of the two middle values:"
msgstr ""
"Quando o número de pontos de dados é par, a mediana é interpolada tomando a "
"média dos dois valores do meio:"

msgid ""
">>> median([1, 3, 5, 7])\n"
"4.0"
msgstr ""
">>> median([1, 3, 5, 7])\n"
"4.0"

msgid ""
"This is suited for when your data is discrete, and you don't mind that the "
"median may not be an actual data point."
msgstr ""
"Isto é adequado quando os seus dados são discretos e não se importa que a "
"mediana possa não ser um ponto de dados real."

msgid ""
"If the data is ordinal (supports order operations) but not numeric (doesn't "
"support addition), consider using :func:`median_low` or :func:`median_high` "
"instead."
msgstr ""
"Se os dados forem ordinais (suportam operações de ordem) mas não numéricos "
"(não suportam adição), considere usar :func:`median_low` ou :func:"
"`median_high` em vez disso."

msgid ""
"Return the low median of numeric data.  If *data* is empty, :exc:"
"`StatisticsError` is raised.  *data* can be a sequence or iterable."
msgstr ""
"Devolve a mediana baixa de dados numéricos. Se *data* estiver vazio, é "
"levantado :exc:`StatisticsError`. *data* pode ser uma sequência ou iterável."

msgid ""
"The low median is always a member of the data set.  When the number of data "
"points is odd, the middle value is returned.  When it is even, the smaller "
"of the two middle values is returned."
msgstr ""
"A mediana baixa é sempre um membro do conjunto de dados. Quando o número de "
"pontos de dados é ímpar, o valor do meio é devolvido. Quando é par, o menor "
"dos dois valores do meio é devolvido."

msgid ""
">>> median_low([1, 3, 5])\n"
"3\n"
">>> median_low([1, 3, 5, 7])\n"
"3"
msgstr ""
">>> median_low([1, 3, 5])\n"
"3\n"
">>> median_low([1, 3, 5, 7])\n"
"3"

msgid ""
"Use the low median when your data are discrete and you prefer the median to "
"be an actual data point rather than interpolated."
msgstr ""
"Use a mediana baixa quando os seus dados são discretos e prefere que a "
"mediana seja um ponto de dados real em vez de interpolado."

msgid ""
"Return the high median of data.  If *data* is empty, :exc:`StatisticsError` "
"is raised.  *data* can be a sequence or iterable."
msgstr ""
"Devolve a mediana alta dos dados. Se *data* estiver vazio, é levantado :exc:"
"`StatisticsError`. *data* pode ser uma sequência ou iterável."

msgid ""
"The high median is always a member of the data set.  When the number of data "
"points is odd, the middle value is returned.  When it is even, the larger of "
"the two middle values is returned."
msgstr ""
"A mediana alta é sempre um membro do conjunto de dados. Quando o número de "
"pontos de dados é ímpar, o valor do meio é devolvido. Quando é par, o maior "
"dos dois valores do meio é devolvido."

msgid ""
">>> median_high([1, 3, 5])\n"
"3\n"
">>> median_high([1, 3, 5, 7])\n"
"5"
msgstr ""
">>> median_high([1, 3, 5])\n"
"3\n"
">>> median_high([1, 3, 5, 7])\n"
"5"

msgid ""
"Use the high median when your data are discrete and you prefer the median to "
"be an actual data point rather than interpolated."
msgstr ""
"Use a mediana alta quando os seus dados são discretos e prefere que a "
"mediana seja um ponto de dados real em vez de interpolado."

msgid ""
"Estimates the median for numeric data that has been `grouped or binned "
"<https://en.wikipedia.org/wiki/Data_binning>`_ around the midpoints of "
"consecutive, fixed-width intervals."
msgstr ""
"Estima a mediana para dados numéricos que foram `agrupados ou colocados em "
"contentores <https://en.wikipedia.org/wiki/Data_binning>`_ em torno dos "
"pontos médios de intervalos consecutivos de largura fixa."

msgid ""
"The *data* can be any iterable of numeric data with each value being exactly "
"the midpoint of a bin.  At least one value must be present."
msgstr ""
"Os *data* podem ser qualquer iterável de dados numéricos, com cada valor a "
"ser exatamente o ponto médio de um contentor. Pelo menos um valor deve estar "
"presente."

msgid "The *interval* is the width of each bin."
msgstr "O *interval* é a largura de cada contentor."

msgid ""
"For example, demographic information may have been summarized into "
"consecutive ten-year age groups with each group being represented by the 5-"
"year midpoints of the intervals:"
msgstr ""
"Por exemplo, informações demográficas podem ter sido resumidas em grupos "
"etários consecutivos de dez anos, com cada grupo representado pelos pontos "
"médios de cinco anos dos intervalos:"

msgid ""
">>> from collections import Counter\n"
">>> demographics = Counter({\n"
"...    25: 172,   # 20 to 30 years old\n"
"...    35: 484,   # 30 to 40 years old\n"
"...    45: 387,   # 40 to 50 years old\n"
"...    55:  22,   # 50 to 60 years old\n"
"...    65:   6,   # 60 to 70 years old\n"
"... })\n"
"..."
msgstr ""

msgid ""
"The 50th percentile (median) is the 536th person out of the 1071 member "
"cohort.  That person is in the 30 to 40 year old age group."
msgstr ""
"O percentil 50 (mediana) é a 536ª pessoa de um grupo de 1071 membros. Essa "
"pessoa está no grupo etário de 30 a 40 anos."

msgid ""
"The regular :func:`median` function would assume that everyone in the "
"tricenarian age group was exactly 35 years old.  A more tenable assumption "
"is that the 484 members of that age group are evenly distributed between 30 "
"and 40.  For that, we use :func:`median_grouped`:"
msgstr ""
"A função :func:`median` normal assumiria que todos no grupo etário de 30 "
"anos tinham exatamente 35 anos. Uma suposição mais sustentável é que os 484 "
"membros desse grupo etário estão uniformemente distribuídos entre 30 e 40. "
"Para isso, usamos :func:`median_grouped`:"

msgid ""
">>> data = list(demographics.elements())\n"
">>> median(data)\n"
"35\n"
">>> round(median_grouped(data, interval=10), 1)\n"
"37.5"
msgstr ""
">>> data = list(demographics.elements())\n"
">>> median(data)\n"
"35\n"
">>> round(median_grouped(data, interval=10), 1)\n"
"37.5"

msgid ""
"The caller is responsible for making sure the data points are separated by "
"exact multiples of *interval*.  This is essential for getting a correct "
"result.  The function does not check this precondition."
msgstr ""
"O chamador é responsável por garantir que os pontos de dados estejam "
"separados por múltiplos exatos de *interval*. Isto é essencial para obter um "
"resultado correto. A função não verifica esta pré-condição."

msgid ""
"Inputs may be any numeric type that can be coerced to a float during the "
"interpolation step."
msgstr ""
"As entradas podem ser de qualquer tipo numérico que possa ser convertido "
"para um float durante a etapa de interpolação."

msgid ""
"Return the single most common data point from discrete or nominal *data*. "
"The mode (when it exists) is the most typical value and serves as a measure "
"of central location."
msgstr ""
"Devolve o ponto de dados mais comum de dados discretos ou nominais *data*. A "
"moda (quando existe) é o valor mais típico e serve como uma medida de "
"localização central."

msgid ""
"If there are multiple modes with the same frequency, returns the first one "
"encountered in the *data*.  If the smallest or largest of those is desired "
"instead, use ``min(multimode(data))`` or ``max(multimode(data))``. If the "
"input *data* is empty, :exc:`StatisticsError` is raised."
msgstr ""
"Se houver várias modas com a mesma frequência, devolve a primeira encontrada "
"nos *data*. Se a menor ou a maior dessas for desejada, use "
"``min(multimode(data))`` ou ``max(multimode(data))``. Se os *data* de "
"entrada estiverem vazios, é levantado :exc:`StatisticsError`."

msgid ""
"``mode`` assumes discrete data and returns a single value. This is the "
"standard treatment of the mode as commonly taught in schools:"
msgstr ""
"``mode`` assume dados discretos e devolve um único valor. Este é o "
"tratamento padrão da moda, como comumente ensinado nas escolas:"

msgid ""
">>> mode([1, 1, 2, 3, 3, 3, 3, 4])\n"
"3"
msgstr ""
">>> mode([1, 1, 2, 3, 3, 3, 3, 4])\n"
"3"

msgid ""
"The mode is unique in that it is the only statistic in this package that "
"also applies to nominal (non-numeric) data:"
msgstr ""
"A moda é única, pois é a única estatística neste pacote que também se aplica "
"a dados nominais (não numéricos):"

msgid ""
">>> mode([\"red\", \"blue\", \"blue\", \"red\", \"green\", \"red\", "
"\"red\"])\n"
"'red'"
msgstr ""
">>> mode([\"vermelho\", \"azul\", \"azul\", \"vermelho\", \"verde\", "
"\"vermelho\", \"vermelho\"])\n"
"'vermelho'"

msgid ""
"Only hashable inputs are supported.  To handle type :class:`set`, consider "
"casting to :class:`frozenset`.  To handle type :class:`list`, consider "
"casting to :class:`tuple`.  For mixed or nested inputs, consider using this "
"slower quadratic algorithm that only depends on equality tests: ``max(data, "
"key=data.count)``."
msgstr ""
"Apenas entradas *hashable* são suportadas. Para lidar com o tipo :class:"
"`set`, considere converter para :class:`frozenset`. Para lidar com o tipo :"
"class:`list`, considere converter para :class:`tuple`. Para entradas mistas "
"ou aninhadas, considere usar este algoritmo quadrático mais lento que "
"depende apenas de testes de igualdade: ``max(data, key=data.count)``."

msgid ""
"Now handles multimodal datasets by returning the first mode encountered. "
"Formerly, it raised :exc:`StatisticsError` when more than one mode was found."
msgstr ""
"Agora lida com conjuntos de dados multimodais devolvendo a primeira moda "
"encontrada. Anteriormente, levantava :exc:`StatisticsError` quando mais do "
"que uma moda era encontrada."

msgid ""
"Return a list of the most frequently occurring values in the order they were "
"first encountered in the *data*.  Will return more than one result if there "
"are multiple modes or an empty list if the *data* is empty:"
msgstr ""
"Devolve uma lista dos valores mais frequentemente ocorridos, pela ordem em "
"que foram encontrados nos *data*. Devolverá mais do que um resultado se "
"houver múltiplas modas ou uma lista vazia se os *data* estiverem vazios:"

msgid ""
">>> multimode('aabbbbccddddeeffffgg')\n"
"['b', 'd', 'f']\n"
">>> multimode('')\n"
"[]"
msgstr ""
">>> multimode('aabbbbccddddeeffffgg')\n"
"['b', 'd', 'f']\n"
">>> multimode('')\n"
"[]"

msgid ""
"Return the population standard deviation (the square root of the population "
"variance).  See :func:`pvariance` for arguments and other details."
msgstr ""
"Devolve o desvio padrão populacional (a raiz quadrada da variância "
"populacional). Veja :func:`pvariance` para argumentos e outros detalhes."

msgid ""
">>> pstdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])\n"
"0.986893273527251"
msgstr ""
">>> pstdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])\n"
"0.986893273527251"

msgid ""
"Return the population variance of *data*, a non-empty sequence or iterable "
"of real-valued numbers.  Variance, or second moment about the mean, is a "
"measure of the variability (spread or dispersion) of data.  A large variance "
"indicates that the data is spread out; a small variance indicates it is "
"clustered closely around the mean."
msgstr ""
"Devolve a variância populacional de *data*, uma sequência ou iterável não "
"vazia de números reais. A variância, ou segundo momento em relação à média, "
"é uma medida da variabilidade (dispersão) dos dados. Uma grande variância "
"indica que os dados estão dispersos; uma pequena variância indica que estão "
"agrupados perto da média."

msgid ""
"If the optional second argument *mu* is given, it should be the *population* "
"mean of the *data*.  It can also be used to compute the second moment around "
"a point that is not the mean.  If it is missing or ``None`` (the default), "
"the arithmetic mean is automatically calculated."
msgstr ""
"Se o segundo argumento opcional *mu* for fornecido, deve ser a média "
"populacional dos *data*. Também pode ser usado para calcular o segundo "
"momento em relação a um ponto que não seja a média. Se estiver em falta ou "
"for ``None`` (o predefinido), a média aritmética é calculada automaticamente."

msgid ""
"Use this function to calculate the variance from the entire population.  To "
"estimate the variance from a sample, the :func:`variance` function is "
"usually a better choice."
msgstr ""
"Use esta função para calcular a variância a partir de toda a população. Para "
"estimar a variância a partir de uma amostra, a função :func:`variance` é "
"geralmente uma melhor escolha."

msgid "Raises :exc:`StatisticsError` if *data* is empty."
msgstr "Levanta :exc:`StatisticsError` se *data* estiver vazio."

msgid "Examples:"
msgstr "Exemplos:"

msgid ""
">>> data = [0.0, 0.25, 0.25, 1.25, 1.5, 1.75, 2.75, 3.25]\n"
">>> pvariance(data)\n"
"1.25"
msgstr ""
">>> data = [0.0, 0.25, 0.25, 1.25, 1.5, 1.75, 2.75, 3.25]\n"
">>> pvariance(data)\n"
"1.25"

msgid ""
"If you have already calculated the mean of your data, you can pass it as the "
"optional second argument *mu* to avoid recalculation:"
msgstr ""
"Se já calculou a média dos seus dados, pode passá-la como segundo argumento "
"opcional *mu* para evitar recalcular:"

msgid ""
">>> mu = mean(data)\n"
">>> pvariance(data, mu)\n"
"1.25"
msgstr ""
">>> mu = mean(data)\n"
">>> pvariance(data, mu)\n"
"1.25"

msgid "Decimals and Fractions are supported:"
msgstr "Decimais e Frações são suportados:"

msgid ""
">>> from decimal import Decimal as D\n"
">>> pvariance([D(\"27.5\"), D(\"30.25\"), D(\"30.25\"), D(\"34.5\"), "
"D(\"41.75\")])\n"
"Decimal('24.815')\n"
"\n"
">>> from fractions import Fraction as F\n"
">>> pvariance([F(1, 4), F(5, 4), F(1, 2)])\n"
"Fraction(13, 72)"
msgstr ""
">>> from decimal import Decimal as D\n"
">>> pvariance([D(\"27.5\"), D(\"30.25\"), D(\"30.25\"), D(\"34.5\"), "
"D(\"41.75\")])\n"
"Decimal('24.815')\n"
"\n"
">>> from fractions import Fraction as F\n"
">>> pvariance([F(1, 4), F(5, 4), F(1, 2)])\n"
"Fraction(13, 72)"

msgid ""
"When called with the entire population, this gives the population variance "
"σ².  When called on a sample instead, this is the biased sample variance s², "
"also known as variance with N degrees of freedom."
msgstr ""
"Quando chamada com toda a população, isto dá a variância populacional σ². "
"Quando chamada com uma amostra, isto é a variância amostral enviesada s², "
"também conhecida como variância com N graus de liberdade."

msgid ""
"If you somehow know the true population mean μ, you may use this function to "
"calculate the variance of a sample, giving the known population mean as the "
"second argument.  Provided the data points are a random sample of the "
"population, the result will be an unbiased estimate of the population "
"variance."
msgstr ""
"Se de alguma forma souber a média populacional verdadeira μ, pode usar esta "
"função para calcular a variância de uma amostra, dando a média populacional "
"conhecida como segundo argumento. Desde que os pontos de dados sejam uma "
"amostra aleatória da população, o resultado será uma estimativa não "
"enviesada da variância populacional."

msgid ""
"Return the sample standard deviation (the square root of the sample "
"variance).  See :func:`variance` for arguments and other details."
msgstr ""
"Devolve o desvio padrão amostral (a raiz quadrada da variância amostral). "
"Veja :func:`variance` para argumentos e outros detalhes."

msgid ""
">>> stdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])\n"
"1.0810874155219827"
msgstr ""
">>> stdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])\n"
"1.0810874155219827"

msgid ""
"Return the sample variance of *data*, an iterable of at least two real-"
"valued numbers.  Variance, or second moment about the mean, is a measure of "
"the variability (spread or dispersion) of data.  A large variance indicates "
"that the data is spread out; a small variance indicates it is clustered "
"closely around the mean."
msgstr ""
"Devolve a variância amostral de *data*, um iterável de pelo menos dois "
"números reais. A variância, ou segundo momento em relação à média, é uma "
"medida da variabilidade (dispersão) dos dados. Uma grande variância indica "
"que os dados estão dispersos; uma pequena variância indica que estão "
"agrupados perto da média."

msgid ""
"If the optional second argument *xbar* is given, it should be the *sample* "
"mean of *data*.  If it is missing or ``None`` (the default), the mean is "
"automatically calculated."
msgstr ""
"Se o segundo argumento opcional *xbar* for fornecido, deve ser a média "
"amostral dos *data*. Se estiver em falta ou for ``None`` (o predefinido), a "
"média é calculada automaticamente."

msgid ""
"Use this function when your data is a sample from a population. To calculate "
"the variance from the entire population, see :func:`pvariance`."
msgstr ""
"Use esta função quando os seus dados são uma amostra de uma população. Para "
"calcular a variância de toda a população, veja :func:`pvariance`."

msgid "Raises :exc:`StatisticsError` if *data* has fewer than two values."
msgstr "Levanta :exc:`StatisticsError` se *data* tiver menos de dois valores."

msgid ""
">>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]\n"
">>> variance(data)\n"
"1.3720238095238095"
msgstr ""
">>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]\n"
">>> variance(data)\n"
"1.3720238095238095"

msgid ""
"If you have already calculated the sample mean of your data, you can pass it "
"as the optional second argument *xbar* to avoid recalculation:"
msgstr ""
"Se já calculou a média amostral dos seus dados, pode passá-la como segundo "
"argumento opcional *xbar* para evitar recalcular:"

msgid ""
">>> m = mean(data)\n"
">>> variance(data, m)\n"
"1.3720238095238095"
msgstr ""
">>> m = mean(data)\n"
">>> variance(data, m)\n"
"1.3720238095238095"

msgid ""
"This function does not attempt to verify that you have passed the actual "
"mean as *xbar*.  Using arbitrary values for *xbar* can lead to invalid or "
"impossible results."
msgstr ""
"Esta função não tenta verificar se passou a média real como *xbar*. Usar "
"valores arbitrários para *xbar* pode levar a resultados inválidos ou "
"impossíveis."

msgid "Decimal and Fraction values are supported:"
msgstr "Valores Decimais e Frações são suportados:"

msgid ""
">>> from decimal import Decimal as D\n"
">>> variance([D(\"27.5\"), D(\"30.25\"), D(\"30.25\"), D(\"34.5\"), "
"D(\"41.75\")])\n"
"Decimal('31.01875')\n"
"\n"
">>> from fractions import Fraction as F\n"
">>> variance([F(1, 6), F(1, 2), F(5, 3)])\n"
"Fraction(67, 108)"
msgstr ""
">>> from decimal import Decimal as D\n"
">>> variance([D(\"27.5\"), D(\"30.25\"), D(\"30.25\"), D(\"34.5\"), "
"D(\"41.75\")])\n"
"Decimal('31.01875')\n"
"\n"
">>> from fractions import Fraction as F\n"
">>> variance([F(1, 6), F(1, 2), F(5, 3)])\n"
"Fraction(67, 108)"

msgid ""
"This is the sample variance s² with Bessel's correction, also known as "
"variance with N-1 degrees of freedom.  Provided that the data points are "
"representative (e.g. independent and identically distributed), the result "
"should be an unbiased estimate of the true population variance."
msgstr ""
"Esta é a variância amostral s² com a correção de Bessel, também conhecida "
"como variância com N-1 graus de liberdade. Desde que os pontos de dados "
"sejam representativos (por exemplo, independentes e identicamente "
"distribuídos), o resultado deve ser uma estimativa não enviesada da "
"variância populacional verdadeira."

msgid ""
"If you somehow know the actual population mean μ you should pass it to the :"
"func:`pvariance` function as the *mu* parameter to get the variance of a "
"sample."
msgstr ""
"Se de alguma forma souber a média populacional real μ, deve passá-la para a "
"função :func:`pvariance` como o parâmetro *mu* para obter a variância de uma "
"amostra."

msgid ""
"Divide *data* into *n* continuous intervals with equal probability. Returns "
"a list of ``n - 1`` cut points separating the intervals."
msgstr ""
"Divide *data* em *n* intervalos contínuos com probabilidade igual. Devolve "
"uma lista de ``n - 1`` pontos de corte que separam os intervalos."

msgid ""
"Set *n* to 4 for quartiles (the default).  Set *n* to 10 for deciles.  Set "
"*n* to 100 for percentiles which gives the 99 cuts points that separate "
"*data* into 100 equal sized groups.  Raises :exc:`StatisticsError` if *n* is "
"not least 1."
msgstr ""
"Defina *n* como 4 para quartis (predefinição). Defina *n* como 10 para "
"decis. Defina *n* como 100 para percentis, o que fornece os 99 pontos de "
"corte que separam *data* em 100 grupos de tamanho igual. Levanta :exc:"
"`StatisticsError` se *n* for menor que 1."

msgid ""
"The *data* can be any iterable containing sample data.  For meaningful "
"results, the number of data points in *data* should be larger than *n*. "
"Raises :exc:`StatisticsError` if there is not at least one data point."
msgstr ""
"Os *data* podem ser qualquer iterável que contenha dados amostrais. Para "
"resultados significativos, o número de pontos de dados em *data* deve ser "
"maior que *n*. Levanta :exc:`StatisticsError` se não houver pelo menos um "
"ponto de dados."

msgid ""
"The cut points are linearly interpolated from the two nearest data points.  "
"For example, if a cut point falls one-third of the distance between two "
"sample values, ``100`` and ``112``, the cut-point will evaluate to ``104``."
msgstr ""
"Os pontos de corte são interpolados linearmente a partir dos dois pontos de "
"dados mais próximos. Por exemplo, se um ponto de corte cair a um terço da "
"distância entre dois valores amostrais, ``100`` e ``112``, o ponto de corte "
"será avaliado como ``104``."

msgid ""
"The *method* for computing quantiles can be varied depending on whether the "
"*data* includes or excludes the lowest and highest possible values from the "
"population."
msgstr ""
"O *method* para calcular quantis pode variar dependendo se os *data* incluem "
"ou excluem os valores mais baixos e mais altos possíveis da população."

msgid ""
"The default *method* is \"exclusive\" and is used for data sampled from a "
"population that can have more extreme values than found in the samples.  The "
"portion of the population falling below the *i-th* of *m* sorted data points "
"is computed as ``i / (m + 1)``.  Given nine sample values, the method sorts "
"them and assigns the following percentiles: 10%, 20%, 30%, 40%, 50%, 60%, "
"70%, 80%, 90%."
msgstr ""
"O *method* predefinido é \"exclusive\" e é usado para dados amostrados de "
"uma população que pode ter valores mais extremos do que os encontrados nas "
"amostras. A porção da população que cai abaixo do *i-ésimo* de *m* pontos de "
"dados ordenados é calculada como ``i / (m + 1)``. Dados nove valores "
"amostrais, o método ordena-os e atribui os seguintes percentis: 10%, 20%, "
"30%, 40%, 50%, 60%, 70%, 80%, 90%."

msgid ""
"Setting the *method* to \"inclusive\" is used for describing population data "
"or for samples that are known to include the most extreme values from the "
"population.  The minimum value in *data* is treated as the 0th percentile "
"and the maximum value is treated as the 100th percentile. The portion of the "
"population falling below the *i-th* of *m* sorted data points is computed as "
"``(i - 1) / (m - 1)``.  Given 11 sample values, the method sorts them and "
"assigns the following percentiles: 0%, 10%, 20%, 30%, 40%, 50%, 60%, 70%, "
"80%, 90%, 100%."
msgstr ""
"Definir o *method* como \"inclusive\" é usado para descrever dados "
"populacionais ou para amostras que são conhecidas por incluir os valores "
"mais extremos da população. O valor mínimo em *data* é tratado como o "
"percentil 0 e o valor máximo é tratado como o percentil 100. A porção da "
"população que cai abaixo do *i-ésimo* de *m* pontos de dados ordenados é "
"calculada como ``(i - 1) / (m - 1)``. Dados 11 valores amostrais, o método "
"ordena-os e atribui os seguintes percentis: 0%, 10%, 20%, 30%, 40%, 50%, "
"60%, 70%, 80%, 90%, 100%."

msgid ""
"# Decile cut points for empirically sampled data\n"
">>> data = [105, 129, 87, 86, 111, 111, 89, 81, 108, 92, 110,\n"
"...         100, 75, 105, 103, 109, 76, 119, 99, 91, 103, 129,\n"
"...         106, 101, 84, 111, 74, 87, 86, 103, 103, 106, 86,\n"
"...         111, 75, 87, 102, 121, 111, 88, 89, 101, 106, 95,\n"
"...         103, 107, 101, 81, 109, 104]\n"
">>> [round(q, 1) for q in quantiles(data, n=10)]\n"
"[81.0, 86.2, 89.0, 99.4, 102.5, 103.6, 106.0, 109.8, 111.0]"
msgstr ""
"# Pontos de corte para decis de dados amostrados empiricamente\n"
">>> data = [105, 129, 87, 86, 111, 111, 89, 81, 108, 92, 110,\n"
"...         100, 75, 105, 103, 109, 76, 119, 99, 91, 103, 129,\n"
"...         106, 101, 84, 111, 74, 87, 86, 103, 103, 106, 86,\n"
"...         111, 75, 87, 102, 121, 111, 88, 89, 101, 106, 95,\n"
"...         103, 107, 101, 81, 109, 104]\n"
">>> [round(q, 1) for q in quantiles(data, n=10)]\n"
"[81.0, 86.2, 89.0, 99.4, 102.5, 103.6, 106.0, 109.8, 111.0]"

msgid ""
"No longer raises an exception for an input with only a single data point. "
"This allows quantile estimates to be built up one sample point at a time "
"becoming gradually more refined with each new data point."
msgstr ""
"Já não levanta uma exceção para uma entrada com apenas um ponto de dados. "
"Isto permite que as estimativas de quantis sejam construídas ponto a ponto, "
"tornando-se gradualmente mais refinadas com cada novo ponto de dados."

msgid ""
"Return the sample covariance of two inputs *x* and *y*. Covariance is a "
"measure of the joint variability of two inputs."
msgstr ""
"Devolve a covariância amostral de duas entradas *x* e *y*. A covariância é "
"uma medida da variabilidade conjunta de duas entradas."

msgid ""
"Both inputs must be of the same length (no less than two), otherwise :exc:"
"`StatisticsError` is raised."
msgstr ""
"Ambas as entradas devem ter o mesmo comprimento (não menos que dois), caso "
"contrário, é levantado :exc:`StatisticsError`."

msgid ""
">>> x = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
">>> y = [1, 2, 3, 1, 2, 3, 1, 2, 3]\n"
">>> covariance(x, y)\n"
"0.75\n"
">>> z = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n"
">>> covariance(x, z)\n"
"-7.5\n"
">>> covariance(z, x)\n"
"-7.5"
msgstr ""
">>> x = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
">>> y = [1, 2, 3, 1, 2, 3, 1, 2, 3]\n"
">>> covariance(x, y)\n"
"0.75\n"
">>> z = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n"
">>> covariance(x, z)\n"
"-7.5\n"
">>> covariance(z, x)\n"
"-7.5"

msgid ""
"Return the `Pearson's correlation coefficient <https://en.wikipedia.org/wiki/"
"Pearson_correlation_coefficient>`_ for two inputs. Pearson's correlation "
"coefficient *r* takes values between -1 and +1. It measures the strength and "
"direction of a linear relationship."
msgstr ""
"Devolve o `coeficiente de correlação de Pearson <https://en.wikipedia.org/"
"wiki/Pearson_correlation_coefficient>`_ para duas entradas. O coeficiente de "
"correlação de Pearson *r* assume valores entre -1 e +1. Medida da força e "
"direção de uma relação linear."

msgid ""
"If *method* is \"ranked\", computes `Spearman's rank correlation coefficient "
"<https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient>`_ "
"for two inputs. The data is replaced by ranks.  Ties are averaged so that "
"equal values receive the same rank.  The resulting coefficient measures the "
"strength of a monotonic relationship."
msgstr ""
"Se *method* for \"ranked\", calcula o `coeficiente de correlação de postos "
"de Spearman <https://en.wikipedia.org/wiki/"
"Spearman%27s_rank_correlation_coefficient>`_ para duas entradas. Os dados "
"são substituídos por postos. Os empates são médios, de modo que valores "
"iguais recebem o mesmo posto. O coeficiente resultante mede a força de uma "
"relação monótona."

msgid ""
"Spearman's correlation coefficient is appropriate for ordinal data or for "
"continuous data that doesn't meet the linear proportion requirement for "
"Pearson's correlation coefficient."
msgstr ""
"O coeficiente de correlação de Spearman é apropriado para dados ordinais ou "
"para dados contínuos que não cumprem o requisito de proporção linear para o "
"coeficiente de correlação de Pearson."

msgid ""
"Both inputs must be of the same length (no less than two), and need not to "
"be constant, otherwise :exc:`StatisticsError` is raised."
msgstr ""
"Ambas as entradas devem ter o mesmo comprimento (não menos que dois) e não "
"devem ser constantes, caso contrário, é levantado :exc:`StatisticsError`."

msgid ""
"Example with `Kepler's laws of planetary motion <https://en.wikipedia.org/"
"wiki/Kepler's_laws_of_planetary_motion>`_:"
msgstr ""
"Exemplo com as `leis de Kepler do movimento planetário <https://en.wikipedia."
"org/wiki/Kepler's_laws_of_planetary_motion>`_:"

msgid ""
">>> # Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, and  Neptune\n"
">>> orbital_period = [88, 225, 365, 687, 4331, 10_756, 30_687, 60_190]    # "
"days\n"
">>> dist_from_sun = [58, 108, 150, 228, 778, 1_400, 2_900, 4_500] # million "
"km\n"
"\n"
">>> # Show that a perfect monotonic relationship exists\n"
">>> correlation(orbital_period, dist_from_sun, method='ranked')\n"
"1.0\n"
"\n"
">>> # Observe that a linear relationship is imperfect\n"
">>> round(correlation(orbital_period, dist_from_sun), 4)\n"
"0.9882\n"
"\n"
">>> # Demonstrate Kepler's third law: There is a linear correlation\n"
">>> # between the square of the orbital period and the cube of the\n"
">>> # distance from the sun.\n"
">>> period_squared = [p * p for p in orbital_period]\n"
">>> dist_cubed = [d * d * d for d in dist_from_sun]\n"
">>> round(correlation(period_squared, dist_cubed), 4)\n"
"1.0"
msgstr ""
">>> # Mercúrio, Vénus, Terra, Marte, Júpiter, Saturno, Urano e Neptuno\n"
">>> orbital_period = [88, 225, 365, 687, 4331, 10_756, 30_687, 60_190]    # "
"dias\n"
">>> dist_from_sun = [58, 108, 150, 228, 778, 1_400, 2_900, 4_500] # milhões "
"de km\n"
"\n"
">>> # Mostra que existe uma relação monótona perfeita\n"
">>> correlation(orbital_period, dist_from_sun, method='ranked')\n"
"1.0\n"
"\n"
">>> # Observa que uma relação linear é imperfeita\n"
">>> round(correlation(orbital_period, dist_from_sun), 4)\n"
"0.9882\n"
"\n"
">>> # Demonstra a terceira lei de Kepler: Existe uma correlação linear\n"
">>> # entre o quadrado do período orbital e o cubo da\n"
">>> # distância ao sol.\n"
">>> period_squared = [p * p for p in orbital_period]\n"
">>> dist_cubed = [d * d * d for d in dist_from_sun]\n"
">>> round(correlation(period_squared, dist_cubed), 4)\n"
"1.0"

msgid "Added support for Spearman's rank correlation coefficient."
msgstr ""
"Adicionado suporte para o coeficiente de correlação de postos de Spearman."

msgid ""
"Return the slope and intercept of `simple linear regression <https://en."
"wikipedia.org/wiki/Simple_linear_regression>`_ parameters estimated using "
"ordinary least squares. Simple linear regression describes the relationship "
"between an independent variable *x* and a dependent variable *y* in terms of "
"this linear function:"
msgstr ""
"Devolve o declive e a interceção dos parâmetros de `regressão linear simples "
"<https://en.wikipedia.org/wiki/Simple_linear_regression>`_ estimados usando "
"mínimos quadrados ordinários. A regressão linear simples descreve a relação "
"entre uma variável independente *x* e uma variável dependente *y* em termos "
"desta função linear:"

msgid "*y = slope \\* x + intercept + noise*"
msgstr "*y = declive \\* x + interceção + ruído*"

msgid ""
"where ``slope`` and ``intercept`` are the regression parameters that are "
"estimated, and ``noise`` represents the variability of the data that was not "
"explained by the linear regression (it is equal to the difference between "
"predicted and actual values of the dependent variable)."
msgstr ""
"onde ``slope`` e ``intercept`` são os parâmetros de regressão que são "
"estimados, e ``noise`` representa a variabilidade dos dados que não foi "
"explicada pela regressão linear (é igual à diferença entre os valores "
"previstos e reais da variável dependente)."

msgid ""
"Both inputs must be of the same length (no less than two), and the "
"independent variable *x* cannot be constant; otherwise a :exc:"
"`StatisticsError` is raised."
msgstr ""
"Ambas as entradas devem ter o mesmo comprimento (não menos que dois), e a "
"variável independente *x* não pode ser constante; caso contrário, é "
"levantado :exc:`StatisticsError`."

msgid ""
"For example, we can use the `release dates of the Monty Python films "
"<https://en.wikipedia.org/wiki/Monty_Python#Films>`_ to predict the "
"cumulative number of Monty Python films that would have been produced by "
"2019 assuming that they had kept the pace."
msgstr ""
"Por exemplo, podemos usar as `datas de lançamento dos filmes Monty Python "
"<https://en.wikipedia.org/wiki/Monty_Python#Films>`_ para prever o número "
"cumulativo de filmes Monty Python que teriam sido produzidos até 2019, "
"assumindo que tivessem mantido o ritmo."

msgid ""
">>> year = [1971, 1975, 1979, 1982, 1983]\n"
">>> films_total = [1, 2, 3, 4, 5]\n"
">>> slope, intercept = linear_regression(year, films_total)\n"
">>> round(slope * 2019 + intercept)\n"
"16"
msgstr ""
">>> year = [1971, 1975, 1979, 1982, 1983]\n"
">>> films_total = [1, 2, 3, 4, 5]\n"
">>> slope, intercept = linear_regression(year, films_total)\n"
">>> round(slope * 2019 + intercept)\n"
"16"

msgid ""
"If *proportional* is true, the independent variable *x* and the dependent "
"variable *y* are assumed to be directly proportional. The data is fit to a "
"line passing through the origin. Since the *intercept* will always be 0.0, "
"the underlying linear function simplifies to:"
msgstr ""
"Se *proportional* for verdadeiro, assume-se que a variável independente *x* "
"e a variável dependente *y* são diretamente proporcionais. Os dados são "
"ajustados a uma linha que passa pela origem. Uma vez que a *interceção* será "
"sempre 0.0, a função linear subjacente simplifica-se para:"

msgid "*y = slope \\* x + noise*"
msgstr "*y = declive \\* x + ruído*"

msgid ""
"Continuing the example from :func:`correlation`, we look to see how well a "
"model based on major planets can predict the orbital distances for dwarf "
"planets:"
msgstr ""
"Continuando o exemplo de :func:`correlation`, observamos quão bem um modelo "
"baseado em planetas principais pode prever as distâncias orbitais para "
"planetas anões:"

msgid ""
">>> model = linear_regression(period_squared, dist_cubed, "
"proportional=True)\n"
">>> slope = model.slope\n"
"\n"
">>> # Dwarf planets:   Pluto,  Eris,    Makemake, Haumea, Ceres\n"
">>> orbital_periods = [90_560, 204_199, 111_845, 103_410, 1_680]  # days\n"
">>> predicted_dist = [math.cbrt(slope * (p * p)) for p in orbital_periods]\n"
">>> list(map(round, predicted_dist))\n"
"[5912, 10166, 6806, 6459, 414]\n"
"\n"
">>> [5_906, 10_152, 6_796, 6_450, 414]  # actual distance in million km\n"
"[5906, 10152, 6796, 6450, 414]"
msgstr ""
">>> model = linear_regression(period_squared, dist_cubed, "
"proportional=True)\n"
">>> slope = model.slope\n"
"\n"
">>> # Planetas anões: Plutão, Éris, Makemake, Haumea, Ceres\n"
">>> orbital_periods = [90_560, 204_199, 111_845, 103_410, 1_680]  # dias\n"
">>> predicted_dist = [math.cbrt(slope * (p * p)) for p in orbital_periods]\n"
">>> list(map(round, predicted_dist))\n"
"[5912, 10166, 6806, 6459, 414]\n"
"\n"
">>> [5_906, 10_152, 6_796, 6_450, 414]  # distância real em milhões de km\n"
"[5906, 10152, 6796, 6450, 414]"

msgid "Added support for *proportional*."
msgstr "Adicionado suporte para *proportional*."

msgid "Exceptions"
msgstr "Exceções"

msgid "A single exception is defined:"
msgstr "Uma única exceção é definida:"

msgid "Subclass of :exc:`ValueError` for statistics-related exceptions."
msgstr ""
"Subclasse de :exc:`ValueError` para exceções relacionadas com estatísticas."

msgid ":class:`NormalDist` objects"
msgstr "Objetos :class:`NormalDist`"

msgid ""
":class:`NormalDist` is a tool for creating and manipulating normal "
"distributions of a `random variable <http://www.stat.yale.edu/"
"Courses/1997-98/101/ranvar.htm>`_.  It is a class that treats the mean and "
"standard deviation of data measurements as a single entity."
msgstr ""
":class:`NormalDist` é uma ferramenta para criar e manipular distribuições "
"normais de uma `variável aleatória <http://www.stat.yale.edu/"
"Courses/1997-98/101/ranvar.htm>`_. É uma classe que trata a média e o desvio "
"padrão das medições de dados como uma única entidade."

msgid ""
"Normal distributions arise from the `Central Limit Theorem <https://en."
"wikipedia.org/wiki/Central_limit_theorem>`_ and have a wide range of "
"applications in statistics."
msgstr ""
"As distribuições normais surgem do `Teorema do Limite Central <https://en."
"wikipedia.org/wiki/Central_limit_theorem>`_ e têm uma vasta gama de "
"aplicações em estatística."

msgid ""
"Returns a new *NormalDist* object where *mu* represents the `arithmetic mean "
"<https://en.wikipedia.org/wiki/Arithmetic_mean>`_ and *sigma* represents the "
"`standard deviation <https://en.wikipedia.org/wiki/Standard_deviation>`_."
msgstr ""
"Devolve um novo objeto *NormalDist* onde *mu* representa a `média aritmética "
"<https://en.wikipedia.org/wiki/Arithmetic_mean>`_ e *sigma* representa o "
"`desvio padrão <https://en.wikipedia.org/wiki/Standard_deviation>`_."

msgid "If *sigma* is negative, raises :exc:`StatisticsError`."
msgstr "Se *sigma* for negativo, levanta :exc:`StatisticsError`."

msgid ""
"A read-only property for the `arithmetic mean <https://en.wikipedia.org/wiki/"
"Arithmetic_mean>`_ of a normal distribution."
msgstr ""
"Uma propriedade de apenas leitura para a `média aritmética <https://en."
"wikipedia.org/wiki/Arithmetic_mean>`_ de uma distribuição normal."

msgid ""
"A read-only property for the `median <https://en.wikipedia.org/wiki/"
"Median>`_ of a normal distribution."
msgstr ""
"Uma propriedade de apenas leitura para a `mediana <https://en.wikipedia.org/"
"wiki/Median>`_ de uma distribuição normal."

msgid ""
"A read-only property for the `mode <https://en.wikipedia.org/wiki/"
"Mode_(statistics)>`_ of a normal distribution."
msgstr ""
"Uma propriedade de apenas leitura para a `moda <https://en.wikipedia.org/"
"wiki/Mode_(statistics)>`_ de uma distribuição normal."

msgid ""
"A read-only property for the `standard deviation <https://en.wikipedia.org/"
"wiki/Standard_deviation>`_ of a normal distribution."
msgstr ""
"Uma propriedade de apenas leitura para o `desvio padrão <https://en."
"wikipedia.org/wiki/Standard_deviation>`_ de uma distribuição normal."

msgid ""
"A read-only property for the `variance <https://en.wikipedia.org/wiki/"
"Variance>`_ of a normal distribution. Equal to the square of the standard "
"deviation."
msgstr ""
"Uma propriedade de apenas leitura para a `variância <https://en.wikipedia."
"org/wiki/Variance>`_ de uma distribuição normal. Igual ao quadrado do desvio "
"padrão."

msgid ""
"Makes a normal distribution instance with *mu* and *sigma* parameters "
"estimated from the *data* using :func:`fmean` and :func:`stdev`."
msgstr ""
"Cria uma instância de distribuição normal com parâmetros *mu* e *sigma* "
"estimados a partir dos *data* usando :func:`fmean` e :func:`stdev`."

msgid ""
"The *data* can be any :term:`iterable` and should consist of values that can "
"be converted to type :class:`float`.  If *data* does not contain at least "
"two elements, raises :exc:`StatisticsError` because it takes at least one "
"point to estimate a central value and at least two points to estimate "
"dispersion."
msgstr ""
"Os *data* podem ser qualquer :term:`iterável` e devem consistir em valores "
"que possam ser convertidos para o tipo :class:`float`. Se *data* não "
"contiver pelo menos dois elementos, levanta :exc:`StatisticsError`, porque é "
"necessário pelo menos um ponto para estimar um valor central e pelo menos "
"dois pontos para estimar a dispersão."

msgid ""
"Generates *n* random samples for a given mean and standard deviation. "
"Returns a :class:`list` of :class:`float` values."
msgstr ""
"Gera *n* amostras aleatórias para uma média e desvio padrão dados. Devolve "
"uma :class:`list` de valores :class:`float`."

msgid ""
"If *seed* is given, creates a new instance of the underlying random number "
"generator.  This is useful for creating reproducible results, even in a "
"multi-threading context."
msgstr ""
"Se *seed* for fornecido, cria uma nova instância do gerador de números "
"aleatórios subjacente. Isto é útil para criar resultados reprodutíveis, "
"mesmo num contexto de multi-threading."

msgid ""
"Switched to a faster algorithm.  To reproduce samples from previous "
"versions, use :func:`random.seed` and :func:`random.gauss`."
msgstr ""
"Mudou para um algoritmo mais rápido. Para reproduzir amostras de versões "
"anteriores, use :func:`random.seed` e :func:`random.gauss`."

msgid ""
"Using a `probability density function (pdf) <https://en.wikipedia.org/wiki/"
"Probability_density_function>`_, compute the relative likelihood that a "
"random variable *X* will be near the given value *x*.  Mathematically, it is "
"the limit of the ratio ``P(x <= X < x+dx) / dx`` as *dx* approaches zero."
msgstr ""
"Usando uma `função de densidade de probabilidade (pdf) <https://en.wikipedia."
"org/wiki/Probability_density_function>`_, calcula a probabilidade relativa "
"de que uma variável aleatória *X* esteja próxima do valor dado *x*. "
"Matematicamente, é o limite da razão ``P(x <= X < x+dx) / dx`` à medida que "
"*dx* se aproxima de zero."

msgid ""
"The relative likelihood is computed as the probability of a sample occurring "
"in a narrow range divided by the width of the range (hence the word "
"\"density\").  Since the likelihood is relative to other points, its value "
"can be greater than ``1.0``."
msgstr ""
"A probabilidade relativa é calculada como a probabilidade de uma amostra "
"ocorrer numa faixa estreita dividida pela largura da faixa (daí a palavra "
"\"densidade\"). Uma vez que a probabilidade é relativa a outros pontos, o "
"seu valor pode ser maior que ``1.0``."

msgid ""
"Using a `cumulative distribution function (cdf) <https://en.wikipedia.org/"
"wiki/Cumulative_distribution_function>`_, compute the probability that a "
"random variable *X* will be less than or equal to *x*.  Mathematically, it "
"is written ``P(X <= x)``."
msgstr ""
"Usando uma `função de distribuição cumulativa (cdf) <https://en.wikipedia."
"org/wiki/Cumulative_distribution_function>`_, calcula a probabilidade de que "
"uma variável aleatória *X* seja menor ou igual a *x*. Matematicamente, é "
"escrito como ``P(X <= x)``."

msgid ""
"Compute the inverse cumulative distribution function, also known as the "
"`quantile function <https://en.wikipedia.org/wiki/Quantile_function>`_ or "
"the `percent-point <https://web.archive.org/web/20190203145224/https://www."
"statisticshowto.datasciencecentral.com/inverse-distribution-function/>`_ "
"function.  Mathematically, it is written ``x : P(X <= x) = p``."
msgstr ""
"Calcula a função de distribuição cumulativa inversa, também conhecida como "
"`função quantil <https://en.wikipedia.org/wiki/Quantile_function>`_ ou a "
"`função percentil <https://web.archive.org/web/20190203145224/https://www."
"statisticshowto.datasciencecentral.com/inverse-distribution-function/>`_. "
"Matematicamente, é escrita como ``x : P(X <= x) = p``."

msgid ""
"Finds the value *x* of the random variable *X* such that the probability of "
"the variable being less than or equal to that value equals the given "
"probability *p*."
msgstr ""
"Encontra o valor *x* da variável aleatória *X* de tal forma que a "
"probabilidade da variável ser menor ou igual a esse valor seja igual à "
"probabilidade dada *p*."

msgid ""
"Measures the agreement between two normal probability distributions. Returns "
"a value between 0.0 and 1.0 giving `the overlapping area for the two "
"probability density functions <https://www.rasch.org/rmt/rmt101r.htm>`_."
msgstr ""
"Medida da concordância entre duas distribuições de probabilidade normal. "
"Devolve um valor entre 0.0 e 1.0 que dá `a área de sobreposição para as duas "
"funções de densidade de probabilidade <https://www.rasch.org/rmt/rmt101r."
"htm>`_."

msgid ""
"Divide the normal distribution into *n* continuous intervals with equal "
"probability.  Returns a list of (n - 1) cut points separating the intervals."
msgstr ""
"Divide a distribuição normal em *n* intervalos contínuos com probabilidade "
"igual. Devolve uma lista de (n - 1) pontos de corte que separam os "
"intervalos."

msgid ""
"Set *n* to 4 for quartiles (the default).  Set *n* to 10 for deciles. Set "
"*n* to 100 for percentiles which gives the 99 cuts points that separate the "
"normal distribution into 100 equal sized groups."
msgstr ""
"Defina *n* como 4 para quartis (predefinição). Defina *n* como 10 para "
"decis. Defina *n* como 100 para percentis, o que fornece os 99 pontos de "
"corte que separam a distribuição normal em 100 grupos de tamanho igual."

msgid ""
"Compute the `Standard Score <https://www.statisticshowto.com/probability-and-"
"statistics/z-score/>`_ describing *x* in terms of the number of standard "
"deviations above or below the mean of the normal distribution: ``(x - "
"mean) / stdev``."
msgstr ""
"Calcula o `Standard Score <https://www.statisticshowto.com/probability-and-"
"statistics/z-score/>`_ descrevendo *x* em termos do número de desvios padrão "
"acima ou abaixo da média da distribuição normal: ``(x - mean) / stdev``."

msgid ""
"Instances of :class:`NormalDist` support addition, subtraction, "
"multiplication and division by a constant.  These operations are used for "
"translation and scaling.  For example:"
msgstr ""
"Instâncias de :class:`NormalDist` suportam adição, subtração, multiplicação "
"e divisão por uma constante. Estas operações são usadas para translação e "
"escalonamento. Por exemplo:"

msgid ""
">>> temperature_february = NormalDist(5, 2.5)             # Celsius\n"
">>> temperature_february * (9/5) + 32                     # Fahrenheit\n"
"NormalDist(mu=41.0, sigma=4.5)"
msgstr ""
">>> temperature_february = NormalDist(5, 2.5)             # Celsius\n"
">>> temperature_february * (9/5) + 32                     # Fahrenheit\n"
"NormalDist(mu=41.0, sigma=4.5)"

msgid ""
"Dividing a constant by an instance of :class:`NormalDist` is not supported "
"because the result wouldn't be normally distributed."
msgstr ""
"A divisão de uma constante por uma instância de :class:`NormalDist` não é "
"suportada porque o resultado não seria normalmente distribuído."

msgid ""
"Since normal distributions arise from additive effects of independent "
"variables, it is possible to `add and subtract two independent normally "
"distributed random variables <https://en.wikipedia.org/wiki/"
"Sum_of_normally_distributed_random_variables>`_ represented as instances of :"
"class:`NormalDist`.  For example:"
msgstr ""
"Uma vez que as distribuições normais surgem de efeitos aditivos de variáveis "
"independentes, é possível `adicionar e subtrair duas variáveis aleatórias "
"normalmente distribuídas e independentes <https://en.wikipedia.org/wiki/"
"Sum_of_normally_distributed_random_variables>`_, representadas como "
"instâncias de :class:`NormalDist`. Por exemplo:"

msgid ""
">>> birth_weights = NormalDist.from_samples([2.5, 3.1, 2.1, 2.4, 2.7, 3.5])\n"
">>> drug_effects = NormalDist(0.4, 0.15)\n"
">>> combined = birth_weights + drug_effects\n"
">>> round(combined.mean, 1)\n"
"3.1\n"
">>> round(combined.stdev, 1)\n"
"0.5"
msgstr ""
">>> birth_weights = NormalDist.from_samples([2.5, 3.1, 2.1, 2.4, 2.7, 3.5])\n"
">>> drug_effects = NormalDist(0.4, 0.15)\n"
">>> combined = birth_weights + drug_effects\n"
">>> round(combined.mean, 1)\n"
"3.1\n"
">>> round(combined.stdev, 1)\n"
"0.5"

msgid "Examples and Recipes"
msgstr "Exemplos e Receitas"

msgid "Classic probability problems"
msgstr "Problemas clássicos de probabilidade"

msgid ":class:`NormalDist` readily solves classic probability problems."
msgstr ""
":class:`NormalDist` resolve facilmente problemas clássicos de probabilidade."

msgid ""
"For example, given `historical data for SAT exams <https://nces.ed.gov/"
"programs/digest/d17/tables/dt17_226.40.asp>`_ showing that scores are "
"normally distributed with a mean of 1060 and a standard deviation of 195, "
"determine the percentage of students with test scores between 1100 and 1200, "
"after rounding to the nearest whole number:"
msgstr ""
"Por exemplo, dados os `dados históricos dos exames SAT <https://nces.ed.gov/"
"programs/digest/d17/tables/dt17_226.40.asp>`_, que mostram que as pontuações "
"são normalmente distribuídas com uma média de 1060 e um desvio padrão de "
"195, determine a percentagem de alunos com pontuações de teste entre 1100 e "
"1200, após arredondamento para o número inteiro mais próximo:"

msgid ""
">>> sat = NormalDist(1060, 195)\n"
">>> fraction = sat.cdf(1200 + 0.5) - sat.cdf(1100 - 0.5)\n"
">>> round(fraction * 100.0, 1)\n"
"18.4"
msgstr ""
">>> sat = NormalDist(1060, 195)\n"
">>> fraction = sat.cdf(1200 + 0.5) - sat.cdf(1100 - 0.5)\n"
">>> round(fraction * 100.0, 1)\n"
"18.4"

msgid ""
"Find the `quartiles <https://en.wikipedia.org/wiki/Quartile>`_ and `deciles "
"<https://en.wikipedia.org/wiki/Decile>`_ for the SAT scores:"
msgstr ""
"Encontre os `quartis <https://en.wikipedia.org/wiki/Quartile>`_ e `decis "
"<https://en.wikipedia.org/wiki/Decile>`_ para as pontuações do SAT:"

msgid ""
">>> list(map(round, sat.quantiles()))\n"
"[928, 1060, 1192]\n"
">>> list(map(round, sat.quantiles(n=10)))\n"
"[810, 896, 958, 1011, 1060, 1109, 1162, 1224, 1310]"
msgstr ""
">>> list(map(round, sat.quantiles()))\n"
"[928, 1060, 1192]\n"
">>> list(map(round, sat.quantiles(n=10)))\n"
"[810, 896, 958, 1011, 1060, 1109, 1162, 1224, 1310]"

msgid "Monte Carlo inputs for simulations"
msgstr "Entradas Monte Carlo para simulações"

msgid ""
"To estimate the distribution for a model that isn't easy to solve "
"analytically, :class:`NormalDist` can generate input samples for a `Monte "
"Carlo simulation <https://en.wikipedia.org/wiki/Monte_Carlo_method>`_:"
msgstr ""
"Para estimar a distribuição para um modelo que não é fácil de resolver "
"analiticamente, :class:`NormalDist` pode gerar amostras de entrada para uma "
"`simulação de Monte Carlo <https://en.wikipedia.org/wiki/"
"Monte_Carlo_method>`_:"

msgid ""
">>> def model(x, y, z):\n"
"...     return (3*x + 7*x*y - 5*y) / (11 * z)\n"
"...\n"
">>> n = 100_000\n"
">>> X = NormalDist(10, 2.5).samples(n, seed=3652260728)\n"
">>> Y = NormalDist(15, 1.75).samples(n, seed=4582495471)\n"
">>> Z = NormalDist(50, 1.25).samples(n, seed=6582483453)\n"
">>> quantiles(map(model, X, Y, Z))\n"
"[1.4591308524824727, 1.8035946855390597, 2.175091447274739]"
msgstr ""
">>> def model(x, y, z):\n"
"...     return (3*x + 7*x*y - 5*y) / (11 * z)\n"
"...\n"
">>> n = 100_000\n"
">>> X = NormalDist(10, 2.5).samples(n, seed=3652260728)\n"
">>> Y = NormalDist(15, 1.75).samples(n, seed=4582495471)\n"
">>> Z = NormalDist(50, 1.25).samples(n, seed=6582483453)\n"
">>> quantiles(map(model, X, Y, Z))\n"
"[1.4591308524824727, 1.8035946855390597, 2.175091447274739]"

msgid "Approximating binomial distributions"
msgstr "Aproximação de distribuições binomiais"

msgid ""
"Normal distributions can be used to approximate `Binomial distributions "
"<https://mathworld.wolfram.com/BinomialDistribution.html>`_ when the sample "
"size is large and when the probability of a successful trial is near 50%."
msgstr ""
"As distribuições normais podem ser usadas para aproximar `distribuições "
"binomiais <https://mathworld.wolfram.com/BinomialDistribution.html>`_ quando "
"o tamanho da amostra é grande e quando a probabilidade de um ensaio bem-"
"sucedido está perto de 50%."

msgid ""
"For example, an open source conference has 750 attendees and two rooms with "
"a 500 person capacity.  There is a talk about Python and another about Ruby. "
"In previous conferences, 65% of the attendees preferred to listen to Python "
"talks.  Assuming the population preferences haven't changed, what is the "
"probability that the Python room will stay within its capacity limits?"
msgstr ""
"Por exemplo, uma conferência de código aberto tem 750 participantes e duas "
"salas com capacidade para 500 pessoas. Há uma palestra sobre Python e outra "
"sobre Ruby. Em conferências anteriores, 65% dos participantes preferiram "
"ouvir palestras sobre Python. Assumindo que as preferências da população não "
"mudaram, qual é a probabilidade de que a sala de Python permaneça dentro dos "
"seus limites de capacidade?"

msgid ""
">>> n = 750             # Sample size\n"
">>> p = 0.65            # Preference for Python\n"
">>> q = 1.0 - p         # Preference for Ruby\n"
">>> k = 500             # Room capacity\n"
"\n"
">>> # Approximation using the cumulative normal distribution\n"
">>> from math import sqrt\n"
">>> round(NormalDist(mu=n*p, sigma=sqrt(n*p*q)).cdf(k + 0.5), 4)\n"
"0.8402\n"
"\n"
">>> # Exact solution using the cumulative binomial distribution\n"
">>> from math import comb, fsum\n"
">>> round(fsum(comb(n, r) * p**r * q**(n-r) for r in range(k+1)), 4)\n"
"0.8402\n"
"\n"
">>> # Approximation using a simulation\n"
">>> from random import seed, binomialvariate\n"
">>> seed(8675309)\n"
">>> mean(binomialvariate(n, p) <= k for i in range(10_000))\n"
"0.8406"
msgstr ""
">>> n = 750             # Tamanho da amostra\n"
">>> p = 0.65            # Preferência por Python\n"
">>> q = 1.0 - p         # Preferência por Ruby\n"
">>> k = 500             # Capacidade da sala\n"
"\n"
">>> # Aproximação usando a distribuição normal cumulativa\n"
">>> from math import sqrt\n"
">>> round(NormalDist(mu=n*p, sigma=sqrt(n*p*q)).cdf(k + 0.5), 4)\n"
"0.8402\n"
"\n"
">>> # Solução exata usando a distribuição binomial cumulativa\n"
">>> from math import comb, fsum\n"
">>> round(fsum(comb(n, r) * p**r * q**(n-r) for r in range(k+1)), 4)\n"
"0.8402\n"
"\n"
">>> # Aproximação usando uma simulação\n"
">>> from random import seed, binomialvariate\n"
">>> seed(8675309)\n"
">>> mean(binomialvariate(n, p) <= k for i in range(10_000))\n"
"0.8406"

msgid "Naive bayesian classifier"
msgstr "Classificador Naive Bayes"

msgid "Normal distributions commonly arise in machine learning problems."
msgstr ""
"Distribuições normais surgem comumente em problemas de aprendizagem "
"automática."

msgid ""
"Wikipedia has a `nice example of a Naive Bayesian Classifier <https://en."
"wikipedia.org/wiki/Naive_Bayes_classifier#Person_classification>`_. The "
"challenge is to predict a person's gender from measurements of normally "
"distributed features including height, weight, and foot size."
msgstr ""
"A Wikipedia tem um `bom exemplo de um Classificador Naive Bayes <https://en."
"wikipedia.org/wiki/Naive_Bayes_classifier#Person_classification>`_. O "
"desafio é prever o género de uma pessoa a partir de medições de "
"características normalmente distribuídas, incluindo altura, peso e tamanho "
"do pé."

msgid ""
"We're given a training dataset with measurements for eight people.  The "
"measurements are assumed to be normally distributed, so we summarize the "
"data with :class:`NormalDist`:"
msgstr ""
"É-nos fornecido um conjunto de dados de treino com medições para oito "
"pessoas. As medições são assumidas como normalmente distribuídas, por isso "
"resumimos os dados com :class:`NormalDist`:"

msgid ""
">>> height_male = NormalDist.from_samples([6, 5.92, 5.58, 5.92])\n"
">>> height_female = NormalDist.from_samples([5, 5.5, 5.42, 5.75])\n"
">>> weight_male = NormalDist.from_samples([180, 190, 170, 165])\n"
">>> weight_female = NormalDist.from_samples([100, 150, 130, 150])\n"
">>> foot_size_male = NormalDist.from_samples([12, 11, 12, 10])\n"
">>> foot_size_female = NormalDist.from_samples([6, 8, 7, 9])"
msgstr ""
">>> height_male = NormalDist.from_samples([6, 5.92, 5.58, 5.92])\n"
">>> height_female = NormalDist.from_samples([5, 5.5, 5.42, 5.75])\n"
">>> weight_male = NormalDist.from_samples([180, 190, 170, 165])\n"
">>> weight_female = NormalDist.from_samples([100, 150, 130, 150])\n"
">>> foot_size_male = NormalDist.from_samples([12, 11, 12, 10])\n"
">>> foot_size_female = NormalDist.from_samples([6, 8, 7, 9])"

msgid ""
"Next, we encounter a new person whose feature measurements are known but "
"whose gender is unknown:"
msgstr ""
"De seguida, encontramos uma nova pessoa cujas medições das características "
"são conhecidas, mas cujo género é desconhecido:"

msgid ""
">>> ht = 6.0        # height\n"
">>> wt = 130        # weight\n"
">>> fs = 8          # foot size"
msgstr ""
">>> ht = 6.0        # altura\n"
">>> wt = 130        # peso\n"
">>> fs = 8          # tamanho do pé"

msgid ""
"Starting with a 50% `prior probability <https://en.wikipedia.org/wiki/"
"Prior_probability>`_ of being male or female, we compute the posterior as "
"the prior times the product of likelihoods for the feature measurements "
"given the gender:"
msgstr ""
"Começando com uma probabilidade `a priori <https://en.wikipedia.org/wiki/"
"Prior_probability>`_ de 50% de ser masculino ou feminino, calculamos a "
"probabilidade a posteriori como a probabilidade a priori vezes o produto das "
"probabilidades para as medições das características dado o género:"

msgid ""
">>> prior_male = 0.5\n"
">>> prior_female = 0.5\n"
">>> posterior_male = (prior_male * height_male.pdf(ht) *\n"
"...                   weight_male.pdf(wt) * foot_size_male.pdf(fs))\n"
"\n"
">>> posterior_female = (prior_female * height_female.pdf(ht) *\n"
"...                     weight_female.pdf(wt) * foot_size_female.pdf(fs))"
msgstr ""
">>> prior_male = 0.5\n"
">>> prior_female = 0.5\n"
">>> posterior_male = (prior_male * height_male.pdf(ht) *\n"
"...                   weight_male.pdf(wt) * foot_size_male.pdf(fs))\n"
"\n"
">>> posterior_female = (prior_female * height_female.pdf(ht) *\n"
"...                     weight_female.pdf(wt) * foot_size_female.pdf(fs))"

msgid ""
"The final prediction goes to the largest posterior. This is known as the "
"`maximum a posteriori <https://en.wikipedia.org/wiki/"
"Maximum_a_posteriori_estimation>`_ or MAP:"
msgstr ""
"A previsão final vai para a maior probabilidade a posteriori. Isto é "
"conhecido como `máxima a posteriori <https://en.wikipedia.org/wiki/"
"Maximum_a_posteriori_estimation>`_ ou MAP:"

msgid ""
">>> 'male' if posterior_male > posterior_female else 'female'\n"
"'female'"
msgstr ""
">>> 'masculino' if posterior_male > posterior_female else 'feminino'\n"
"'feminino'"
