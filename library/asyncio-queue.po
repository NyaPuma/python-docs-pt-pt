# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# NyaPuma <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-23 14:12+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: NyaPuma <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid "Queues"
msgstr "Filas"

msgid "**Source code:** :source:`Lib/asyncio/queues.py`"
msgstr ""

msgid ""
"asyncio queues are designed to be similar to classes of the :mod:`queue` "
"module.  Although asyncio queues are not thread-safe, they are designed to "
"be used specifically in async/await code."
msgstr ""

msgid ""
"Note that methods of asyncio queues don't have a *timeout* parameter; use :"
"func:`asyncio.wait_for` function to do queue operations with a timeout."
msgstr ""

msgid "See also the `Examples`_ section below."
msgstr ""

msgid "Queue"
msgstr "Queue"

msgid "A first in, first out (FIFO) queue."
msgstr ""

msgid ""
"If *maxsize* is less than or equal to zero, the queue size is infinite.  If "
"it is an integer greater than ``0``, then ``await put()`` blocks when the "
"queue reaches *maxsize* until an item is removed by :meth:`get`."
msgstr ""

msgid ""
"Unlike the standard library threading :mod:`queue`, the size of the queue is "
"always known and can be returned by calling the :meth:`qsize` method."
msgstr ""

msgid "Removed the *loop* parameter."
msgstr "Removido o parâmetro *loop*."

msgid "This class is :ref:`not thread safe <asyncio-multithreading>`."
msgstr ""

msgid "Number of items allowed in the queue."
msgstr ""

msgid "Return ``True`` if the queue is empty, ``False`` otherwise."
msgstr "Devolve ``True`` se a fila estiver vazia, ``False`` caso contrário."

msgid "Return ``True`` if there are :attr:`maxsize` items in the queue."
msgstr ""

msgid ""
"If the queue was initialized with ``maxsize=0`` (the default), then :meth:"
"`full` never returns ``True``."
msgstr ""

msgid ""
"Remove and return an item from the queue. If queue is empty, wait until an "
"item is available."
msgstr ""

msgid ""
"Raises :exc:`QueueShutDown` if the queue has been shut down and is empty, or "
"if the queue has been shut down immediately."
msgstr ""

msgid ""
"Return an item if one is immediately available, else raise :exc:`QueueEmpty`."
msgstr ""

msgid "Block until all items in the queue have been received and processed."
msgstr ""

msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue. The count goes down whenever a consumer coroutine calls :meth:"
"`task_done` to indicate that the item was retrieved and all work on it is "
"complete.  When the count of unfinished tasks drops to zero, :meth:`join` "
"unblocks."
msgstr ""

msgid ""
"Put an item into the queue. If the queue is full, wait until a free slot is "
"available before adding the item."
msgstr ""

msgid "Raises :exc:`QueueShutDown` if the queue has been shut down."
msgstr ""

msgid "Put an item into the queue without blocking."
msgstr ""

msgid "If no free slot is immediately available, raise :exc:`QueueFull`."
msgstr ""

msgid "Return the number of items in the queue."
msgstr ""

msgid "Put a :class:`Queue` instance into a shutdown mode."
msgstr ""

msgid ""
"The queue can no longer grow. Future calls to :meth:`~Queue.put` raise :exc:"
"`QueueShutDown`. Currently blocked callers of :meth:`~Queue.put` will be "
"unblocked and will raise :exc:`QueueShutDown` in the formerly blocked thread."
msgstr ""

msgid ""
"If *immediate* is false (the default), the queue can be wound down normally "
"with :meth:`~Queue.get` calls to extract tasks that have already been loaded."
msgstr ""

msgid ""
"And if :meth:`~Queue.task_done` is called for each remaining task, a "
"pending :meth:`~Queue.join` will be unblocked normally."
msgstr ""

msgid ""
"Once the queue is empty, future calls to :meth:`~Queue.get` will raise :exc:"
"`QueueShutDown`."
msgstr ""

msgid ""
"If *immediate* is true, the queue is terminated immediately. The queue is "
"drained to be completely empty and the count of unfinished tasks is reduced "
"by the number of tasks drained. If unfinished tasks is zero, callers of :"
"meth:`~Queue.join` are unblocked.  Also, blocked callers of :meth:`~Queue."
"get` are unblocked and will raise :exc:`QueueShutDown` because the queue is "
"empty."
msgstr ""

msgid ""
"Use caution when using :meth:`~Queue.join` with *immediate* set to true. "
"This unblocks the join even when no work has been done on the tasks, "
"violating the usual invariant for joining a queue."
msgstr ""

msgid "Indicate that a formerly enqueued work item is complete."
msgstr ""

msgid ""
"Used by queue consumers. For each :meth:`~Queue.get` used to fetch a work "
"item, a subsequent call to :meth:`task_done` tells the queue that the "
"processing on the work item is complete."
msgstr ""

msgid ""
"If a :meth:`join` is currently blocking, it will resume when all items have "
"been processed (meaning that a :meth:`task_done` call was received for every "
"item that had been :meth:`~Queue.put` into the queue)."
msgstr ""

msgid ""
"Raises :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr ""

msgid "Priority Queue"
msgstr ""

msgid ""
"A variant of :class:`Queue`; retrieves entries in priority order (lowest "
"first)."
msgstr ""

msgid "Entries are typically tuples of the form ``(priority_number, data)``."
msgstr ""

msgid "LIFO Queue"
msgstr ""

msgid ""
"A variant of :class:`Queue` that retrieves most recently added entries first "
"(last in, first out)."
msgstr ""

msgid "Exceptions"
msgstr "Exceções"

msgid ""
"This exception is raised when the :meth:`~Queue.get_nowait` method is called "
"on an empty queue."
msgstr ""

msgid ""
"Exception raised when the :meth:`~Queue.put_nowait` method is called on a "
"queue that has reached its *maxsize*."
msgstr ""

msgid ""
"Exception raised when :meth:`~Queue.put` or :meth:`~Queue.get` is called on "
"a queue which has been shut down."
msgstr ""

msgid "Examples"
msgstr "Exemplos"

msgid ""
"Queues can be used to distribute workload between several concurrent tasks::"
msgstr ""

msgid ""
"import asyncio\n"
"import random\n"
"import time\n"
"\n"
"\n"
"async def worker(name, queue):\n"
"    while True:\n"
"        # Get a \"work item\" out of the queue.\n"
"        sleep_for = await queue.get()\n"
"\n"
"        # Sleep for the \"sleep_for\" seconds.\n"
"        await asyncio.sleep(sleep_for)\n"
"\n"
"        # Notify the queue that the \"work item\" has been processed.\n"
"        queue.task_done()\n"
"\n"
"        print(f'{name} has slept for {sleep_for:.2f} seconds')\n"
"\n"
"\n"
"async def main():\n"
"    # Create a queue that we will use to store our \"workload\".\n"
"    queue = asyncio.Queue()\n"
"\n"
"    # Generate random timings and put them into the queue.\n"
"    total_sleep_time = 0\n"
"    for _ in range(20):\n"
"        sleep_for = random.uniform(0.05, 1.0)\n"
"        total_sleep_time += sleep_for\n"
"        queue.put_nowait(sleep_for)\n"
"\n"
"    # Create three worker tasks to process the queue concurrently.\n"
"    tasks = []\n"
"    for i in range(3):\n"
"        task = asyncio.create_task(worker(f'worker-{i}', queue))\n"
"        tasks.append(task)\n"
"\n"
"    # Wait until the queue is fully processed.\n"
"    started_at = time.monotonic()\n"
"    await queue.join()\n"
"    total_slept_for = time.monotonic() - started_at\n"
"\n"
"    # Cancel our worker tasks.\n"
"    for task in tasks:\n"
"        task.cancel()\n"
"    # Wait until all worker tasks are cancelled.\n"
"    await asyncio.gather(*tasks, return_exceptions=True)\n"
"\n"
"    print('====')\n"
"    print(f'3 workers slept in parallel for {total_slept_for:.2f} seconds')\n"
"    print(f'total expected sleep time: {total_sleep_time:.2f} seconds')\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
