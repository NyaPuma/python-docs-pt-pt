# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# NyaPuma <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-25 14:15+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: NyaPuma <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid ":mod:`!sys.monitoring` --- Execution event monitoring"
msgstr ""

msgid ""
":mod:`sys.monitoring` is a namespace within the :mod:`sys` module, not an "
"independent module, so there is no need to ``import sys.monitoring``, simply "
"``import sys`` and then use ``sys.monitoring``."
msgstr ""

msgid ""
"This namespace provides access to the functions and constants necessary to "
"activate and control event monitoring."
msgstr ""

msgid ""
"As programs execute, events occur that might be of interest to tools that "
"monitor execution. The :mod:`sys.monitoring` namespace provides means to "
"receive callbacks when events of interest occur."
msgstr ""

msgid "The monitoring API consists of three components:"
msgstr ""

msgid "`Tool identifiers`_"
msgstr ""

msgid "`Events`_"
msgstr ""

msgid ":ref:`Callbacks <callbacks>`"
msgstr ""

msgid "Tool identifiers"
msgstr ""

msgid ""
"A tool identifier is an integer and the associated name. Tool identifiers "
"are used to discourage tools from interfering with each other and to allow "
"multiple tools to operate at the same time. Currently tools are completely "
"independent and cannot be used to monitor each other. This restriction may "
"be lifted in the future."
msgstr ""

msgid ""
"Before registering or activating events, a tool should choose an identifier. "
"Identifiers are integers in the range 0 to 5 inclusive."
msgstr ""

msgid "Registering and using tools"
msgstr ""

msgid ""
"Must be called before *tool_id* can be used. *tool_id* must be in the range "
"0 to 5 inclusive. Raises a :exc:`ValueError` if *tool_id* is in use."
msgstr ""

msgid "Unregister all events and callback functions associated with *tool_id*."
msgstr ""

msgid ""
"Should be called once a tool no longer requires *tool_id*. Will call :func:"
"`clear_tool_id` before releasing *tool_id*."
msgstr ""

msgid ""
"Returns the name of the tool if *tool_id* is in use, otherwise it returns "
"``None``. *tool_id* must be in the range 0 to 5 inclusive."
msgstr ""

msgid ""
"All IDs are treated the same by the VM with regard to events, but the "
"following IDs are pre-defined to make co-operation of tools easier::"
msgstr ""

msgid ""
"sys.monitoring.DEBUGGER_ID = 0\n"
"sys.monitoring.COVERAGE_ID = 1\n"
"sys.monitoring.PROFILER_ID = 2\n"
"sys.monitoring.OPTIMIZER_ID = 5"
msgstr ""

msgid "Events"
msgstr ""

msgid "The following events are supported:"
msgstr ""

msgid "A conditional branch goes left."
msgstr ""

msgid ""
"It is up to the tool to determine how to present \"left\" and \"right\" "
"branches. There is no guarantee which branch is \"left\" and which is "
"\"right\", except that it will be consistent for the duration of the program."
msgstr ""

msgid "A conditional branch goes right."
msgstr ""

msgid "A call in Python code (event occurs before the call)."
msgstr ""

msgid ""
"An exception raised from any callable, except for Python functions (event "
"occurs after the exit)."
msgstr ""

msgid ""
"Return from any callable, except for Python functions (event occurs after "
"the return)."
msgstr ""

msgid "An exception is handled."
msgstr ""

msgid "A VM instruction is about to be executed."
msgstr ""

msgid "An unconditional jump in the control flow graph is made."
msgstr ""

msgid ""
"An instruction is about to be executed that has a different line number from "
"the preceding instruction."
msgstr ""

msgid ""
"Resumption of a Python function (for generator and coroutine functions), "
"except for ``throw()`` calls."
msgstr ""

msgid ""
"Return from a Python function (occurs immediately before the return, the "
"callee's frame will be on the stack)."
msgstr ""

msgid ""
"Start of a Python function (occurs immediately after the call, the callee's "
"frame will be on the stack)"
msgstr ""

msgid "A Python function is resumed by a ``throw()`` call."
msgstr ""

msgid ""
"Exit from a Python function during exception unwinding. This includes "
"exceptions raised directly within the function and that are allowed to "
"continue to propagate."
msgstr ""

msgid ""
"Yield from a Python function (occurs immediately before the yield, the "
"callee's frame will be on the stack)."
msgstr ""

msgid ""
"An exception is raised, except those that cause a :monitoring-event:"
"`STOP_ITERATION` event."
msgstr ""

msgid ""
"An exception is re-raised, for example at the end of a :keyword:`finally` "
"block."
msgstr ""

msgid ""
"An artificial :exc:`StopIteration` is raised; see `the STOP_ITERATION "
"event`_."
msgstr ""

msgid "More events may be added in the future."
msgstr ""

msgid ""
"These events are attributes of the :mod:`!sys.monitoring.events` namespace. "
"Each event is represented as a power-of-2 integer constant. To define a set "
"of events, simply bitwise OR the individual events together. For example, to "
"specify both :monitoring-event:`PY_RETURN` and :monitoring-event:`PY_START` "
"events, use the expression ``PY_RETURN | PY_START``."
msgstr ""

msgid "An alias for ``0`` so users can do explicit comparisons like::"
msgstr ""

msgid ""
"if get_events(DEBUGGER_ID) == NO_EVENTS:\n"
"    ..."
msgstr ""

msgid "Setting this event deactivates all events."
msgstr ""

msgid "Local events"
msgstr ""

msgid ""
"Local events are associated with normal execution of the program and happen "
"at clearly defined locations. All local events can be disabled. The local "
"events are:"
msgstr ""

msgid ":monitoring-event:`PY_START`"
msgstr ":monitoring-event:`PY_START`"

msgid ":monitoring-event:`PY_RESUME`"
msgstr ":monitoring-event:`PY_RESUME`"

msgid ":monitoring-event:`PY_RETURN`"
msgstr ":monitoring-event:`PY_RETURN`"

msgid ":monitoring-event:`PY_YIELD`"
msgstr ":monitoring-event:`PY_YIELD`"

msgid ":monitoring-event:`CALL`"
msgstr ":monitoring-event:`CALL`"

msgid ":monitoring-event:`LINE`"
msgstr ":monitoring-event:`LINE`"

msgid ":monitoring-event:`INSTRUCTION`"
msgstr ":monitoring-event:`INSTRUCTION`"

msgid ":monitoring-event:`JUMP`"
msgstr ":monitoring-event:`JUMP`"

msgid ":monitoring-event:`BRANCH_LEFT`"
msgstr ":monitoring-event:`BRANCH_LEFT`"

msgid ":monitoring-event:`BRANCH_RIGHT`"
msgstr ":monitoring-event:`BRANCH_RIGHT`"

msgid ":monitoring-event:`STOP_ITERATION`"
msgstr ":monitoring-event:`STOP_ITERATION`"

msgid "Deprecated event"
msgstr ""

msgid "``BRANCH``"
msgstr ""

msgid ""
"The ``BRANCH`` event is deprecated in 3.14. Using :monitoring-event:"
"`BRANCH_LEFT` and :monitoring-event:`BRANCH_RIGHT` events will give much "
"better performance as they can be disabled independently."
msgstr ""

msgid "Ancillary events"
msgstr ""

msgid ""
"Ancillary events can be monitored like other events, but are controlled by "
"another event:"
msgstr ""

msgid ":monitoring-event:`C_RAISE`"
msgstr ":monitoring-event:`C_RAISE`"

msgid ":monitoring-event:`C_RETURN`"
msgstr ":monitoring-event:`C_RETURN`"

msgid ""
"The :monitoring-event:`C_RETURN` and :monitoring-event:`C_RAISE` events are "
"controlled by the :monitoring-event:`CALL` event. :monitoring-event:"
"`C_RETURN` and :monitoring-event:`C_RAISE` events will only be seen if the "
"corresponding :monitoring-event:`CALL` event is being monitored."
msgstr ""

msgid "Other events"
msgstr ""

msgid ""
"Other events are not necessarily tied to a specific location in the program "
"and cannot be individually disabled via :data:`DISABLE`."
msgstr ""

msgid "The other events that can be monitored are:"
msgstr ""

msgid ":monitoring-event:`PY_THROW`"
msgstr ":monitoring-event:`PY_THROW`"

msgid ":monitoring-event:`PY_UNWIND`"
msgstr ":monitoring-event:`PY_UNWIND`"

msgid ":monitoring-event:`RAISE`"
msgstr ":monitoring-event:`RAISE`"

msgid ":monitoring-event:`EXCEPTION_HANDLED`"
msgstr ":monitoring-event:`EXCEPTION_HANDLED`"

msgid "The STOP_ITERATION event"
msgstr ""

msgid ""
":pep:`PEP 380 <380#use-of-stopiteration-to-return-values>` specifies that a :"
"exc:`StopIteration` exception is raised when returning a value from a "
"generator or coroutine. However, this is a very inefficient way to return a "
"value, so some Python implementations, notably CPython 3.12+, do not raise "
"an exception unless it would be visible to other code."
msgstr ""

msgid ""
"To allow tools to monitor for real exceptions without slowing down "
"generators and coroutines, the :monitoring-event:`STOP_ITERATION` event is "
"provided. :monitoring-event:`STOP_ITERATION` can be locally disabled, "
"unlike :monitoring-event:`RAISE`."
msgstr ""

msgid ""
"Note that the :monitoring-event:`STOP_ITERATION` event and the :monitoring-"
"event:`RAISE` event for a :exc:`StopIteration` exception are equivalent, and "
"are treated as interchangeable when generating events. Implementations will "
"favor :monitoring-event:`STOP_ITERATION` for performance reasons, but may "
"generate a :monitoring-event:`RAISE` event with a :exc:`StopIteration`."
msgstr ""

msgid "Turning events on and off"
msgstr ""

msgid ""
"In order to monitor an event, it must be turned on and a corresponding "
"callback must be registered. Events can be turned on or off by setting the "
"events either globally and/or for a particular code object. An event will "
"trigger only once, even if it is turned on both globally and locally."
msgstr ""

msgid "Setting events globally"
msgstr ""

msgid ""
"Events can be controlled globally by modifying the set of events being "
"monitored."
msgstr ""

msgid "Returns the ``int`` representing all the active events."
msgstr ""

msgid ""
"Activates all events which are set in *event_set*. Raises a :exc:"
"`ValueError` if *tool_id* is not in use."
msgstr ""

msgid "No events are active by default."
msgstr ""

msgid "Per code object events"
msgstr ""

msgid ""
"Events can also be controlled on a per code object basis. The functions "
"defined below which accept a :class:`types.CodeType` should be prepared to "
"accept a look-alike object from functions which are not defined in Python "
"(see :ref:`c-api-monitoring`)."
msgstr ""

msgid "Returns all the :ref:`local events <monitoring-event-local>` for *code*"
msgstr ""

msgid ""
"Activates all the :ref:`local events <monitoring-event-local>` for *code* "
"which are set in *event_set*. Raises a :exc:`ValueError` if *tool_id* is not "
"in use."
msgstr ""

msgid "Disabling events"
msgstr ""

msgid ""
"A special value that can be returned from a callback function to disable "
"events for the current code location."
msgstr ""

msgid ""
":ref:`Local events <monitoring-event-local>` can be disabled for a specific "
"code location by returning :data:`sys.monitoring.DISABLE` from a callback "
"function. This does not change which events are set, or any other code "
"locations for the same event."
msgstr ""

msgid ""
"Disabling events for specific locations is very important for high "
"performance monitoring. For example, a program can be run under a debugger "
"with no overhead if the debugger disables all monitoring except for a few "
"breakpoints."
msgstr ""

msgid ""
"If :data:`DISABLE` is returned by a callback for a :ref:`global event "
"<monitoring-event-global>`, :exc:`ValueError` will be raised by the "
"interpreter in a non-specific location (that is, no traceback will be "
"provided)."
msgstr ""

msgid ""
"Enable all the events that were disabled by :data:`sys.monitoring.DISABLE` "
"for all tools."
msgstr ""

msgid "Registering callback functions"
msgstr ""

msgid "Registers the callable *func* for the *event* with the given *tool_id*"
msgstr ""

msgid ""
"If another callback was registered for the given *tool_id* and *event*, it "
"is unregistered and returned. Otherwise :func:`register_callback` returns "
"``None``."
msgstr ""

msgid ""
"Raises an :ref:`auditing event <auditing>` ``sys.monitoring."
"register_callback`` with argument ``func``."
msgstr ""

msgid ""
"Functions can be unregistered by calling ``sys.monitoring."
"register_callback(tool_id, event, None)``."
msgstr ""

msgid "Callback functions can be registered and unregistered at any time."
msgstr ""

msgid ""
"Callbacks are called only once regardless if the event is turned on both "
"globally and locally. As such, if an event could be turned on for both "
"global and local events by your code then the callback needs to be written "
"to handle either trigger."
msgstr ""

msgid "Callback function arguments"
msgstr ""

msgid ""
"A special value that is passed to a callback function to indicate that there "
"are no arguments to the call."
msgstr ""

msgid ""
"When an active event occurs, the registered callback function is called. "
"Callback functions returning an object other than :data:`DISABLE` will have "
"no effect. Different events will provide the callback function with "
"different arguments, as follows:"
msgstr ""

msgid ":monitoring-event:`PY_START` and :monitoring-event:`PY_RESUME`::"
msgstr ""

msgid "func(code: CodeType, instruction_offset: int) -> object"
msgstr ""

msgid ":monitoring-event:`PY_RETURN` and :monitoring-event:`PY_YIELD`::"
msgstr ""

msgid "func(code: CodeType, instruction_offset: int, retval: object) -> object"
msgstr ""

msgid ""
":monitoring-event:`CALL`, :monitoring-event:`C_RAISE` and :monitoring-event:"
"`C_RETURN` (*arg0* can be :data:`MISSING` specifically)::"
msgstr ""

msgid ""
"func(code: CodeType, instruction_offset: int, callable: object, arg0: "
"object) -> object"
msgstr ""

msgid ""
"*code* represents the code object where the call is being made, while "
"*callable* is the object that is about to be called (and thus triggered the "
"event). If there are no arguments, *arg0* is set to :data:`sys.monitoring."
"MISSING`."
msgstr ""

msgid ""
"For instance methods, *callable* will be the function object as found on the "
"class with *arg0* set to the instance (i.e. the ``self`` argument to the "
"method)."
msgstr ""

msgid ""
":monitoring-event:`RAISE`, :monitoring-event:`RERAISE`, :monitoring-event:"
"`EXCEPTION_HANDLED`, :monitoring-event:`PY_UNWIND`, :monitoring-event:"
"`PY_THROW` and :monitoring-event:`STOP_ITERATION`::"
msgstr ""

msgid ""
"func(code: CodeType, instruction_offset: int, exception: BaseException) -> "
"object"
msgstr ""

msgid ":monitoring-event:`LINE`::"
msgstr ""

msgid "func(code: CodeType, line_number: int) -> object"
msgstr ""

msgid ""
":monitoring-event:`BRANCH_LEFT`, :monitoring-event:`BRANCH_RIGHT` and :"
"monitoring-event:`JUMP`::"
msgstr ""

msgid ""
"func(code: CodeType, instruction_offset: int, destination_offset: int) -> "
"object"
msgstr ""

msgid "Note that the *destination_offset* is where the code will next execute."
msgstr ""

msgid ":monitoring-event:`INSTRUCTION`::"
msgstr ""
