# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-15 14:12+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid ":mod:`!dis` --- Disassembler for Python bytecode"
msgstr ":mod:`!dis` — Desmontador para bytecode Python"

msgid "**Source code:** :source:`Lib/dis.py`"
msgstr "**Código-fonte:** :source:`Lib/dis.py`"

msgid ""
"The :mod:`dis` module supports the analysis of CPython :term:`bytecode` by "
"disassembling it. The CPython bytecode which this module takes as an input "
"is defined in the file :file:`Include/opcode.h` and used by the compiler and "
"the interpreter."
msgstr ""
"O módulo :mod:`dis` suporta a análise de :term:`bytecode` CPython através da "
"sua desmontagem. O bytecode CPython que este módulo recebe como entrada está "
"definido no ficheiro :file:`Include/opcode.h` e é usado pelo compilador e "
"pelo interpretador."

msgid ""
"Bytecode is an implementation detail of the CPython interpreter.  No "
"guarantees are made that bytecode will not be added, removed, or changed "
"between versions of Python.  Use of this module should not be considered to "
"work across Python VMs or Python releases."
msgstr ""
"Bytecode é um detalhe de implementação do interpretador CPython. Não há "
"garantias de que o bytecode não será adicionado, removido ou alterado entre "
"versões do Python. O uso deste módulo não deve ser considerado para "
"funcionar em diferentes VMs Python ou versões do Python."

msgid ""
"Use 2 bytes for each instruction. Previously the number of bytes varied by "
"instruction."
msgstr ""
"Usar 2 bytes para cada instrução. Anteriormente, o número de bytes variava "
"por instrução."

msgid ""
"The argument of jump, exception handling and loop instructions is now the "
"instruction offset rather than the byte offset."
msgstr ""
"O argumento de saltos, tratamento de exceções e instruções de ciclo é agora "
"o deslocamento da instrução em vez do deslocamento de byte."

msgid ""
"Some instructions are accompanied by one or more inline cache entries, which "
"take the form of :opcode:`CACHE` instructions. These instructions are hidden "
"by default, but can be shown by passing ``show_caches=True`` to any :mod:"
"`dis` utility. Furthermore, the interpreter now adapts the bytecode to "
"specialize it for different runtime conditions. The adaptive bytecode can be "
"shown by passing ``adaptive=True``."
msgstr ""
"Algumas instruções são acompanhadas por uma ou mais entradas de cache em "
"linha, que assumem a forma de instruções :opcode:`CACHE`. Estas instruções "
"estão ocultas por predefinição, mas podem ser mostradas passando "
"``show_caches=True`` para qualquer utilitário :mod:`dis`. Além disso, o "
"interpretador agora adapta o bytecode para o especializar para diferentes "
"condições de tempo de execução. O bytecode adaptativo pode ser mostrado "
"passando ``adaptive=True``."

msgid ""
"The argument of a jump is the offset of the target instruction relative to "
"the instruction that appears immediately after the jump instruction's :"
"opcode:`CACHE` entries."
msgstr ""
"O argumento de um salto é o deslocamento da instrução de destino em relação "
"à instrução que aparece imediatamente após as entradas :opcode:`CACHE` da "
"instrução de salto."

msgid ""
"As a consequence, the presence of the :opcode:`CACHE` instructions is "
"transparent for forward jumps but needs to be taken into account when "
"reasoning about backward jumps."
msgstr ""
"Como consequência, a presença das instruções :opcode:`CACHE` é transparente "
"para saltos para a frente, mas precisa de ser tida em conta ao raciocinar "
"sobre saltos para trás."

msgid ""
"The output shows logical labels rather than instruction offsets for jump "
"targets and exception handlers. The ``-O`` command line option and the "
"``show_offsets`` argument were added."
msgstr ""
"A saída mostra etiquetas lógicas em vez de deslocamentos de instrução para "
"alvos de salto e manipuladores de exceções. A opção de linha de comandos ``-"
"O`` e o argumento ``show_offsets`` foram adicionados."

msgid ""
"The :option:`-P <dis --show-positions>` command-line option and the "
"``show_positions`` argument were added."
msgstr ""
"A opção de linha de comandos :option:`-P <dis --show-positions>` e o "
"argumento ``show_positions`` foram adicionados."

msgid "The :option:`-S <dis --specialized>` command-line option is added."
msgstr ""
"A opção de linha de comandos :option:`-S <dis --specialized>` foi adicionada."

msgid "Example: Given the function :func:`!myfunc`::"
msgstr "Exemplo: Dada a função :func:`!myfunc`:"

msgid ""
"def myfunc(alist):\n"
"    return len(alist)"
msgstr ""
"def myfunc(alist):\n"
"    return len(alist)"

msgid ""
"the following command can be used to display the disassembly of :func:`!"
"myfunc`:"
msgstr ""
"o seguinte comando pode ser usado para mostrar a desmontagem de :func:`!"
"myfunc`:"

msgid ""
">>> dis.dis(myfunc)\n"
"  2           RESUME                   0\n"
"\n"
"  3           LOAD_GLOBAL              1 (len + NULL)\n"
"              LOAD_FAST_BORROW         0 (alist)\n"
"              CALL                     1\n"
"              RETURN_VALUE"
msgstr ""
">>> dis.dis(myfunc)\n"
"  2           RESUME                   0\n"
"\n"
"  3           LOAD_GLOBAL              1 (len + NULL)\n"
"              LOAD_FAST_BORROW         0 (alist)\n"
"              CALL                     1\n"
"              RETURN_VALUE"

msgid "(The \"2\" is a line number)."
msgstr "(O \"2\" é um número de linha)."

msgid "Command-line interface"
msgstr "Interface de linha de comandos"

msgid "The :mod:`dis` module can be invoked as a script from the command line:"
msgstr ""
"O módulo :mod:`dis` pode ser invocado como um script a partir da linha de "
"comandos:"

msgid "python -m dis [-h] [-C] [-O] [-P] [-S] [infile]"
msgstr "python -m dis [-h] [-C] [-O] [-P] [-S] [ficheiro_entrada]"

msgid "The following options are accepted:"
msgstr "As seguintes opções são aceites:"

msgid "Display usage and exit."
msgstr "Mostrar utilização e sair."

msgid "Show inline caches."
msgstr "Mostrar caches em linha."

msgid "Show offsets of instructions."
msgstr "Mostrar deslocamentos das instruções."

msgid "Show positions of instructions in the source code."
msgstr "Mostrar posições das instruções no código-fonte."

msgid "Show specialized bytecode."
msgstr "Mostrar bytecode especializado."

msgid ""
"If :file:`infile` is specified, its disassembled code will be written to "
"stdout. Otherwise, disassembly is performed on compiled source code received "
"from stdin."
msgstr ""
"Se :file:`infile` for especificado, o seu código desmontado será escrito "
"para stdout. Caso contrário, a desmontagem é realizada no código-fonte "
"compilado recebido de stdin."

msgid "Bytecode analysis"
msgstr "Análise de bytecode"

msgid ""
"The bytecode analysis API allows pieces of Python code to be wrapped in a :"
"class:`Bytecode` object that provides easy access to details of the compiled "
"code."
msgstr ""
"A API de análise de bytecode permite que pedaços de código Python sejam "
"envolvidos num objeto :class:`Bytecode` que fornece acesso fácil aos "
"detalhes do código compilado."

msgid ""
"Analyse the bytecode corresponding to a function, generator, asynchronous "
"generator, coroutine, method, string of source code, or a code object (as "
"returned by :func:`compile`)."
msgstr ""
"Analisar o bytecode correspondente a uma função, gerador, gerador "
"assíncrono, corrotina, método, string de código-fonte, ou um objeto de "
"código (como retornado por :func:`compile`)."

msgid ""
"This is a convenience wrapper around many of the functions listed below, "
"most notably :func:`get_instructions`, as iterating over a :class:`Bytecode` "
"instance yields the bytecode operations as :class:`Instruction` instances."
msgstr ""
"Isto é um invólucro de conveniência em torno de muitas das funções listadas "
"abaixo, mais notavelmente :func:`get_instructions`, uma vez que iterar sobre "
"uma instância :class:`Bytecode` produz as operações de bytecode como "
"instâncias :class:`Instruction`."

msgid ""
"If *first_line* is not ``None``, it indicates the line number that should be "
"reported for the first source line in the disassembled code.  Otherwise, the "
"source line information (if any) is taken directly from the disassembled "
"code object."
msgstr ""
"Se *first_line* não for ``None``, indica o número de linha que deve ser "
"relatado para a primeira linha de código-fonte no código desmontado. Caso "
"contrário, a informação da linha de código-fonte (se houver) é obtida "
"diretamente do objeto de código desmontado."

msgid ""
"If *current_offset* is not ``None``, it refers to an instruction offset in "
"the disassembled code. Setting this means :meth:`.dis` will display a "
"\"current instruction\" marker against the specified opcode."
msgstr ""
"Se *current_offset* não for ``None``, refere-se a um deslocamento de "
"instrução no código desmontado. Definir isto significa que :meth:`.dis` irá "
"mostrar um marcador de \"instrução atual\" contra o opcode especificado."

msgid ""
"If *show_caches* is ``True``, :meth:`.dis` will display inline cache entries "
"used by the interpreter to specialize the bytecode."
msgstr ""
"Se *show_caches* for ``True``, :meth:`.dis` irá mostrar entradas de cache em "
"linha usadas pelo interpretador para especializar o bytecode."

msgid ""
"If *adaptive* is ``True``, :meth:`.dis` will display specialized bytecode "
"that may be different from the original bytecode."
msgstr ""
"Se *adaptive* for ``True``, :meth:`.dis` irá mostrar bytecode especializado "
"que pode ser diferente do bytecode original."

msgid ""
"If *show_offsets* is ``True``, :meth:`.dis` will include instruction offsets "
"in the output."
msgstr ""
"Se *show_offsets* for ``True``, :meth:`.dis` irá incluir deslocamentos de "
"instrução na saída."

msgid ""
"If *show_positions* is ``True``, :meth:`.dis` will include instruction "
"source code positions in the output."
msgstr ""
"Se *show_positions* for ``True``, :meth:`.dis` irá incluir posições de "
"código-fonte das instruções na saída."

msgid ""
"Construct a :class:`Bytecode` instance from the given traceback, setting "
"*current_offset* to the instruction responsible for the exception."
msgstr ""
"Construir uma instância :class:`Bytecode` a partir do traceback dado, "
"definindo *current_offset* para a instrução responsável pela exceção."

msgid "The compiled code object."
msgstr "O objeto de código compilado."

msgid "The first source line of the code object (if available)"
msgstr "A primeira linha de código-fonte do objeto de código (se disponível)"

msgid ""
"Return a formatted view of the bytecode operations (the same as printed by :"
"func:`dis.dis`, but returned as a multi-line string)."
msgstr ""
"Retorna uma vista formatada das operações de bytecode (a mesma que é "
"impressa por :func:`dis.dis`, mas retornada como uma string de várias "
"linhas)."

msgid ""
"Return a formatted multi-line string with detailed information about the "
"code object, like :func:`code_info`."
msgstr ""
"Retorna uma string de várias linhas formatada com informações detalhadas "
"sobre o objeto de código, como :func:`code_info`."

msgid "This can now handle coroutine and asynchronous generator objects."
msgstr ""
"Isto agora pode lidar com objetos de corrotina e geradores assíncronos."

msgid "Added the *show_caches* and *adaptive* parameters."
msgstr "Adicionados os parâmetros *show_caches* e *adaptive*."

msgid "Added the *show_offsets* parameter"
msgstr "Adicionado o parâmetro *show_offsets*"

msgid "Added the *show_positions* parameter."
msgstr "Adicionado o parâmetro *show_positions*."

msgid "Example:"
msgstr "Exemplo:"

msgid ""
">>> bytecode = dis.Bytecode(myfunc)\n"
">>> for instr in bytecode:\n"
"...     print(instr.opname)\n"
"...\n"
"RESUME\n"
"LOAD_GLOBAL\n"
"LOAD_FAST_BORROW\n"
"CALL\n"
"RETURN_VALUE"
msgstr ""
">>> bytecode = dis.Bytecode(myfunc)\n"
">>> for instr in bytecode:\n"
"...     print(instr.opname)\n"
"...\n"
"RESUME\n"
"LOAD_GLOBAL\n"
"LOAD_FAST_BORROW\n"
"CALL\n"
"RETURN_VALUE"

msgid "Analysis functions"
msgstr "Funções de análise"

msgid ""
"The :mod:`dis` module also defines the following analysis functions that "
"convert the input directly to the desired output. They can be useful if only "
"a single operation is being performed, so the intermediate analysis object "
"isn't useful:"
msgstr ""
"O módulo :mod:`dis` também define as seguintes funções de análise que "
"convertem a entrada diretamente para a saída desejada. Podem ser úteis se "
"apenas uma única operação estiver a ser realizada, de modo que o objeto de "
"análise intermédio não é útil:"

msgid ""
"Return a formatted multi-line string with detailed code object information "
"for the supplied function, generator, asynchronous generator, coroutine, "
"method, source code string or code object."
msgstr ""
"Retorna uma string de várias linhas formatada com informações detalhadas do "
"objeto de código para a função fornecida, gerador, gerador assíncrono, "
"corrotina, método, string de código-fonte ou objeto de código."

msgid ""
"Note that the exact contents of code info strings are highly implementation "
"dependent and they may change arbitrarily across Python VMs or Python "
"releases."
msgstr ""
"Note que o conteúdo exato das strings de informação de código é altamente "
"dependente da implementação e pode mudar arbitrariamente entre VMs Python ou "
"versões do Python."

msgid ""
"Print detailed code object information for the supplied function, method, "
"source code string or code object to *file* (or ``sys.stdout`` if *file* is "
"not specified)."
msgstr ""
"Imprime informações detalhadas do objeto de código para a função fornecida, "
"método, string de código-fonte ou objeto de código para *ficheiro* (ou ``sys."
"stdout`` se *ficheiro* não for especificado)."

msgid ""
"This is a convenient shorthand for ``print(code_info(x), file=file)``, "
"intended for interactive exploration at the interpreter prompt."
msgstr ""
"Isto é um atalho conveniente para ``print(code_info(x), file=file)``, "
"destinado à exploração interativa no prompt do interpretador."

msgid "Added *file* parameter."
msgstr "Adicionado o parâmetro *ficheiro*."

msgid ""
"Disassemble the *x* object.  *x* can denote either a module, a class, a "
"method, a function, a generator, an asynchronous generator, a coroutine, a "
"code object, a string of source code or a byte sequence of raw bytecode. For "
"a module, it disassembles all functions. For a class, it disassembles all "
"methods (including class and static methods). For a code object or sequence "
"of raw bytecode, it prints one line per bytecode instruction. It also "
"recursively disassembles nested code objects. These can include generator "
"expressions, nested functions, the bodies of nested classes, and the code "
"objects used for :ref:`annotation scopes <annotation-scopes>`. Strings are "
"first compiled to code objects with the :func:`compile` built-in function "
"before being disassembled.  If no object is provided, this function "
"disassembles the last traceback."
msgstr ""
"Desmontar o objeto *x*. *x* pode denotar um módulo, uma classe, um método, "
"uma função, um gerador, um gerador assíncrono, uma corrotina, um objeto de "
"código, uma string de código-fonte ou uma sequência de bytes de bytecode "
"bruto. Para um módulo, desmonta todas as funções. Para uma classe, desmonta "
"todos os métodos (incluindo métodos de classe e métodos estáticos). Para um "
"objeto de código ou sequência de bytecode bruto, imprime uma linha por "
"instrução de bytecode. Também desmonta recursivamente objetos de código "
"aninhados. Estes podem incluir expressões de gerador, funções aninhadas, os "
"corpos de classes aninhadas e os objetos de código usados para :ref:`escopos "
"de anotação <annotation-scopes>`. As strings são primeiro compiladas para "
"objetos de código com a função integrada :func:`compile` antes de serem "
"desmontadas. Se nenhum objeto for fornecido, esta função desmonta o último "
"traceback."

msgid ""
"The disassembly is written as text to the supplied *file* argument if "
"provided and to ``sys.stdout`` otherwise."
msgstr ""
"A desmontagem é escrita como texto para o argumento *ficheiro* fornecido, se "
"fornecido, e para ``sys.stdout`` caso contrário."

msgid ""
"The maximal depth of recursion is limited by *depth* unless it is ``None``. "
"``depth=0`` means no recursion."
msgstr ""
"A profundidade máxima de recursão é limitada por *depth* a menos que seja "
"``None``. ``depth=0`` significa sem recursão."

msgid ""
"If *show_caches* is ``True``, this function will display inline cache "
"entries used by the interpreter to specialize the bytecode."
msgstr ""
"Se *show_caches* for ``True``, esta função irá mostrar entradas de cache em "
"linha usadas pelo interpretador para especializar o bytecode."

msgid ""
"If *adaptive* is ``True``, this function will display specialized bytecode "
"that may be different from the original bytecode."
msgstr ""
"Se *adaptive* for ``True``, esta função irá mostrar bytecode especializado "
"que pode ser diferente do bytecode original."

msgid "Implemented recursive disassembling and added *depth* parameter."
msgstr "Implementada desmontagem recursiva e adicionado o parâmetro *depth*."

msgid "Added the *show_offsets* parameter."
msgstr "Adicionado o parâmetro *show_offsets*."

msgid ""
"Disassemble the top-of-stack function of a traceback, using the last "
"traceback if none was passed.  The instruction causing the exception is "
"indicated."
msgstr ""
"Desmontar a função no topo da pilha de um traceback, usando o último "
"traceback se nenhum for passado. A instrução que causou a exceção é indicada."

msgid ""
"Disassemble a code object, indicating the last instruction if *lasti* was "
"provided.  The output is divided in the following columns:"
msgstr ""
"Desmontar um objeto de código, indicando a última instrução se *lasti* for "
"fornecido. A saída é dividida nas seguintes colunas:"

msgid ""
"the source code location of the instruction. Complete location information "
"is shown if *show_positions* is true. Otherwise (the default) only the line "
"number is displayed."
msgstr ""
"a localização do código-fonte da instrução. Informação completa de "
"localização é mostrada se *show_positions* for verdadeiro. Caso contrário (o "
"predefinido), apenas o número da linha é mostrado."

msgid "the current instruction, indicated as ``-->``,"
msgstr "a instrução atual, indicada como ``-->``,"

msgid "a labelled instruction, indicated with ``>>``,"
msgstr "uma instrução etiquetada, indicada com ``>>``,"

msgid "the address of the instruction,"
msgstr "o endereço da instrução,"

msgid "the operation code name,"
msgstr "o nome do código de operação,"

msgid "operation parameters, and"
msgstr "parâmetros da operação, e"

msgid "interpretation of the parameters in parentheses."
msgstr "interpretação dos parâmetros entre parênteses."

msgid ""
"The parameter interpretation recognizes local and global variable names, "
"constant values, branch targets, and compare operators."
msgstr ""
"A interpretação dos parâmetros reconhece nomes de variáveis locais e "
"globais, valores constantes, alvos de ramificação e operadores de comparação."

msgid ""
"Return an iterator over the instructions in the supplied function, method, "
"source code string or code object."
msgstr ""
"Retorna um iterador sobre as instruções na função fornecida, método, string "
"de código-fonte ou objeto de código."

msgid ""
"The iterator generates a series of :class:`Instruction` named tuples giving "
"the details of each operation in the supplied code."
msgstr ""
"O iterador gera uma série de tuplos nomeados :class:`Instruction` que "
"fornecem os detalhes de cada operação no código fornecido."

msgid "The *adaptive* parameter works as it does in :func:`dis`."
msgstr "O parâmetro *adaptive* funciona como em :func:`dis`."

msgid ""
"The *show_caches* parameter is deprecated and has no effect. The iterator "
"generates the :class:`Instruction` instances with the *cache_info* field "
"populated (regardless of the value of *show_caches*) and it no longer "
"generates separate items for the cache entries."
msgstr ""
"O parâmetro *show_caches* está obsoleto e não tem efeito. O iterador gera as "
"instâncias :class:`Instruction` com o campo *cache_info* preenchido "
"(independentemente do valor de *show_caches*) e já não gera itens separados "
"para as entradas de cache."

msgid ""
"This generator function uses the :meth:`~codeobject.co_lines` method of the :"
"ref:`code object <code-objects>` *code* to find the offsets which are starts "
"of lines in the source code.  They are generated as ``(offset, lineno)`` "
"pairs."
msgstr ""
"Esta função geradora usa o método :meth:`~codeobject.co_lines` do objeto de "
"código :ref:`code object <code-objects>` *code* para encontrar os "
"deslocamentos que são inícios de linhas no código-fonte. Eles são gerados "
"como pares ``(offset, lineno)``."

msgid "Line numbers can be decreasing. Before, they were always increasing."
msgstr ""
"Os números de linha podem ser decrescentes. Antes, eram sempre crescentes."

msgid ""
"The :pep:`626` :meth:`~codeobject.co_lines` method is used instead of the :"
"attr:`~codeobject.co_firstlineno` and :attr:`~codeobject.co_lnotab` "
"attributes of the :ref:`code object <code-objects>`."
msgstr ""
"O método :pep:`626` :meth:`~codeobject.co_lines` é usado em vez dos "
"atributos :attr:`~codeobject.co_firstlineno` e :attr:`~codeobject.co_lnotab` "
"do :ref:`objeto de código <code-objects>`."

msgid ""
"Line numbers can be ``None`` for bytecode that does not map to source lines."
msgstr ""
"Os números de linha podem ser ``None`` para bytecode que não mapeia para "
"linhas de código-fonte."

msgid ""
"Detect all offsets in the raw compiled bytecode string *code* which are jump "
"targets, and return a list of these offsets."
msgstr ""
"Deteta todos os deslocamentos na string de bytecode compilado bruto *code* "
"que são alvos de salto e retorna uma lista destes deslocamentos."

msgid "Compute the stack effect of *opcode* with argument *oparg*."
msgstr "Calcular o efeito na pilha de *opcode* com argumento *oparg*."

msgid ""
"If the code has a jump target and *jump* is ``True``, :func:`~stack_effect` "
"will return the stack effect of jumping.  If *jump* is ``False``, it will "
"return the stack effect of not jumping. And if *jump* is ``None`` (default), "
"it will return the maximal stack effect of both cases."
msgstr ""
"Se o código tiver um alvo de salto e *jump* for ``True``, :func:"
"`~stack_effect` retornará o efeito na pilha de saltar. Se *jump* for "
"``False``, retornará o efeito na pilha de não saltar. E se *jump* for "
"``None`` (predefinido), retornará o efeito máximo na pilha de ambos os casos."

msgid "Added *jump* parameter."
msgstr "Adicionado o parâmetro *jump*."

msgid ""
"If ``oparg`` is omitted (or ``None``), the stack effect is now returned for "
"``oparg=0``. Previously this was an error for opcodes that use their arg. It "
"is also no longer an error to pass an integer ``oparg`` when the ``opcode`` "
"does not use it; the ``oparg`` in this case is ignored."
msgstr ""
"Se ``oparg`` for omitido (ou ``None``), o efeito na pilha é agora retornado "
"para ``oparg=0``. Anteriormente, isto era um erro para opcodes que usam o "
"seu argumento. Também já não é um erro passar um ``oparg`` inteiro quando o "
"``opcode`` não o usa; o ``oparg`` neste caso é ignorado."

msgid "Python Bytecode Instructions"
msgstr "Instruções de Bytecode Python"

msgid ""
"The :func:`get_instructions` function and :class:`Bytecode` class provide "
"details of bytecode instructions as :class:`Instruction` instances:"
msgstr ""
"A função :func:`get_instructions` e a classe :class:`Bytecode` fornecem "
"detalhes das instruções de bytecode como instâncias :class:`Instruction`:"

msgid "Details for a bytecode operation"
msgstr "Detalhes para uma operação de bytecode"

msgid ""
"numeric code for operation, corresponding to the opcode values listed below "
"and the bytecode values in the :ref:`opcode_collections`."
msgstr ""
"código numérico para a operação, correspondente aos valores de opcode "
"listados abaixo e aos valores de bytecode em :ref:`opcode_collections`."

msgid "human readable name for operation"
msgstr "nome legível para a operação"

msgid ""
"numeric code for the base operation if operation is specialized; otherwise "
"equal to :data:`opcode`"
msgstr ""
"código numérico para a operação base se a operação for especializada; caso "
"contrário, igual a :data:`opcode`"

msgid ""
"human readable name for the base operation if operation is specialized; "
"otherwise equal to :data:`opname`"
msgstr ""
"nome legível para a operação base se a operação for especializada; caso "
"contrário, igual a :data:`opname`"

msgid "numeric argument to operation (if any), otherwise ``None``"
msgstr ""
"argumento numérico para a operação (se houver), caso contrário ``None``"

msgid "alias for :data:`arg`"
msgstr "alias para :data:`arg`"

msgid "resolved arg value (if any), otherwise ``None``"
msgstr "valor do argumento resolvido (se houver), caso contrário ``None``"

msgid ""
"human readable description of operation argument (if any), otherwise an "
"empty string."
msgstr ""
"descrição legível do argumento da operação (se houver), caso contrário uma "
"string vazia."

msgid "start index of operation within bytecode sequence"
msgstr "índice de início da operação dentro da sequência de bytecode"

msgid ""
"start index of operation within bytecode sequence, including prefixed "
"``EXTENDED_ARG`` operations if present; otherwise equal to :data:`offset`"
msgstr ""
"índice de início da operação dentro da sequência de bytecode, incluindo "
"operações ``EXTENDED_ARG`` prefixadas se presentes; caso contrário, igual a :"
"data:`offset`"

msgid "start index of the cache entries following the operation"
msgstr "índice de início das entradas de cache seguintes à operação"

msgid "end index of the cache entries following the operation"
msgstr "índice final das entradas de cache seguintes à operação"

msgid "``True`` if this opcode starts a source line, otherwise ``False``"
msgstr ""
"``True`` se este opcode inicia uma linha de código-fonte, caso contrário "
"``False``"

msgid ""
"source line number associated with this opcode (if any), otherwise ``None``"
msgstr ""
"número da linha de código-fonte associado a este opcode (se houver), caso "
"contrário ``None``"

msgid "``True`` if other code jumps to here, otherwise ``False``"
msgstr "``True`` se outro código salta para aqui, caso contrário ``False``"

msgid ""
"bytecode index of the jump target if this is a jump operation, otherwise "
"``None``"
msgstr ""
"índice de bytecode do alvo de salto se esta for uma operação de salto, caso "
"contrário ``None``"

msgid ""
":class:`dis.Positions` object holding the start and end locations that are "
"covered by this instruction."
msgstr ""
"objeto :class:`dis.Positions` que contém as localizações de início e fim que "
"são cobertas por esta instrução."

msgid ""
"Information about the cache entries of this instruction, as triplets of the "
"form ``(name, size, data)``, where the ``name`` and ``size`` describe the "
"cache format and data is the contents of the cache. ``cache_info`` is "
"``None`` if the instruction does not have caches."
msgstr ""
"Informação sobre as entradas de cache desta instrução, como tripletos da "
"forma ``(name, size, data)``, onde ``name`` e ``size`` descrevem o formato "
"da cache e dados é o conteúdo da cache. ``cache_info`` é ``None`` se a "
"instrução não tiver caches."

msgid "Field ``positions`` is added."
msgstr "O campo ``positions`` foi adicionado."

msgid "Changed field ``starts_line``."
msgstr "Campo ``starts_line`` alterado."

msgid ""
"Added fields ``start_offset``, ``cache_offset``, ``end_offset``, "
"``baseopname``, ``baseopcode``, ``jump_target``, ``oparg``, ``line_number`` "
"and ``cache_info``."
msgstr ""
"Adicionados os campos ``start_offset``, ``cache_offset``, ``end_offset``, "
"``baseopname``, ``baseopcode``, ``jump_target``, ``oparg``, ``line_number`` "
"e ``cache_info``."

msgid ""
"In case the information is not available, some fields might be ``None``."
msgstr ""
"No caso de a informação não estar disponível, alguns campos podem ser "
"``None``."

msgid ""
"The Python compiler currently generates the following bytecode instructions."
msgstr ""
"O compilador Python atualmente gera as seguintes instruções de bytecode."

msgid "**General instructions**"
msgstr "**Instruções gerais**"

msgid ""
"In the following, We will refer to the interpreter stack as ``STACK`` and "
"describe operations on it as if it was a Python list. The top of the stack "
"corresponds to ``STACK[-1]`` in this language."
msgstr ""
"Em seguida, iremos referir-nos à pilha do interpretador como ``STACK`` e "
"descrever operações nela como se fosse uma lista Python. O topo da pilha "
"corresponde a ``STACK[-1]`` nesta linguagem."

msgid ""
"Do nothing code.  Used as a placeholder by the bytecode optimizer, and to "
"generate line tracing events."
msgstr ""
"Código que não faz nada. Usado como um espaço reservado pelo otimizador de "
"bytecode e para gerar eventos de rastreamento de linha."

msgid ""
"Do nothing code. Used by the interpreter to record :monitoring-event:"
"`BRANCH_LEFT` and :monitoring-event:`BRANCH_RIGHT` events for :mod:`sys."
"monitoring`."
msgstr ""
"Código que não faz nada. Usado pelo interpretador para registar eventos :"
"monitoring-event:`BRANCH_LEFT` e :monitoring-event:`BRANCH_RIGHT` para :mod:"
"`sys.monitoring`."

msgid "Removes the iterator from the top of the stack."
msgstr "Remove o iterador do topo da pilha."

msgid "Removes the top-of-stack item::"
msgstr "Remove o item do topo da pilha:"

msgid "STACK.pop()"
msgstr "STACK.pop()"

msgid ""
"Removes the top-of-stack item. Equivalent to ``POP_TOP``. Used to clean up "
"at the end of loops, hence the name."
msgstr ""
"Remove o item do topo da pilha. Equivalente a ``POP_TOP``. Usado para limpar "
"no final de ciclos, daí o nome."

msgid "Implements ``del STACK[-2]``. Used to clean up when a generator exits."
msgstr ""
"Implementa ``del STACK[-2]``. Usado para limpar quando um gerador termina."

msgid ""
"Push the i-th item to the top of the stack without removing it from its "
"original location::"
msgstr ""
"Empurra o i-ésimo item para o topo da pilha sem o remover da sua localização "
"original:"

msgid ""
"assert i > 0\n"
"STACK.append(STACK[-i])"
msgstr ""
"assert i > 0\n"
"STACK.append(STACK[-i])"

msgid "Swap the top of the stack with the i-th element::"
msgstr "Troca o topo da pilha com o i-ésimo elemento:"

msgid "STACK[-i], STACK[-1] = STACK[-1], STACK[-i]"
msgstr "STACK[-i], STACK[-1] = STACK[-1], STACK[-i]"

msgid ""
"Rather than being an actual instruction, this opcode is used to mark extra "
"space for the interpreter to cache useful data directly in the bytecode "
"itself. It is automatically hidden by all ``dis`` utilities, but can be "
"viewed with ``show_caches=True``."
msgstr ""
"Em vez de ser uma instrução real, este opcode é usado para marcar espaço "
"extra para o interpretador armazenar dados úteis diretamente no próprio "
"bytecode. É automaticamente ocultado por todas as utilidades ``dis``, mas "
"pode ser visualizado com ``show_caches=True``."

msgid ""
"Logically, this space is part of the preceding instruction. Many opcodes "
"expect to be followed by an exact number of caches, and will instruct the "
"interpreter to skip over them at runtime."
msgstr ""
"Logicamente, este espaço faz parte da instrução precedente. Muitos opcodes "
"esperam ser seguidos por um número exato de caches e instruirão o "
"interpretador a ignorá-los em tempo de execução."

msgid ""
"Populated caches can look like arbitrary instructions, so great care should "
"be taken when reading or modifying raw, adaptive bytecode containing "
"quickened data."
msgstr ""
"Caches preenchidos podem parecer instruções arbitrárias, por isso deve-se "
"ter muito cuidado ao ler ou modificar bytecode bruto e adaptativo que "
"contenha dados acelerados."

msgid "**Unary operations**"
msgstr "**Operações unárias**"

msgid ""
"Unary operations take the top of the stack, apply the operation, and push "
"the result back on the stack."
msgstr ""
"Operações unárias pegam no topo da pilha, aplicam a operação e empurram o "
"resultado de volta para a pilha."

msgid "Implements ``STACK[-1] = -STACK[-1]``."
msgstr "Implementa ``STACK[-1] = -STACK[-1]``."

msgid "Implements ``STACK[-1] = not STACK[-1]``."
msgstr "Implementa ``STACK[-1] = not STACK[-1]``."

msgid "This instruction now requires an exact :class:`bool` operand."
msgstr "Esta instrução agora requer um operando exato :class:`bool`."

msgid "Implements ``STACK[-1] = ~STACK[-1]``."
msgstr "Implementa ``STACK[-1] = ~STACK[-1]``."

msgid "Implements ``STACK[-1] = iter(STACK[-1])``."
msgstr "Implementa ``STACK[-1] = iter(STACK[-1])``."

msgid ""
"If ``STACK[-1]`` is a :term:`generator iterator` or :term:`coroutine` object "
"it is left as is.  Otherwise, implements ``STACK[-1] = iter(STACK[-1])``."
msgstr ""
"Se ``STACK[-1]`` for um :term:`iterador de gerador` ou um objeto :term:"
"`coroutine`, é deixado como está. Caso contrário, implementa ``STACK[-1] = "
"iter(STACK[-1])``."

msgid "Implements ``STACK[-1] = bool(STACK[-1])``."
msgstr "Implementa ``STACK[-1] = bool(STACK[-1])``."

msgid "**Binary and in-place operations**"
msgstr "**Operações binárias e in-place**"

msgid ""
"Binary operations remove the top two items from the stack (``STACK[-1]`` and "
"``STACK[-2]``). They perform the operation, then put the result back on the "
"stack."
msgstr ""
"Operações binárias removem os dois itens do topo da pilha (``STACK[-1]`` e "
"``STACK[-2]``). Elas realizam a operação e depois colocam o resultado de "
"volta na pilha."

msgid ""
"In-place operations are like binary operations, but the operation is done in-"
"place when ``STACK[-2]`` supports it, and the resulting ``STACK[-1]`` may be "
"(but does not have to be) the original ``STACK[-2]``."
msgstr ""
"Operações in-place são como operações binárias, mas a operação é feita in-"
"place quando ``STACK[-2]`` suporta isso, e o ``STACK[-1]`` resultante pode "
"(mas não tem de) ser o ``STACK[-2]`` original."

msgid ""
"Implements the binary and in-place operators (depending on the value of "
"*op*)::"
msgstr ""
"Implementa os operadores binários e in-place (dependendo do valor de *op*):"

msgid ""
"rhs = STACK.pop()\n"
"lhs = STACK.pop()\n"
"STACK.append(lhs op rhs)"
msgstr ""
"rhs = STACK.pop()\n"
"lhs = STACK.pop()\n"
"STACK.append(lhs op rhs)"

msgid ""
"With oparg :``NB_SUBSCR``, implements binary subscript (replaces opcode "
"``BINARY_SUBSCR``)"
msgstr ""
"Com oparg :``NB_SUBSCR``, implementa subscrito binário (substitui o opcode "
"``BINARY_SUBSCR``)"

msgid "Implements::"
msgstr "Implementa:"

msgid ""
"key = STACK.pop()\n"
"container = STACK.pop()\n"
"value = STACK.pop()\n"
"container[key] = value"
msgstr ""
"key = STACK.pop()\n"
"container = STACK.pop()\n"
"value = STACK.pop()\n"
"container[key] = value"

msgid ""
"key = STACK.pop()\n"
"container = STACK.pop()\n"
"del container[key]"
msgstr ""
"key = STACK.pop()\n"
"container = STACK.pop()\n"
"del container[key]"

msgid ""
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"container = STACK.pop()\n"
"STACK.append(container[start:end])"
msgstr ""
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"container = STACK.pop()\n"
"STACK.append(container[start:end])"

msgid ""
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"container = STACK.pop()\n"
"values = STACK.pop()\n"
"container[start:end] = value"
msgstr ""
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"container = STACK.pop()\n"
"values = STACK.pop()\n"
"container[start:end] = value"

msgid "**Coroutine opcodes**"
msgstr "**Opcodes de corrotina**"

msgid ""
"Implements ``STACK[-1] = get_awaitable(STACK[-1])``, where "
"``get_awaitable(o)`` returns ``o`` if ``o`` is a coroutine object or a "
"generator object with the :data:`~inspect.CO_ITERABLE_COROUTINE` flag, or "
"resolves ``o.__await__``."
msgstr ""
"Implementa ``STACK[-1] = get_awaitable(STACK[-1])``, onde "
"``get_awaitable(o)`` retorna ``o`` se ``o`` for um objeto de corrotina ou um "
"objeto de gerador com a flag :data:`~inspect.CO_ITERABLE_COROUTINE`, ou "
"resolve ``o.__await__``."

msgid ""
"If the ``where`` operand is nonzero, it indicates where the instruction "
"occurs:"
msgstr "Se o operando ``where`` for não nulo, indica onde a instrução ocorre:"

msgid "``1``: After a call to ``__aenter__``"
msgstr "``1``: Após uma chamada a ``__aenter__``"

msgid "``2``: After a call to ``__aexit__``"
msgstr "``2``: Após uma chamada a ``__aexit__``"

msgid "Previously, this instruction did not have an oparg."
msgstr "Anteriormente, esta instrução não tinha um oparg."

msgid "Implements ``STACK[-1] = STACK[-1].__aiter__()``."
msgstr "Implementa ``STACK[-1] = STACK[-1].__aiter__()``."

msgid "Returning awaitable objects from ``__aiter__`` is no longer supported."
msgstr "Retornar objetos aguardáveis de ``__aiter__`` já não é suportado."

msgid ""
"Implement ``STACK.append(get_awaitable(STACK[-1].__anext__()))`` to the "
"stack. See ``GET_AWAITABLE`` for details about ``get_awaitable``."
msgstr ""
"Implementa ``STACK.append(get_awaitable(STACK[-1].__anext__()))`` na pilha. "
"Veja ``GET_AWAITABLE`` para detalhes sobre ``get_awaitable``."

msgid ""
"Terminates an :keyword:`async for` loop.  Handles an exception raised when "
"awaiting a next item. The stack contains the async iterable in ``STACK[-2]`` "
"and the raised exception in ``STACK[-1]``. Both are popped. If the exception "
"is not :exc:`StopAsyncIteration`, it is re-raised."
msgstr ""
"Termina um ciclo :keyword:`async for`. Lida com uma exceção levantada ao "
"aguardar o próximo item. A pilha contém o iterável assíncrono em "
"``STACK[-2]`` e a exceção levantada em ``STACK[-1]``. Ambos são removidos. "
"Se a exceção não for :exc:`StopAsyncIteration`, é relançada."

msgid ""
"Exception representation on the stack now consist of one, not three, items."
msgstr ""
"A representação de exceção na pilha agora consiste em um, não três, itens."

msgid ""
"Handles an exception raised during a :meth:`~generator.throw` or :meth:"
"`~generator.close` call through the current frame.  If ``STACK[-1]`` is an "
"instance of :exc:`StopIteration`, pop three values from the stack and push "
"its ``value`` member.  Otherwise, re-raise ``STACK[-1]``."
msgstr ""
"Lida com uma exceção levantada durante uma chamada :meth:`~generator.throw` "
"ou :meth:`~generator.close` através do quadro atual. Se ``STACK[-1]`` for "
"uma instância de :exc:`StopIteration`, remove três valores da pilha e "
"empurra o seu membro ``value``. Caso contrário, relança ``STACK[-1]``."

msgid "**Miscellaneous opcodes**"
msgstr "**Opcodes diversos**"

msgid ""
"item = STACK.pop()\n"
"set.add(STACK[-i], item)"
msgstr ""
"item = STACK.pop()\n"
"set.add(STACK[-i], item)"

msgid "Used to implement set comprehensions."
msgstr "Usado para implementar comprehensions de conjunto."

msgid ""
"item = STACK.pop()\n"
"list.append(STACK[-i], item)"
msgstr ""
"item = STACK.pop()\n"
"list.append(STACK[-i], item)"

msgid "Used to implement list comprehensions."
msgstr "Usado para implementar comprehensions de lista."

msgid ""
"value = STACK.pop()\n"
"key = STACK.pop()\n"
"dict.__setitem__(STACK[-i], key, value)"
msgstr ""
"value = STACK.pop()\n"
"key = STACK.pop()\n"
"dict.__setitem__(STACK[-i], key, value)"

msgid "Used to implement dict comprehensions."
msgstr "Usado para implementar comprehensions de dicionário."

msgid ""
"Map value is ``STACK[-1]`` and map key is ``STACK[-2]``. Before, those were "
"reversed."
msgstr ""
"O valor do mapa é ``STACK[-1]`` e a chave do mapa é ``STACK[-2]``. Antes, "
"estavam invertidos."

msgid ""
"For all of the :opcode:`SET_ADD`, :opcode:`LIST_APPEND` and :opcode:"
"`MAP_ADD` instructions, while the added value or key/value pair is popped "
"off, the container object remains on the stack so that it is available for "
"further iterations of the loop."
msgstr ""
"Para todas as instruções :opcode:`SET_ADD`, :opcode:`LIST_APPEND` e :opcode:"
"`MAP_ADD`, embora o valor adicionado ou par chave/valor seja removido, o "
"objeto contentor permanece na pilha para que esteja disponível para mais "
"iterações do ciclo."

msgid "Returns with ``STACK[-1]`` to the caller of the function."
msgstr "Retorna com ``STACK[-1]`` para o chamador da função."

msgid "Yields ``STACK.pop()`` from a :term:`generator`."
msgstr "Produz ``STACK.pop()`` de um :term:`gerador`."

msgid "oparg set to be the stack depth."
msgstr "oparg definido para ser a profundidade da pilha."

msgid ""
"oparg set to be the exception block depth, for efficient closing of "
"generators."
msgstr ""
"oparg definido para ser a profundidade do bloco de exceção, para um "
"fechamento eficiente de geradores."

msgid ""
"oparg is ``1`` if this instruction is part of a yield-from or await, and "
"``0`` otherwise."
msgstr ""
"oparg é ``1`` se esta instrução fizer parte de um yield-from ou await, e "
"``0`` caso contrário."

msgid ""
"Checks whether ``__annotations__`` is defined in ``locals()``, if not it is "
"set up to an empty ``dict``. This opcode is only emitted if a class or "
"module body contains :term:`variable annotations <variable annotation>` "
"statically."
msgstr ""
"Verifica se ``__annotations__`` está definido em ``locals()``; se não "
"estiver, é definido como um ``dict`` vazio. Este opcode é emitido apenas se "
"um corpo de classe ou módulo contiver :term:`anotações de variáveis "
"<variable annotation>` estaticamente."

msgid ""
"Pops a value from the stack, which is used to restore the exception state."
msgstr ""
"Remove um valor da pilha, que é usado para restaurar o estado da exceção."

msgid ""
"Re-raises the exception currently on top of the stack. If oparg is non-zero, "
"pops an additional value from the stack which is used to set :attr:`~frame."
"f_lasti` of the current frame."
msgstr ""
"Relança a exceção atualmente no topo da pilha. Se oparg for diferente de "
"zero, remove um valor adicional da pilha que é usado para definir :attr:"
"`~frame.f_lasti` do quadro atual."

msgid ""
"Pops a value from the stack. Pushes the current exception to the top of the "
"stack. Pushes the value originally popped back to the stack. Used in "
"exception handlers."
msgstr ""
"Remove um valor da pilha. Empurra a exceção atual para o topo da pilha. "
"Empurra o valor originalmente removido de volta para a pilha. Usado em "
"manipuladores de exceção."

msgid ""
"Performs exception matching for ``except``. Tests whether the ``STACK[-2]`` "
"is an exception matching ``STACK[-1]``. Pops ``STACK[-1]`` and pushes the "
"boolean result of the test."
msgstr ""
"Realiza a correspondência de exceção para ``except``. Testa se ``STACK[-2]`` "
"é uma exceção que corresponde a ``STACK[-1]``. Remove ``STACK[-1]`` e "
"empurra o resultado booleano do teste."

msgid ""
"Performs exception matching for ``except*``. Applies ``split(STACK[-1])`` on "
"the exception group representing ``STACK[-2]``."
msgstr ""
"Realiza a correspondência de exceção para ``except*``. Aplica "
"``split(STACK[-1])`` no grupo de exceção que representa ``STACK[-2]``."

msgid ""
"In case of a match, pops two items from the stack and pushes the non-"
"matching subgroup (``None`` in case of full match) followed by the matching "
"subgroup. When there is no match, pops one item (the match type) and pushes "
"``None``."
msgstr ""
"Em caso de correspondência, remove dois itens da pilha e empurra o subgrupo "
"não correspondente (``None`` em caso de correspondência total) seguido do "
"subgrupo correspondente. Quando não há correspondência, remove um item (o "
"tipo de correspondência) e empurra ``None``."

msgid ""
"Calls the function in position 4 on the stack with arguments (type, val, tb) "
"representing the exception at the top of the stack. Used to implement the "
"call ``context_manager.__exit__(*exc_info())`` when an exception has "
"occurred in a :keyword:`with` statement."
msgstr ""
"Chama a função na posição 4 na pilha com argumentos (tipo, val, tb) que "
"representam a exceção no topo da pilha. Usado para implementar a chamada "
"``context_manager.__exit__(*exc_info())`` quando uma exceção ocorre numa "
"instrução :keyword:`with`."

msgid ""
"The ``__exit__`` function is in position 4 of the stack rather than 7. "
"Exception representation on the stack now consist of one, not three, items."
msgstr ""
"A função ``__exit__`` está na posição 4 da pilha em vez de 7. A "
"representação da exceção na pilha agora consiste em um, não três, itens."

msgid ""
"Pushes a common constant onto the stack. The interpreter contains a "
"hardcoded list of constants supported by this instruction.  Used by the :"
"keyword:`assert` statement to load :exc:`AssertionError`."
msgstr ""
"Empurra uma constante comum para a pilha. O interpretador contém uma lista "
"codificada de constantes suportadas por esta instrução. Usado pela "
"instrução :keyword:`assert` para carregar :exc:`AssertionError`."

msgid ""
"Pushes :func:`!builtins.__build_class__` onto the stack.  It is later called "
"to construct a class."
msgstr ""
"Empurra :func:`!builtins.__build_class__` para a pilha. É chamado mais tarde "
"para construir uma classe."

msgid ""
"Perform ``STACK.append(len(STACK[-1]))``. Used in :keyword:`match` "
"statements where comparison with structure of pattern is needed."
msgstr ""
"Realiza ``STACK.append(len(STACK[-1]))``. Usado em instruções :keyword:"
"`match` onde a comparação com a estrutura do padrão é necessária."

msgid ""
"If ``STACK[-1]`` is an instance of :class:`collections.abc.Mapping` (or, "
"more technically: if it has the :c:macro:`Py_TPFLAGS_MAPPING` flag set in "
"its :c:member:`~PyTypeObject.tp_flags`), push ``True`` onto the stack.  "
"Otherwise, push ``False``."
msgstr ""
"Se ``STACK[-1]`` for uma instância de :class:`collections.abc.Mapping` (ou, "
"mais tecnicamente: se tiver a flag :c:macro:`Py_TPFLAGS_MAPPING` definida "
"em :c:member:`~PyTypeObject.tp_flags`), empurra ``True`` para a pilha. Caso "
"contrário, empurra ``False``."

msgid ""
"If ``STACK[-1]`` is an instance of :class:`collections.abc.Sequence` and is "
"*not* an instance of :class:`str`/:class:`bytes`/:class:`bytearray` (or, "
"more technically: if it has the :c:macro:`Py_TPFLAGS_SEQUENCE` flag set in "
"its :c:member:`~PyTypeObject.tp_flags`), push ``True`` onto the stack.  "
"Otherwise, push ``False``."
msgstr ""
"Se ``STACK[-1]`` for uma instância de :class:`collections.abc.Sequence` e "
"*não* for uma instância de :class:`str`/:class:`bytes`/:class:`bytearray` "
"(ou, mais tecnicamente: se tiver a flag :c:macro:`Py_TPFLAGS_SEQUENCE` "
"definida em :c:member:`~PyTypeObject.tp_flags`), empurra ``True`` para a "
"pilha. Caso contrário, empurra ``False``."

msgid ""
"``STACK[-1]`` is a tuple of mapping keys, and ``STACK[-2]`` is the match "
"subject. If ``STACK[-2]`` contains all of the keys in ``STACK[-1]``, push a :"
"class:`tuple` containing the corresponding values. Otherwise, push ``None``."
msgstr ""
"``STACK[-1]`` é um tuplo de chaves de mapeamento, e ``STACK[-2]`` é o "
"assunto de correspondência. Se ``STACK[-2]`` contiver todas as chaves em "
"``STACK[-1]``, empurra um :class:`tuple` contendo os valores "
"correspondentes. Caso contrário, empurra ``None``."

msgid ""
"Previously, this instruction also pushed a boolean value indicating success "
"(``True``) or failure (``False``)."
msgstr ""
"Anteriormente, esta instrução também empurrava um valor booleano indicando "
"sucesso (``True``) ou falha (``False``)."

msgid ""
"Implements ``name = STACK.pop()``. *namei* is the index of *name* in the "
"attribute :attr:`~codeobject.co_names` of the :ref:`code object <code-"
"objects>`. The compiler tries to use :opcode:`STORE_FAST` or :opcode:"
"`STORE_GLOBAL` if possible."
msgstr ""
"Implementa ``name = STACK.pop()``. *namei* é o índice de *name* no atributo :"
"attr:`~codeobject.co_names` do :ref:`objeto de código <code-objects>`. O "
"compilador tenta usar :opcode:`STORE_FAST` ou :opcode:`STORE_GLOBAL` se "
"possível."

msgid ""
"Implements ``del name``, where *namei* is the index into :attr:`~codeobject."
"co_names` attribute of the :ref:`code object <code-objects>`."
msgstr ""
"Implementa ``del name``, onde *namei* é o índice no atributo :attr:"
"`~codeobject.co_names` do :ref:`objeto de código <code-objects>`."

msgid ""
"Unpacks ``STACK[-1]`` into *count* individual values, which are put onto the "
"stack right-to-left. Require there to be exactly *count* values.::"
msgstr ""
"Desempacota ``STACK[-1]`` em *count* valores individuais, que são colocados "
"na pilha da direita para a esquerda. Requer que haja exatamente *count* "
"valores."

msgid ""
"assert(len(STACK[-1]) == count)\n"
"STACK.extend(STACK.pop()[:-count-1:-1])"
msgstr ""
"assert(len(STACK[-1]) == count)\n"
"STACK.extend(STACK.pop()[:-count-1:-1])"

msgid ""
"Implements assignment with a starred target: Unpacks an iterable in "
"``STACK[-1]`` into individual values, where the total number of values can "
"be smaller than the number of items in the iterable: one of the new values "
"will be a list of all leftover items."
msgstr ""
"Implementa atribuição com um alvo estrelado: Desempacota um iterável em "
"``STACK[-1]`` em valores individuais, onde o número total de valores pode "
"ser menor que o número de itens no iterável: um dos novos valores será uma "
"lista de todos os itens restantes."

msgid "The number of values before and after the list value is limited to 255."
msgstr "O número de valores antes e depois do valor da lista é limitado a 255."

msgid ""
"The number of values before the list value is encoded in the argument of the "
"opcode. The number of values after the list if any is encoded using an "
"``EXTENDED_ARG``. As a consequence, the argument can be seen as a two bytes "
"values where the low byte of *counts* is the number of values before the "
"list value, the high byte of *counts* the number of values after it."
msgstr ""
"O número de valores antes do valor da lista é codificado no argumento do "
"opcode. O número de valores após a lista, se houver, é codificado usando um "
"``EXTENDED_ARG``. Como consequência, o argumento pode ser visto como um "
"valor de dois bytes onde o byte baixo de *counts* é o número de valores "
"antes do valor da lista, e o byte alto de *counts* é o número de valores "
"depois."

msgid ""
"The extracted values are put onto the stack right-to-left, i.e. ``a, *b, c = "
"d`` will be stored after execution as ``STACK.extend((a, b, c))``."
msgstr ""
"Os valores extraídos são colocados na pilha da direita para a esquerda, ou "
"seja, ``a, *b, c = d`` será armazenado após a execução como ``STACK."
"extend((a, b, c))``."

msgid ""
"obj = STACK.pop()\n"
"value = STACK.pop()\n"
"obj.name = value"
msgstr ""
"obj = STACK.pop()\n"
"value = STACK.pop()\n"
"obj.name = value"

msgid ""
"where *namei* is the index of name in :attr:`~codeobject.co_names` of the :"
"ref:`code object <code-objects>`."
msgstr ""
"onde *namei* é o índice do nome em :attr:`~codeobject.co_names` do :ref:"
"`objeto de código <code-objects>`."

msgid ""
"obj = STACK.pop()\n"
"del obj.name"
msgstr ""
"obj = STACK.pop()\n"
"del obj.name"

msgid ""
"where *namei* is the index of name into :attr:`~codeobject.co_names` of the :"
"ref:`code object <code-objects>`."
msgstr ""
"onde *namei* é o índice do nome em :attr:`~codeobject.co_names` do :ref:"
"`objeto de código <code-objects>`."

msgid "Works as :opcode:`STORE_NAME`, but stores the name as a global."
msgstr "Funciona como :opcode:`STORE_NAME`, mas armazena o nome como global."

msgid "Works as :opcode:`DELETE_NAME`, but deletes a global name."
msgstr "Funciona como :opcode:`DELETE_NAME`, mas apaga um nome global."

msgid "Pushes ``co_consts[consti]`` onto the stack."
msgstr "Empurra ``co_consts[consti]`` para a pilha."

msgid ""
"Pushes the integer ``i`` onto the stack. ``i`` must be in ``range(256)``"
msgstr ""
"Empurra o inteiro ``i`` para a pilha. ``i`` deve estar em ``range(256)``."

msgid ""
"Pushes the value associated with ``co_names[namei]`` onto the stack. The "
"name is looked up within the locals, then the globals, then the builtins."
msgstr ""
"Empurra o valor associado a ``co_names[namei]`` para a pilha. O nome é "
"procurado nos locais, depois nos globais, depois nos incorporados."

msgid ""
"Pushes a reference to the locals dictionary onto the stack.  This is used to "
"prepare namespace dictionaries for :opcode:`LOAD_FROM_DICT_OR_DEREF` and :"
"opcode:`LOAD_FROM_DICT_OR_GLOBALS`."
msgstr ""
"Empurra uma referência para o dicionário de locais para a pilha. Isto é "
"usado para preparar dicionários de espaço de nomes para :opcode:"
"`LOAD_FROM_DICT_OR_DEREF` e :opcode:`LOAD_FROM_DICT_OR_GLOBALS`."

msgid ""
"Pops a mapping off the stack and looks up the value for ``co_names[namei]``. "
"If the name is not found there, looks it up in the globals and then the "
"builtins, similar to :opcode:`LOAD_GLOBAL`. This is used for loading global "
"variables in :ref:`annotation scopes <annotation-scopes>` within class "
"bodies."
msgstr ""
"Remove um mapeamento da pilha e procura o valor para ``co_names[namei]``. Se "
"o nome não for encontrado lá, procura nos globais e depois nos incorporados, "
"semelhante a :opcode:`LOAD_GLOBAL`. Isto é usado para carregar variáveis "
"globais em :ref:`escopos de anotação <annotation-scopes>` dentro de corpos "
"de classe."

msgid ""
"Constructs a new :class:`~string.templatelib.Template` instance from a tuple "
"of strings and a tuple of interpolations and pushes the resulting object "
"onto the stack::"
msgstr ""
"Constrói uma nova instância :class:`~string.templatelib.Template` a partir "
"de um tuplo de strings e um tuplo de interpolações e empurra o objeto "
"resultante para a pilha."

msgid ""
"interpolations = STACK.pop()\n"
"strings = STACK.pop()\n"
"STACK.append(_build_template(strings, interpolations))"
msgstr ""
"interpolations = STACK.pop()\n"
"strings = STACK.pop()\n"
"STACK.append(_build_template(strings, interpolations))"

msgid ""
"Constructs a new :class:`~string.templatelib.Interpolation` instance from a "
"value and its source expression and pushes the resulting object onto the "
"stack."
msgstr ""
"Constrói uma nova instância :class:`~string.templatelib.Interpolation` a "
"partir de um valor e da sua expressão de origem e empurra o objeto "
"resultante para a pilha."

msgid ""
"If no conversion or format specification is present, ``format`` is set to "
"``2``."
msgstr ""
"Se nenhuma conversão ou especificação de formato estiver presente, "
"``format`` é definido para ``2``."

msgid ""
"If the low bit of ``format`` is set, it indicates that the interpolation "
"contains a format specification."
msgstr ""
"Se o bit baixo de ``format`` estiver definido, indica que a interpolação "
"contém uma especificação de formato."

msgid ""
"If ``format >> 2`` is non-zero, it indicates that the interpolation contains "
"a conversion. The value of ``format >> 2`` is the conversion type (``0`` for "
"no conversion, ``1`` for ``!s``, ``2`` for ``!r``, and ``3`` for ``!a``)::"
msgstr ""
"Se ``format >> 2`` não for zero, indica que a interpolação contém uma "
"conversão. O valor de ``format >> 2`` é o tipo de conversão (``0`` para "
"nenhuma conversão, ``1`` para ``!s``, ``2`` para ``!r``, e ``3`` para ``!"
"a``)."

msgid ""
"conversion = format >> 2\n"
"if format & 1:\n"
"    format_spec = STACK.pop()\n"
"else:\n"
"    format_spec = None\n"
"expression = STACK.pop()\n"
"value = STACK.pop()\n"
"STACK.append(_build_interpolation(value, expression, conversion, "
"format_spec))"
msgstr ""
"conversion = format >> 2\n"
"if format & 1:\n"
"    format_spec = STACK.pop()\n"
"else:\n"
"    format_spec = None\n"
"expression = STACK.pop()\n"
"value = STACK.pop()\n"
"STACK.append(_build_interpolation(value, expression, conversion, "
"format_spec))"

msgid ""
"Creates a tuple consuming *count* items from the stack, and pushes the "
"resulting tuple onto the stack::"
msgstr ""
"Cria um tuplo consumindo *count* itens da pilha e empurra o tuplo resultante "
"para a pilha."

msgid ""
"if count == 0:\n"
"    value = ()\n"
"else:\n"
"    value = tuple(STACK[-count:])\n"
"    STACK = STACK[:-count]\n"
"\n"
"STACK.append(value)"
msgstr ""
"if count == 0:\n"
"    value = ()\n"
"else:\n"
"    value = tuple(STACK[-count:])\n"
"    STACK = STACK[:-count]\n"
"\n"
"STACK.append(value)"

msgid "Works as :opcode:`BUILD_TUPLE`, but creates a list."
msgstr "Funciona como :opcode:`BUILD_TUPLE`, mas cria uma lista."

msgid "Works as :opcode:`BUILD_TUPLE`, but creates a set."
msgstr "Funciona como :opcode:`BUILD_TUPLE`, mas cria um conjunto."

msgid ""
"Pushes a new dictionary object onto the stack.  Pops ``2 * count`` items so "
"that the dictionary holds *count* entries: ``{..., STACK[-4]: STACK[-3], "
"STACK[-2]: STACK[-1]}``."
msgstr ""
"Empurra um novo objeto de dicionário para a pilha. Remove ``2 * count`` "
"itens de modo que o dicionário contenha *count* entradas: ``{..., STACK[-4]: "
"STACK[-3], STACK[-2]: STACK[-1]}``."

msgid ""
"The dictionary is created from stack items instead of creating an empty "
"dictionary pre-sized to hold *count* items."
msgstr ""
"O dicionário é criado a partir de itens da pilha em vez de criar um "
"dicionário vazio pré-dimensionado para conter *count* itens."

msgid ""
"Concatenates *count* strings from the stack and pushes the resulting string "
"onto the stack."
msgstr ""
"Concatena *count* strings da pilha e empurra a string resultante para a "
"pilha."

msgid ""
"seq = STACK.pop()\n"
"list.extend(STACK[-i], seq)"
msgstr ""
"seq = STACK.pop()\n"
"list.extend(STACK[-i], seq)"

msgid "Used to build lists."
msgstr "Usado para construir listas."

msgid ""
"seq = STACK.pop()\n"
"set.update(STACK[-i], seq)"
msgstr ""
"seq = STACK.pop()\n"
"set.update(STACK[-i], seq)"

msgid "Used to build sets."
msgstr "Usado para construir conjuntos."

msgid ""
"map = STACK.pop()\n"
"dict.update(STACK[-i], map)"
msgstr ""
"map = STACK.pop()\n"
"dict.update(STACK[-i], map)"

msgid "Used to build dicts."
msgstr "Usado para construir dicionários."

msgid "Like :opcode:`DICT_UPDATE` but raises an exception for duplicate keys."
msgstr ""
"Semelhante a :opcode:`DICT_UPDATE`, mas levanta uma exceção para chaves "
"duplicadas."

msgid ""
"If the low bit of ``namei`` is not set, this replaces ``STACK[-1]`` with "
"``getattr(STACK[-1], co_names[namei>>1])``."
msgstr ""
"Se o bit baixo de ``namei`` não estiver definido, isto substitui "
"``STACK[-1]`` por ``getattr(STACK[-1], co_names[namei>>1])``."

msgid ""
"If the low bit of ``namei`` is set, this will attempt to load a method named "
"``co_names[namei>>1]`` from the ``STACK[-1]`` object. ``STACK[-1]`` is "
"popped. This bytecode distinguishes two cases: if ``STACK[-1]`` has a method "
"with the correct name, the bytecode pushes the unbound method and "
"``STACK[-1]``. ``STACK[-1]`` will be used as the first argument (``self``) "
"by :opcode:`CALL` or :opcode:`CALL_KW` when calling the unbound method. "
"Otherwise, ``NULL`` and the object returned by the attribute lookup are "
"pushed."
msgstr ""
"Se o bit baixo de ``namei`` estiver definido, isto tentará carregar um "
"método chamado ``co_names[namei>>1]`` do objeto ``STACK[-1]``. ``STACK[-1]`` "
"é removido. Este bytecode distingue dois casos: se ``STACK[-1]`` tiver um "
"método com o nome correto, o bytecode empurra o método não ligado e "
"``STACK[-1]``. ``STACK[-1]`` será usado como o primeiro argumento (``self``) "
"por :opcode:`CALL` ou :opcode:`CALL_KW` ao chamar o método não ligado. Caso "
"contrário, ``NULL`` e o objeto retornado pela pesquisa de atributo são "
"empurrados."

msgid ""
"If the low bit of ``namei`` is set, then a ``NULL`` or ``self`` is pushed to "
"the stack before the attribute or unbound method respectively."
msgstr ""
"Se o bit baixo de ``namei`` estiver definido, então um ``NULL`` ou ``self`` "
"é empurrado para a pilha antes do atributo ou método não ligado, "
"respetivamente."

msgid ""
"This opcode implements :func:`super`, both in its zero-argument and two-"
"argument forms (e.g. ``super().method()``, ``super().attr`` and ``super(cls, "
"self).method()``, ``super(cls, self).attr``)."
msgstr ""
"Este opcode implementa :func:`super`, tanto na sua forma de zero argumentos "
"como de dois argumentos (por exemplo, ``super().method()``, ``super().attr`` "
"e ``super(cls, self).method()``, ``super(cls, self).attr``)."

msgid "It pops three values from the stack (from top of stack down):"
msgstr "Remove três valores da pilha (do topo da pilha para baixo):"

msgid "``self``: the first argument to the current method"
msgstr "``self``: o primeiro argumento para o método atual"

msgid "``cls``: the class within which the current method was defined"
msgstr "``cls``: a classe dentro da qual o método atual foi definido"

msgid "the global ``super``"
msgstr "o ``super`` global"

msgid ""
"With respect to its argument, it works similarly to :opcode:`LOAD_ATTR`, "
"except that ``namei`` is shifted left by 2 bits instead of 1."
msgstr ""
"Em relação ao seu argumento, funciona de forma semelhante a :opcode:"
"`LOAD_ATTR`, exceto que ``namei`` é deslocado à esquerda por 2 bits em vez "
"de 1."

msgid ""
"The low bit of ``namei`` signals to attempt a method load, as with :opcode:"
"`LOAD_ATTR`, which results in pushing ``NULL`` and the loaded method. When "
"it is unset a single value is pushed to the stack."
msgstr ""
"O bit baixo de ``namei`` sinaliza para tentar carregar um método, como em :"
"opcode:`LOAD_ATTR`, o que resulta em empurrar ``NULL`` e o método carregado. "
"Quando não está definido, um único valor é empurrado para a pilha."

msgid ""
"The second-low bit of ``namei``, if set, means that this was a two-argument "
"call to :func:`super` (unset means zero-argument)."
msgstr ""
"O segundo bit baixo de ``namei``, se definido, significa que esta foi uma "
"chamada de dois argumentos para :func:`super` (não definido significa zero "
"argumentos)."

msgid ""
"Performs a Boolean operation.  The operation name can be found in "
"``cmp_op[opname >> 5]``. If the fifth-lowest bit of ``opname`` is set "
"(``opname & 16``), the result should be coerced to ``bool``."
msgstr ""
"Realiza uma operação booleana. O nome da operação pode ser encontrado em "
"``cmp_op[opname >> 5]``. Se o quinto bit menos significativo de ``opname`` "
"estiver definido (``opname & 16``), o resultado deve ser convertido para "
"``bool``."

msgid ""
"The fifth-lowest bit of the oparg now indicates a forced conversion to :"
"class:`bool`."
msgstr ""
"O quinto bit menos significativo do oparg agora indica uma conversão forçada "
"para :class:`bool`."

msgid "Performs ``is`` comparison, or ``is not`` if ``invert`` is 1."
msgstr "Realiza a comparação ``is``, ou ``is not`` se ``invert`` for 1."

msgid "Performs ``in`` comparison, or ``not in`` if ``invert`` is 1."
msgstr "Realiza a comparação ``in``, ou ``not in`` se ``invert`` for 1."

msgid ""
"Imports the module ``co_names[namei]``.  ``STACK[-1]`` and ``STACK[-2]`` are "
"popped and provide the *fromlist* and *level* arguments of :func:"
"`__import__`. The module object is pushed onto the stack.  The current "
"namespace is not affected: for a proper import statement, a subsequent :"
"opcode:`STORE_FAST` instruction modifies the namespace."
msgstr ""
"Importa o módulo ``co_names[namei]``. ``STACK[-1]`` e ``STACK[-2]`` são "
"removidos e fornecem os argumentos *fromlist* e *level* de :func:"
"`__import__`. O objeto do módulo é empurrado para a pilha. O espaço de nomes "
"atual não é afetado: para uma instrução de importação adequada, uma "
"instrução subsequente :opcode:`STORE_FAST` modifica o espaço de nomes."

msgid ""
"Loads the attribute ``co_names[namei]`` from the module found in "
"``STACK[-1]``. The resulting object is pushed onto the stack, to be "
"subsequently stored by a :opcode:`STORE_FAST` instruction."
msgstr ""
"Carrega o atributo ``co_names[namei]`` do módulo encontrado em "
"``STACK[-1]``. O objeto resultante é empurrado para a pilha, para ser "
"posteriormente armazenado por uma instrução :opcode:`STORE_FAST`."

msgid "Increments bytecode counter by *delta*."
msgstr "Incrementa o contador de bytecode por *delta*."

msgid "Decrements bytecode counter by *delta*. Checks for interrupts."
msgstr "Decrementa o contador de bytecode por *delta*. Verifica interrupções."

msgid "Decrements bytecode counter by *delta*. Does not check for interrupts."
msgstr ""
"Decrementa o contador de bytecode por *delta*. Não verifica interrupções."

msgid ""
"If ``STACK[-1]`` is true, increments the bytecode counter by *delta*. "
"``STACK[-1]`` is popped."
msgstr ""
"Se ``STACK[-1]`` for verdadeiro, incrementa o contador de bytecode por "
"*delta*. ``STACK[-1]`` é removido."

msgid ""
"The oparg is now a relative delta rather than an absolute target. This "
"opcode is a pseudo-instruction, replaced in final bytecode by the directed "
"versions (forward/backward)."
msgstr ""
"O oparg é agora um delta relativo em vez de um alvo absoluto. Este opcode é "
"uma pseudo-instrução, substituída no bytecode final pelas versões "
"direcionadas (para frente/para trás)."

msgid "This is no longer a pseudo-instruction."
msgstr "Isto já não é uma pseudo-instrução."

msgid ""
"If ``STACK[-1]`` is false, increments the bytecode counter by *delta*. "
"``STACK[-1]`` is popped."
msgstr ""
"Se ``STACK[-1]`` for falso, incrementa o contador de bytecode por *delta*. "
"``STACK[-1]`` é removido."

msgid ""
"If ``STACK[-1]`` is not ``None``, increments the bytecode counter by "
"*delta*. ``STACK[-1]`` is popped."
msgstr ""
"Se ``STACK[-1]`` não for ``None``, incrementa o contador de bytecode por "
"*delta*. ``STACK[-1]`` é removido."

msgid ""
"If ``STACK[-1]`` is ``None``, increments the bytecode counter by *delta*. "
"``STACK[-1]`` is popped."
msgstr ""
"Se ``STACK[-1]`` for ``None``, incrementa o contador de bytecode por "
"*delta*. ``STACK[-1]`` é removido."

msgid ""
"``STACK[-1]`` is an :term:`iterator`.  Call its :meth:`~iterator.__next__` "
"method. If this yields a new value, push it on the stack (leaving the "
"iterator below it).  If the iterator indicates it is exhausted then the byte "
"code counter is incremented by *delta*."
msgstr ""
"``STACK[-1]`` é um :term:`iterador`. Chama o seu método :meth:`~iterator."
"__next__`. Se isto produzir um novo valor, empurra-o para a pilha (deixando "
"o iterador abaixo dele). Se o iterador indicar que está esgotado, então o "
"contador de bytecode é incrementado por *delta*."

msgid "Up until 3.11 the iterator was popped when it was exhausted."
msgstr "Até à versão 3.11, o iterador era removido quando estava esgotado."

msgid "Loads the global named ``co_names[namei>>1]`` onto the stack."
msgstr "Carrega o global chamado ``co_names[namei>>1]`` para a pilha."

msgid ""
"If the low bit of ``namei`` is set, then a ``NULL`` is pushed to the stack "
"before the global variable."
msgstr ""
"Se o bit baixo de ``namei`` estiver definido, então um ``NULL`` é empurrado "
"para a pilha antes da variável global."

msgid ""
"Pushes a reference to the local ``co_varnames[var_num]`` onto the stack."
msgstr ""
"Empurra uma referência para o local ``co_varnames[var_num]`` para a pilha."

msgid ""
"This opcode is now only used in situations where the local variable is "
"guaranteed to be initialized. It cannot raise :exc:`UnboundLocalError`."
msgstr ""
"Este opcode é agora usado apenas em situações onde a variável local é "
"garantidamente inicializada. Não pode levantar :exc:`UnboundLocalError`."

msgid ""
"Pushes a borrowed reference to the local ``co_varnames[var_num]`` onto the "
"stack."
msgstr ""
"Empurra uma referência emprestada para o local ``co_varnames[var_num]`` para "
"a pilha."

msgid ""
"Pushes references to ``co_varnames[var_nums >> 4]`` and "
"``co_varnames[var_nums & 15]`` onto the stack."
msgstr ""
"Empurra referências para ``co_varnames[var_nums >> 4]`` e "
"``co_varnames[var_nums & 15]`` para a pilha."

msgid ""
"Pushes borrowed references to ``co_varnames[var_nums >> 4]`` and "
"``co_varnames[var_nums & 15]`` onto the stack."
msgstr ""
"Empurra referências emprestadas para ``co_varnames[var_nums >> 4]`` e "
"``co_varnames[var_nums & 15]`` para a pilha."

msgid ""
"Pushes a reference to the local ``co_varnames[var_num]`` onto the stack, "
"raising an :exc:`UnboundLocalError` if the local variable has not been "
"initialized."
msgstr ""
"Empurra uma referência para o local ``co_varnames[var_num]`` para a pilha, "
"levantando um :exc:`UnboundLocalError` se a variável local não tiver sido "
"inicializada."

msgid ""
"Pushes a reference to the local ``co_varnames[var_num]`` onto the stack (or "
"pushes ``NULL`` onto the stack if the local variable has not been "
"initialized) and sets ``co_varnames[var_num]`` to ``NULL``."
msgstr ""
"Empurra uma referência para o local ``co_varnames[var_num]`` para a pilha "
"(ou empurra ``NULL`` para a pilha se a variável local não tiver sido "
"inicializada) e define ``co_varnames[var_num]`` para ``NULL``."

msgid "Stores ``STACK.pop()`` into the local ``co_varnames[var_num]``."
msgstr "Armazena ``STACK.pop()`` no local ``co_varnames[var_num]``."

msgid ""
"Stores ``STACK[-1]`` into ``co_varnames[var_nums >> 4]`` and ``STACK[-2]`` "
"into ``co_varnames[var_nums & 15]``."
msgstr ""
"Armazena ``STACK[-1]`` em ``co_varnames[var_nums >> 4]`` e ``STACK[-2]`` em "
"``co_varnames[var_nums & 15]``."

msgid ""
"Stores ``STACK.pop()`` into the local ``co_varnames[var_nums >> 4]`` and "
"pushes a reference to the local ``co_varnames[var_nums & 15]`` onto the "
"stack."
msgstr ""
"Armazena ``STACK.pop()`` no local ``co_varnames[var_nums >> 4]`` e empurra "
"uma referência para o local ``co_varnames[var_nums & 15]`` para a pilha."

msgid "Deletes local ``co_varnames[var_num]``."
msgstr "Apaga o local ``co_varnames[var_num]``."

msgid ""
"Creates a new cell in slot ``i``.  If that slot is nonempty then that value "
"is stored into the new cell."
msgstr ""
"Cria uma nova célula no slot ``i``. Se esse slot não estiver vazio, então "
"esse valor é armazenado na nova célula."

msgid ""
"Loads the cell contained in slot ``i`` of the \"fast locals\" storage. "
"Pushes a reference to the object the cell contains on the stack."
msgstr ""
"Carrega a célula contida no slot ``i`` do armazenamento de \"locais "
"rápidos\". Empurra uma referência para o objeto que a célula contém na pilha."

msgid ""
"``i`` is no longer offset by the length of :attr:`~codeobject.co_varnames`."
msgstr ""
"``i`` já não é deslocado pelo comprimento de :attr:`~codeobject.co_varnames`."

msgid ""
"Pops a mapping off the stack and looks up the name associated with slot "
"``i`` of the \"fast locals\" storage in this mapping. If the name is not "
"found there, loads it from the cell contained in slot ``i``, similar to :"
"opcode:`LOAD_DEREF`. This is used for loading :term:`closure variables "
"<closure variable>` in class bodies (which previously used :opcode:`!"
"LOAD_CLASSDEREF`) and in :ref:`annotation scopes <annotation-scopes>` within "
"class bodies."
msgstr ""
"Remove um mapeamento da pilha e procura o nome associado ao slot ``i`` do "
"armazenamento de \"locais rápidos\" neste mapeamento. Se o nome não for "
"encontrado lá, carrega-o da célula contida no slot ``i``, semelhante a :"
"opcode:`LOAD_DEREF`. Isto é usado para carregar :term:`variáveis de closure "
"<closure variable>` em corpos de classe (que anteriormente usavam :opcode:`!"
"LOAD_CLASSDEREF`) e em :ref:`escopos de anotação <annotation-scopes>` dentro "
"de corpos de classe."

msgid ""
"Stores ``STACK.pop()`` into the cell contained in slot ``i`` of the \"fast "
"locals\" storage."
msgstr ""
"Armazena ``STACK.pop()`` na célula contida no slot ``i`` do armazenamento de "
"\"locais rápidos\"."

msgid ""
"Empties the cell contained in slot ``i`` of the \"fast locals\" storage. "
"Used by the :keyword:`del` statement."
msgstr ""
"Esvazia a célula contida no slot ``i`` do armazenamento de \"locais "
"rápidos\". Usado pela instrução :keyword:`del`."

msgid ""
"Copies the ``n`` :term:`free (closure) variables <closure variable>` from "
"the closure into the frame. Removes the need for special code on the "
"caller's side when calling closures."
msgstr ""
"Copia as ``n`` :term:`variáveis livres (closure) <closure variable>` da "
"closure para o quadro. Remove a necessidade de código especial do lado do "
"chamador ao chamar closures."

msgid ""
"Raises an exception using one of the 3 forms of the ``raise`` statement, "
"depending on the value of *argc*:"
msgstr ""
"Levanta uma exceção usando uma das 3 formas da instrução ``raise``, "
"dependendo do valor de *argc*:"

msgid "0: ``raise`` (re-raise previous exception)"
msgstr "0: ``raise`` (relança a exceção anterior)"

msgid ""
"1: ``raise STACK[-1]`` (raise exception instance or type at ``STACK[-1]``)"
msgstr ""
"1: ``raise STACK[-1]`` (levanta instância ou tipo de exceção em "
"``STACK[-1]``)"

msgid ""
"2: ``raise STACK[-2] from STACK[-1]`` (raise exception instance or type at "
"``STACK[-2]`` with ``__cause__`` set to ``STACK[-1]``)"
msgstr ""
"2: ``raise STACK[-2] from STACK[-1]`` (levanta instância ou tipo de exceção "
"em ``STACK[-2]`` com ``__cause__`` definido para ``STACK[-1]``)"

msgid ""
"Calls a callable object with the number of arguments specified by ``argc``. "
"On the stack are (in ascending order):"
msgstr ""
"Chama um objeto chamável com o número de argumentos especificado por "
"``argc``. Na pilha estão (por ordem ascendente):"

msgid "The callable"
msgstr "O objeto chamável"

msgid "``self`` or ``NULL``"
msgstr "``self`` ou ``NULL``"

msgid "The remaining positional arguments"
msgstr "Os argumentos posicionais restantes"

msgid "``argc`` is the total of the positional arguments, excluding ``self``."
msgstr "``argc`` é o total dos argumentos posicionais, excluindo ``self``."

msgid ""
"``CALL`` pops all arguments and the callable object off the stack, calls the "
"callable object with those arguments, and pushes the return value returned "
"by the callable object."
msgstr ""
"``CALL`` remove todos os argumentos e o objeto chamável da pilha, chama o "
"objeto chamável com esses argumentos e empurra o valor de retorno retornado "
"pelo objeto chamável."

msgid "The callable now always appears at the same position on the stack."
msgstr "O objeto chamável agora aparece sempre na mesma posição na pilha."

msgid "Calls with keyword arguments are now handled by :opcode:`CALL_KW`."
msgstr ""
"Chamadas com argumentos de palavra-chave são agora tratadas por :opcode:"
"`CALL_KW`."

msgid ""
"Calls a callable object with the number of arguments specified by ``argc``, "
"including one or more named arguments. On the stack are (in ascending order):"
msgstr ""
"Chama um objeto chamável com o número de argumentos especificado por "
"``argc``, incluindo um ou mais argumentos nomeados. Na pilha estão (por "
"ordem ascendente):"

msgid "The named arguments"
msgstr "Os argumentos nomeados"

msgid "A :class:`tuple` of keyword argument names"
msgstr "Um :class:`tuple` de nomes de argumentos de palavra-chave"

msgid ""
"``argc`` is the total of the positional and named arguments, excluding "
"``self``. The length of the tuple of keyword argument names is the number of "
"named arguments."
msgstr ""
"``argc`` é o total dos argumentos posicionais e nomeados, excluindo "
"``self``. O comprimento do tuplo de nomes de argumentos de palavra-chave é o "
"número de argumentos nomeados."

msgid ""
"``CALL_KW`` pops all arguments, the keyword names, and the callable object "
"off the stack, calls the callable object with those arguments, and pushes "
"the return value returned by the callable object."
msgstr ""
"``CALL_KW`` remove todos os argumentos, os nomes de palavra-chave e o objeto "
"chamável da pilha, chama o objeto chamável com esses argumentos e empurra o "
"valor de retorno retornado pelo objeto chamável."

msgid ""
"Calls a callable object with variable set of positional and keyword "
"arguments.  If the lowest bit of *flags* is set, the top of the stack "
"contains a mapping object containing additional keyword arguments. Before "
"the callable is called, the mapping object and iterable object are each "
"\"unpacked\" and their contents passed in as keyword and positional "
"arguments respectively. ``CALL_FUNCTION_EX`` pops all arguments and the "
"callable object off the stack, calls the callable object with those "
"arguments, and pushes the return value returned by the callable object."
msgstr ""
"Chama um objeto chamável com um conjunto variável de argumentos posicionais "
"e de palavra-chave. Se o bit menos significativo de *flags* estiver "
"definido, o topo da pilha contém um objeto de mapeamento contendo argumentos "
"de palavra-chave adicionais. Antes de o objeto chamável ser chamado, o "
"objeto de mapeamento e o objeto iterável são cada um \"desempacotados\" e os "
"seus conteúdos passados como argumentos de palavra-chave e posicionais, "
"respetivamente. ``CALL_FUNCTION_EX`` remove todos os argumentos e o objeto "
"chamável da pilha, chama o objeto chamável com esses argumentos e empurra o "
"valor de retorno retornado pelo objeto chamável."

msgid ""
"Pushes a ``NULL`` to the stack. Used in the call sequence to match the "
"``NULL`` pushed by :opcode:`!LOAD_METHOD` for non-method calls."
msgstr ""
"Empurra um ``NULL`` para a pilha. Usado na sequência de chamada para "
"corresponder ao ``NULL`` empurrado por :opcode:`!LOAD_METHOD` para chamadas "
"não-método."

msgid ""
"Pushes a new function object on the stack built from the code object at "
"``STACK[-1]``."
msgstr ""
"Empurra um novo objeto de função para a pilha construído a partir do objeto "
"de código em ``STACK[-1]``."

msgid "Flag value ``0x04`` is a tuple of strings instead of dictionary"
msgstr "O valor da flag ``0x04`` é um tuplo de strings em vez de um dicionário"

msgid "Qualified name at ``STACK[-1]`` was removed."
msgstr "O nome qualificado em ``STACK[-1]`` foi removido."

msgid ""
"Extra function attributes on the stack, signaled by oparg flags, were "
"removed. They now use :opcode:`SET_FUNCTION_ATTRIBUTE`."
msgstr ""
"Atributos extra de função na pilha, sinalizados por flags oparg, foram "
"removidos. Agora usam :opcode:`SET_FUNCTION_ATTRIBUTE`."

msgid ""
"Sets an attribute on a function object. Expects the function at "
"``STACK[-1]`` and the attribute value to set at ``STACK[-2]``; consumes both "
"and leaves the function at ``STACK[-1]``. The flag determines which "
"attribute to set:"
msgstr ""
"Define um atributo num objeto de função. Espera a função em ``STACK[-1]`` e "
"o valor do atributo a definir em ``STACK[-2]``; consome ambos e deixa a "
"função em ``STACK[-1]``. A flag determina qual atributo definir:"

msgid ""
"``0x01`` a tuple of default values for positional-only and positional-or-"
"keyword parameters in positional order"
msgstr ""
"``0x01`` um tuplo de valores predefinidos para parâmetros apenas posicionais "
"e posicionais ou de palavra-chave, por ordem posicional"

msgid "``0x02`` a dictionary of keyword-only parameters' default values"
msgstr ""
"``0x02`` um dicionário de valores predefinidos de parâmetros apenas de "
"palavra-chave"

msgid "``0x04`` a tuple of strings containing parameters' annotations"
msgstr "``0x04`` um tuplo de strings contendo anotações de parâmetros"

msgid "``0x08`` a tuple containing cells for free variables, making a closure"
msgstr ""
"``0x08`` um tuplo contendo células para variáveis livres, criando uma closure"

msgid "``0x10`` the :term:`annotate function` for the function object"
msgstr "``0x10`` a :term:`função de anotação` para o objeto de função"

msgid ""
"Added ``0x10`` to indicate the annotate function for the function object."
msgstr ""
"Adicionado ``0x10`` para indicar a função de anotação para o objeto de "
"função."

msgid ""
"Pushes a slice object on the stack.  *argc* must be 2 or 3.  If it is 2, "
"implements::"
msgstr ""
"Empurra um objeto de fatia para a pilha. *argc* deve ser 2 ou 3. Se for 2, "
"implementa:"

msgid ""
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"STACK.append(slice(start, end))"
msgstr ""
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"STACK.append(slice(start, end))"

msgid "if it is 3, implements::"
msgstr "se for 3, implementa:"

msgid ""
"step = STACK.pop()\n"
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"STACK.append(slice(start, end, step))"
msgstr ""
"step = STACK.pop()\n"
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"STACK.append(slice(start, end, step))"

msgid "See the :func:`slice` built-in function for more information."
msgstr "Veja a função integrada :func:`slice` para mais informações."

msgid ""
"Prefixes any opcode which has an argument too big to fit into the default "
"one byte. *ext* holds an additional byte which act as higher bits in the "
"argument. For each opcode, at most three prefixal ``EXTENDED_ARG`` are "
"allowed, forming an argument from two-byte to four-byte."
msgstr ""
"Prefixa qualquer opcode que tenha um argumento demasiado grande para caber "
"num byte. *ext* contém um byte adicional que atua como bits mais "
"significativos no argumento. Para cada opcode, são permitidos no máximo três "
"``EXTENDED_ARG`` prefixados, formando um argumento de dois a quatro bytes."

msgid "Convert value to a string, depending on ``oparg``::"
msgstr "Converte valor para uma string, dependendo de ``oparg``:"

msgid ""
"value = STACK.pop()\n"
"result = func(value)\n"
"STACK.append(result)"
msgstr ""
"value = STACK.pop()\n"
"result = func(value)\n"
"STACK.append(result)"

msgid "``oparg == 1``: call :func:`str` on *value*"
msgstr "``oparg == 1``: chama :func:`str` em *value*"

msgid "``oparg == 2``: call :func:`repr` on *value*"
msgstr "``oparg == 2``: chama :func:`repr` em *value*"

msgid "``oparg == 3``: call :func:`ascii` on *value*"
msgstr "``oparg == 3``: chama :func:`ascii` em *value*"

msgid "Used for implementing formatted string literals (f-strings)."
msgstr "Usado para implementar literais de string formatadas (f-strings)."

msgid "Formats the value on top of stack::"
msgstr "Formata o valor no topo da pilha:"

msgid ""
"value = STACK.pop()\n"
"result = value.__format__(\"\")\n"
"STACK.append(result)"
msgstr ""
"value = STACK.pop()\n"
"result = value.__format__(\"\")\n"
"STACK.append(result)"

msgid "Formats the given value with the given format spec::"
msgstr "Formata o valor dado com a especificação de formato dada:"

msgid ""
"spec = STACK.pop()\n"
"value = STACK.pop()\n"
"result = value.__format__(spec)\n"
"STACK.append(result)"
msgstr ""
"spec = STACK.pop()\n"
"value = STACK.pop()\n"
"result = value.__format__(spec)\n"
"STACK.append(result)"

msgid ""
"``STACK[-1]`` is a tuple of keyword attribute names, ``STACK[-2]`` is the "
"class being matched against, and ``STACK[-3]`` is the match subject.  "
"*count* is the number of positional sub-patterns."
msgstr ""
"``STACK[-1]`` é um tuplo de nomes de atributos de palavra-chave, "
"``STACK[-2]`` é a classe que está a ser correspondida, e ``STACK[-3]`` é o "
"assunto de correspondência. *count* é o número de sub-padrões posicionais."

msgid ""
"Pop ``STACK[-1]``, ``STACK[-2]``, and ``STACK[-3]``. If ``STACK[-3]`` is an "
"instance of ``STACK[-2]`` and has the positional and keyword attributes "
"required by *count* and ``STACK[-1]``, push a tuple of extracted attributes. "
"Otherwise, push ``None``."
msgstr ""
"Remove ``STACK[-1]``, ``STACK[-2]`` e ``STACK[-3]``. Se ``STACK[-3]`` for "
"uma instância de ``STACK[-2]`` e tiver os atributos posicionais e de palavra-"
"chave exigidos por *count* e ``STACK[-1]``, empurra um tuplo de atributos "
"extraídos. Caso contrário, empurra ``None``."

msgid "A no-op. Performs internal tracing, debugging and optimization checks."
msgstr ""
"Uma operação sem efeito. Realiza rastreio interno, depuração e verificações "
"de otimização."

msgid ""
"The ``context`` operand consists of two parts. The lowest two bits indicate "
"where the ``RESUME`` occurs:"
msgstr ""
"O operando ``context`` consiste em duas partes. Os dois bits menos "
"significativos indicam onde ocorre o ``RESUME``:"

msgid ""
"``0`` The start of a function, which is neither a generator, coroutine nor "
"an async generator"
msgstr ""
"``0`` O início de uma função, que não é um gerador, corrotina nem um gerador "
"assíncrono"

msgid "``1`` After a ``yield`` expression"
msgstr "``1`` Após uma expressão ``yield``"

msgid "``2`` After a ``yield from`` expression"
msgstr "``2`` Após uma expressão ``yield from``"

msgid "``3`` After an ``await`` expression"
msgstr "``3`` Após uma expressão ``await``"

msgid ""
"The next bit is ``1`` if the RESUME is at except-depth ``1``, and ``0`` "
"otherwise."
msgstr ""
"O bit seguinte é ``1`` se o RESUME estiver na profundidade de exceção ``1``, "
"e ``0`` caso contrário."

msgid "The oparg value changed to include information about except-depth"
msgstr ""
"O valor de oparg foi alterado para incluir informações sobre a profundidade "
"de exceção."

msgid ""
"Create a generator, coroutine, or async generator from the current frame. "
"Used as first opcode of in code object for the above mentioned callables. "
"Clear the current frame and return the newly created generator."
msgstr ""
"Cria um gerador, corrotina ou gerador assíncrono a partir do quadro atual. "
"Usado como primeiro opcode no objeto de código para os chamáveis mencionados "
"acima. Limpa o quadro atual e retorna o gerador recém-criado."

msgid ""
"Equivalent to ``STACK[-1] = STACK[-2].send(STACK[-1])``. Used in ``yield "
"from`` and ``await`` statements."
msgstr ""
"Equivalente a ``STACK[-1] = STACK[-2].send(STACK[-1])``. Usado em instruções "
"``yield from`` e ``await``."

msgid ""
"If the call raises :exc:`StopIteration`, pop the top value from the stack, "
"push the exception's ``value`` attribute, and increment the bytecode counter "
"by *delta*."
msgstr ""
"Se a chamada levantar :exc:`StopIteration`, remove o valor do topo da pilha, "
"empurra o atributo ``value`` da exceção e incrementa o contador de bytecode "
"por *delta*."

msgid ""
"This is not really an opcode.  It identifies the dividing line between "
"opcodes in the range [0,255] which don't use their argument and those that "
"do (``< HAVE_ARGUMENT`` and ``>= HAVE_ARGUMENT``, respectively)."
msgstr ""
"Isto não é realmente um opcode. Identifica a linha divisória entre opcodes "
"no intervalo [0,255] que não usam o seu argumento e aqueles que usam (``< "
"HAVE_ARGUMENT`` e ``>= HAVE_ARGUMENT``, respetivamente)."

msgid ""
"If your application uses pseudo instructions or specialized instructions, "
"use the :data:`hasarg` collection instead."
msgstr ""
"Se a sua aplicação usar pseudo-instruções ou instruções especializadas, use "
"a coleção :data:`hasarg` em vez disso."

msgid ""
"Now every instruction has an argument, but opcodes ``< HAVE_ARGUMENT`` "
"ignore it. Before, only opcodes ``>= HAVE_ARGUMENT`` had an argument."
msgstr ""
"Agoras todas as instruções têm um argumento, mas os opcodes ``< "
"HAVE_ARGUMENT`` ignoram-no. Antes, apenas os opcodes ``>= HAVE_ARGUMENT`` "
"tinham um argumento."

msgid ""
"Pseudo instructions were added to the :mod:`dis` module, and for them it is "
"not true that comparison with ``HAVE_ARGUMENT`` indicates whether they use "
"their arg."
msgstr ""
"Pseudo-instruções foram adicionadas ao módulo :mod:`dis`, e para elas não é "
"verdade que a comparação com ``HAVE_ARGUMENT`` indique se usam o seu "
"argumento."

msgid "Use :data:`hasarg` instead."
msgstr "Use :data:`hasarg` em vez disso."

msgid ""
"Calls an intrinsic function with one argument. Passes ``STACK[-1]`` as the "
"argument and sets ``STACK[-1]`` to the result. Used to implement "
"functionality that is not performance critical."
msgstr ""
"Chama uma função intrínseca com um argumento. Passa ``STACK[-1]`` como "
"argumento e define ``STACK[-1]`` para o resultado. Usado para implementar "
"funcionalidades que não são críticas para o desempenho."

msgid "The operand determines which intrinsic function is called:"
msgstr "O operando determina qual função intrínseca é chamada:"

msgid "Operand"
msgstr "Operando"

msgid "Description"
msgstr "Descrição"

msgid "``INTRINSIC_1_INVALID``"
msgstr "``INTRINSIC_1_INVALID``"

msgid "Not valid"
msgstr "Não válido"

msgid "``INTRINSIC_PRINT``"
msgstr "``INTRINSIC_PRINT``"

msgid "Prints the argument to standard out. Used in the REPL."
msgstr "Imprime o argumento para a saída padrão. Usado no REPL."

msgid "``INTRINSIC_IMPORT_STAR``"
msgstr "``INTRINSIC_IMPORT_STAR``"

msgid "Performs ``import *`` for the named module."
msgstr "Realiza ``import *`` para o módulo nomeado."

msgid "``INTRINSIC_STOPITERATION_ERROR``"
msgstr "``INTRINSIC_STOPITERATION_ERROR``"

msgid "Extracts the return value from a ``StopIteration`` exception."
msgstr "Extrai o valor de retorno de uma exceção ``StopIteration``."

msgid "``INTRINSIC_ASYNC_GEN_WRAP``"
msgstr "``INTRINSIC_ASYNC_GEN_WRAP``"

msgid "Wraps an async generator value"
msgstr "Embrulha um valor de gerador assíncrono"

msgid "``INTRINSIC_UNARY_POSITIVE``"
msgstr "``INTRINSIC_UNARY_POSITIVE``"

msgid "Performs the unary ``+`` operation"
msgstr "Realiza a operação unária ``+``"

msgid "``INTRINSIC_LIST_TO_TUPLE``"
msgstr "``INTRINSIC_LIST_TO_TUPLE``"

msgid "Converts a list to a tuple"
msgstr "Converte uma lista num tuplo"

msgid "``INTRINSIC_TYPEVAR``"
msgstr "``INTRINSIC_TYPEVAR``"

msgid "Creates a :class:`typing.TypeVar`"
msgstr "Cria um :class:`typing.TypeVar`"

msgid "``INTRINSIC_PARAMSPEC``"
msgstr "``INTRINSIC_PARAMSPEC``"

msgid "Creates a :class:`typing.ParamSpec`"
msgstr "Cria um :class:`typing.ParamSpec`"

msgid "``INTRINSIC_TYPEVARTUPLE``"
msgstr "``INTRINSIC_TYPEVARTUPLE``"

msgid "Creates a :class:`typing.TypeVarTuple`"
msgstr "Cria um :class:`typing.TypeVarTuple`"

msgid "``INTRINSIC_SUBSCRIPT_GENERIC``"
msgstr "``INTRINSIC_SUBSCRIPT_GENERIC``"

msgid "Returns :class:`typing.Generic` subscripted with the argument"
msgstr "Retorna :class:`typing.Generic` subscrito com o argumento"

msgid "``INTRINSIC_TYPEALIAS``"
msgstr "``INTRINSIC_TYPEALIAS``"

msgid ""
"Creates a :class:`typing.TypeAliasType`; used in the :keyword:`type` "
"statement. The argument is a tuple of the type alias's name, type "
"parameters, and value."
msgstr ""
"Cria um :class:`typing.TypeAliasType`; usado na instrução :keyword:`type`. O "
"argumento é um tuplo com o nome do alias de tipo, parâmetros de tipo e valor."

msgid ""
"Calls an intrinsic function with two arguments. Used to implement "
"functionality that is not performance critical::"
msgstr ""
"Chama uma função intrínseca com dois argumentos. Usado para implementar "
"funcionalidades que não são críticas para o desempenho:"

msgid ""
"arg2 = STACK.pop()\n"
"arg1 = STACK.pop()\n"
"result = intrinsic2(arg1, arg2)\n"
"STACK.append(result)"
msgstr ""
"arg2 = STACK.pop()\n"
"arg1 = STACK.pop()\n"
"result = intrinsic2(arg1, arg2)\n"
"STACK.append(result)"

msgid "``INTRINSIC_2_INVALID``"
msgstr "``INTRINSIC_2_INVALID``"

msgid "``INTRINSIC_PREP_RERAISE_STAR``"
msgstr "``INTRINSIC_PREP_RERAISE_STAR``"

msgid "Calculates the :exc:`ExceptionGroup` to raise from a ``try-except*``."
msgstr ""
"Calcula o :exc:`ExceptionGroup` a levantar a partir de um ``try-except*``."

msgid "``INTRINSIC_TYPEVAR_WITH_BOUND``"
msgstr "``INTRINSIC_TYPEVAR_WITH_BOUND``"

msgid "Creates a :class:`typing.TypeVar` with a bound."
msgstr "Cria um :class:`typing.TypeVar` com um limite."

msgid "``INTRINSIC_TYPEVAR_WITH_CONSTRAINTS``"
msgstr "``INTRINSIC_TYPEVAR_WITH_CONSTRAINTS``"

msgid "Creates a :class:`typing.TypeVar` with constraints."
msgstr "Cria um :class:`typing.TypeVar` com restrições."

msgid "``INTRINSIC_SET_FUNCTION_TYPE_PARAMS``"
msgstr "``INTRINSIC_SET_FUNCTION_TYPE_PARAMS``"

msgid "Sets the ``__type_params__`` attribute of a function."
msgstr "Define o atributo ``__type_params__`` de uma função."

msgid ""
"Performs special method lookup on ``STACK[-1]``. If ``type(STACK[-1])."
"__xxx__`` is a method, leave ``type(STACK[-1]).__xxx__; STACK[-1]`` on the "
"stack. If ``type(STACK[-1]).__xxx__`` is not a method, leave ``STACK[-1]."
"__xxx__; NULL`` on the stack."
msgstr ""
"Realiza a pesquisa de método especial em ``STACK[-1]``. Se ``type(STACK[-1])."
"__xxx__`` for um método, deixa ``type(STACK[-1]).__xxx__; STACK[-1]`` na "
"pilha. Se ``type(STACK[-1]).__xxx__`` não for um método, deixa ``STACK[-1]."
"__xxx__; NULL`` na pilha."

msgid "**Pseudo-instructions**"
msgstr "**Pseudo-instruções**"

msgid ""
"These opcodes do not appear in Python bytecode. They are used by the "
"compiler but are replaced by real opcodes or removed before bytecode is "
"generated."
msgstr ""
"Estes opcodes não aparecem no bytecode Python. São usados pelo compilador, "
"mas são substituídos por opcodes reais ou removidos antes de o bytecode ser "
"gerado."

msgid ""
"Set up an exception handler for the following code block. If an exception "
"occurs, the value stack level is restored to its current state and control "
"is transferred to the exception handler at ``target``."
msgstr ""
"Configura um manipulador de exceção para o bloco de código seguinte. Se "
"ocorrer uma exceção, o nível da pilha de valores é restaurado para o seu "
"estado atual e o controlo é transferido para o manipulador de exceção em "
"``target``."

msgid ""
"Like ``SETUP_FINALLY``, but in case of an exception also pushes the last "
"instruction (``lasti``) to the stack so that ``RERAISE`` can restore it. If "
"an exception occurs, the value stack level and the last instruction on the "
"frame are restored to their current state, and control is transferred to the "
"exception handler at ``target``."
msgstr ""
"Semelhante a ``SETUP_FINALLY``, mas em caso de exceção também empurra a "
"última instrução (``lasti``) para a pilha para que ``RERAISE`` possa "
"restaurá-la. Se ocorrer uma exceção, o nível da pilha de valores e a última "
"instrução no quadro são restaurados para o seu estado atual, e o controlo é "
"transferido para o manipulador de exceção em ``target``."

msgid ""
"Like ``SETUP_CLEANUP``, but in case of an exception one more item is popped "
"from the stack before control is transferred to the exception handler at "
"``target``."
msgstr ""
"Semelhante a ``SETUP_CLEANUP``, mas em caso de exceção, mais um item é "
"removido da pilha antes de o controlo ser transferido para o manipulador de "
"exceção em ``target``."

msgid ""
"This variant is used in :keyword:`with` and :keyword:`async with` "
"constructs, which push the return value of the context manager's :meth:"
"`~object.__enter__` or :meth:`~object.__aenter__` to the stack."
msgstr ""
"Esta variante é usada em construções :keyword:`with` e :keyword:`async "
"with`, que empurram o valor de retorno do :meth:`~object.__enter__` ou :meth:"
"`~object.__aenter__` do gestor de contexto para a pilha."

msgid ""
"Marks the end of the code block associated with the last ``SETUP_FINALLY``, "
"``SETUP_CLEANUP`` or ``SETUP_WITH``."
msgstr ""
"Marca o fim do bloco de código associado ao último ``SETUP_FINALLY``, "
"``SETUP_CLEANUP`` ou ``SETUP_WITH``."

msgid ""
"Works as :opcode:`LOAD_CONST`, but is more efficient for immortal objects."
msgstr ""
"Funciona como :opcode:`LOAD_CONST`, mas é mais eficiente para objetos "
"imortais."

msgid ""
"Undirected relative jump instructions which are replaced by their directed "
"(forward/backward) counterparts by the assembler."
msgstr ""
"Instruções de salto relativo não direcionadas que são substituídas pelas "
"suas contrapartes direcionadas (para frente/para trás) pelo montador."

msgid ""
"Conditional jumps which do not impact the stack. Replaced by the sequence "
"``COPY 1``, ``TO_BOOL``, ``POP_JUMP_IF_TRUE/FALSE``."
msgstr ""
"Saltos condicionais que não afetam a pilha. Substituídos pela sequência "
"``COPY 1``, ``TO_BOOL``, ``POP_JUMP_IF_TRUE/FALSE``."

msgid ""
"Pushes a reference to the cell contained in slot ``i`` of the \"fast "
"locals\" storage."
msgstr ""
"Empurra uma referência para a célula contida no slot ``i`` do armazenamento "
"de \"locais rápidos\"."

msgid ""
"Note that ``LOAD_CLOSURE`` is replaced with ``LOAD_FAST`` in the assembler."
msgstr "Note que ``LOAD_CLOSURE`` é substituído por ``LOAD_FAST`` no montador."

msgid "This opcode is now a pseudo-instruction."
msgstr "Este opcode é agora uma pseudo-instrução."

msgid "Opcode collections"
msgstr "Coleções de opcodes"

msgid ""
"These collections are provided for automatic introspection of bytecode "
"instructions:"
msgstr ""
"Estas coleções são fornecidas para introspeção automática de instruções de "
"bytecode:"

msgid ""
"The collections now contain pseudo instructions and instrumented "
"instructions as well. These are opcodes with values ``>= MIN_PSEUDO_OPCODE`` "
"and ``>= MIN_INSTRUMENTED_OPCODE``."
msgstr ""
"As coleções agora também contêm pseudo-instruções e instruções "
"instrumentadas. Estas são opcodes com valores ``>= MIN_PSEUDO_OPCODE`` e "
"``>= MIN_INSTRUMENTED_OPCODE``."

msgid "Sequence of operation names, indexable using the bytecode."
msgstr "Sequência de nomes de operações, indexável usando o bytecode."

msgid "Dictionary mapping operation names to bytecodes."
msgstr "Dicionário que mapeia nomes de operações para bytecodes."

msgid "Sequence of all compare operation names."
msgstr "Sequência de todos os nomes de operações de comparação."

msgid "Sequence of bytecodes that use their argument."
msgstr "Sequência de bytecodes que usam o seu argumento."

msgid "Sequence of bytecodes that access a constant."
msgstr "Sequência de bytecodes que acedem a uma constante."

msgid ""
"Sequence of bytecodes that access a :term:`free (closure) variable <closure "
"variable>`. 'free' in this context refers to names in the current scope that "
"are referenced by inner scopes or names in outer scopes that are referenced "
"from this scope.  It does *not* include references to global or builtin "
"scopes."
msgstr ""

msgid "Sequence of bytecodes that access an attribute by name."
msgstr "Sequência de bytecodes que acedem a um atributo por nome."

msgid "Sequence of bytecodes that have a jump target. All jumps are relative."
msgstr ""
"Sequência de bytecodes que têm um alvo de salto. Todos os saltos são "
"relativos."

msgid "Sequence of bytecodes that access a local variable."
msgstr "Sequência de bytecodes que acedem a uma variável local."

msgid "Sequence of bytecodes of Boolean operations."
msgstr "Sequência de bytecodes de operações booleanas."

msgid "Sequence of bytecodes that set an exception handler."
msgstr "Sequência de bytecodes que definem um manipulador de exceção."

msgid "Sequence of bytecodes that have a relative jump target."
msgstr "Sequência de bytecodes que têm um alvo de salto relativo."

msgid "All jumps are now relative. Use :data:`hasjump`."
msgstr "Todos os saltos são agora relativos. Use :data:`hasjump`."

msgid "Sequence of bytecodes that have an absolute jump target."
msgstr "Sequência de bytecodes que têm um alvo de salto absoluto."

msgid "All jumps are now relative. This list is empty."
msgstr "Todos os saltos são agora relativos. Esta lista está vazia."

msgid "built-in function"
msgstr "função incorporada"

msgid "slice"
msgstr "fatia"
