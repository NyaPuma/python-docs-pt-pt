# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# NyaPuma <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-19 14:14+0000\n"
"PO-Revision-Date: 2025-09-16 00:02+0000\n"
"Last-Translator: NyaPuma <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid "Lexical analysis"
msgstr "Análise léxica"

msgid ""
"A Python program is read by a *parser*.  Input to the parser is a stream of :"
"term:`tokens <token>`, generated by the *lexical analyzer* (also known as "
"the *tokenizer*). This chapter describes how the lexical analyzer produces "
"these tokens."
msgstr ""
"Um programa Python é lido por um *analisador sintático*. A entrada para o "
"analisador sintático é um fluxo de :term:`tokens <token>`, gerados pelo "
"*analisador léxico* (também conhecido como *tokenizador*). Este capítulo "
"descreve como o analisador léxico produz estes tokens."

msgid ""
"The lexical analyzer determines the program text's :ref:`encoding "
"<encodings>` (UTF-8 by default), and decodes the text into :ref:`source "
"characters <lexical-source-character>`. If the text cannot be decoded, a :"
"exc:`SyntaxError` is raised."
msgstr ""
"O analisador léxico determina a :ref:`codificação <encodings>` do texto do "
"programa (UTF-8 por predefinição) e descodifica o texto em :ref:`caracteres "
"de origem <lexical-source-character>`. Se o texto não puder ser "
"descodificado, é levantado um :exc:`SyntaxError`."

msgid ""
"Next, the lexical analyzer uses the source characters to generate a stream "
"of tokens. The type of a generated token generally depends on the next "
"source character to be processed. Similarly, other special behavior of the "
"analyzer depends on the first source character that hasn't yet been "
"processed. The following table gives a quick summary of these source "
"characters, with links to sections that contain more information."
msgstr ""
"De seguida, o analisador léxico utiliza os caracteres de origem para gerar "
"um fluxo de tokens. O tipo de token gerado depende geralmente do próximo "
"caractere de origem a ser processado. Da mesma forma, outros comportamentos "
"especiais do analisador dependem do primeiro caractere de origem que ainda "
"não foi processado. A tabela seguinte fornece um resumo rápido destes "
"caracteres de origem, com ligações para secções que contêm mais informações."

msgid "Character"
msgstr "Caractere"

msgid "Next token (or other relevant documentation)"
msgstr "Próximo token (ou outra documentação relevante)"

msgid "space"
msgstr "espaço"

msgid "tab"
msgstr "tabulação"

msgid "formfeed"
msgstr "avanço de formulário"

msgid ":ref:`Whitespace <whitespace>`"
msgstr ":ref:`Espaço em branco <whitespace>`"

msgid "CR, LF"
msgstr "CR, LF"

msgid ":ref:`New line <line-structure>`"
msgstr ":ref:`Nova linha <line-structure>`"

msgid ":ref:`Indentation <indentation>`"
msgstr ":ref:`Indentação <indentation>`"

msgid "backslash (``\\``)"
msgstr "barra invertida (``\\``)"

msgid ":ref:`Explicit line joining <explicit-joining>`"
msgstr ":ref:`Junção explícita de linhas <explicit-joining>`"

msgid "(Also significant in :ref:`string escape sequences <escape-sequences>`)"
msgstr ""
"(Também significativo em :ref:`sequências de escape de strings <escape-"
"sequences>`)"

msgid "hash (``#``)"
msgstr "cerquilha (``#``)"

msgid ":ref:`Comment <comments>`"
msgstr ":ref:`Comentário <comments>`"

msgid "quote (``'``, ``\"``)"
msgstr "aspa (``'``, ``\"``)"

msgid ":ref:`String literal <strings>`"
msgstr ":ref:`Literal de string <strings>`"

msgid "ASCII letter (``a``-``z``, ``A``-``Z``)"
msgstr "Letra ASCII (``a``-``z``, ``A``-``Z``)"

msgid "non-ASCII character"
msgstr "caractere não ASCII"

msgid ":ref:`Name <identifiers>`"
msgstr ":ref:`Nome <identifiers>`"

msgid "Prefixed :ref:`string or bytes literal <strings>`"
msgstr ":ref:`Literal de string ou bytes com prefixo <strings>`"

msgid "underscore (``_``)"
msgstr "sublinhado (``_``)"

msgid "(Can also be part of :ref:`numeric literals <numbers>`)"
msgstr "(Também pode fazer parte de :ref:`literais numéricos <numbers>`)"

msgid "number (``0``-``9``)"
msgstr "número (``0``-``9``)"

msgid ":ref:`Numeric literal <numbers>`"
msgstr ":ref:`Literal numérico <numbers>`"

msgid "dot (``.``)"
msgstr "ponto (``.``)"

msgid ":ref:`Operator <operators>`"
msgstr ":ref:`Operador <operators>`"

msgid "question mark (``?``)"
msgstr "ponto de interrogação (``?``)"

msgid "dollar (``$``)"
msgstr "símbolo de dólar (``$``)"

msgid "backquote (``​`​``)"
msgstr "crase (``​`​``)"

msgid "control character"
msgstr "caractere de controlo"

msgid "Error (outside string literals and comments)"
msgstr "Erro (fora de literais de string e comentários)"

msgid "other printing character"
msgstr "outro caractere imprimível"

msgid ":ref:`Operator or delimiter <operators>`"
msgstr ":ref:`Operador ou delimitador <operators>`"

msgid "end of file"
msgstr "fim de ficheiro"

msgid ":ref:`End marker <endmarker-token>`"
msgstr ":ref:`Marcador de fim <endmarker-token>`"

msgid "Line structure"
msgstr "Estrutura de linha"

msgid "A Python program is divided into a number of *logical lines*."
msgstr "Um programa Python é dividido num número de *linhas lógicas*."

msgid "Logical lines"
msgstr "Linhas lógicas"

msgid ""
"The end of a logical line is represented by the token :data:`~token."
"NEWLINE`. Statements cannot cross logical line boundaries except where :data:"
"`!NEWLINE` is allowed by the syntax (e.g., between statements in compound "
"statements). A logical line is constructed from one or more *physical lines* "
"by following the :ref:`explicit <explicit-joining>` or :ref:`implicit "
"<implicit-joining>` *line joining* rules."
msgstr ""
"O fim de uma linha lógica é representado pelo token :data:`~token.NEWLINE`. "
"As instruções não podem cruzar os limites das linhas lógicas, exceto onde :"
"data:`!NEWLINE` é permitido pela sintaxe (por exemplo, entre instruções em "
"instruções compostas). Uma linha lógica é construída a partir de uma ou mais "
"*linhas físicas*, seguindo as regras de :ref:`junção explícita <explicit-"
"joining>` ou :ref:`junção implícita <implicit-joining>`."

msgid "Physical lines"
msgstr "Linhas físicas"

msgid ""
"A physical line is a sequence of characters terminated by one the following "
"end-of-line sequences:"
msgstr ""
"Uma linha física é uma sequência de caracteres terminada por uma das "
"seguintes sequências de fim de linha:"

msgid "the Unix form using ASCII LF (linefeed),"
msgstr "a forma Unix utilizando ASCII LF (alimentação de linha),"

msgid ""
"the Windows form using the ASCII sequence CR LF (return followed by "
"linefeed),"
msgstr ""
"a forma Windows utilizando a sequência ASCII CR LF (retorno seguido de "
"alimentação de linha),"

msgid "the '`Classic Mac OS`__' form using the ASCII CR (return) character."
msgstr ""
"a forma '`Classic Mac OS`__' utilizando o caractere ASCII CR (retorno)."

msgid ""
"Regardless of platform, each of these sequences is replaced by a single "
"ASCII LF (linefeed) character. (This is done even inside :ref:`string "
"literals <strings>`.) Each line can use any of the sequences; they do not "
"need to be consistent within a file."
msgstr ""
"Independentemente da plataforma, cada uma destas sequências é substituída "
"por um único caractere ASCII LF (alimentação de linha). (Isto é feito mesmo "
"dentro de :ref:`literais de string <strings>`.) Cada linha pode utilizar "
"qualquer uma das sequências; não precisam de ser consistentes dentro de um "
"ficheiro."

msgid ""
"The end of input also serves as an implicit terminator for the final "
"physical line."
msgstr ""
"O fim da entrada também serve como terminador implícito para a última linha "
"física."

msgid "Formally:"
msgstr "Formalmente:"

msgid "Comments"
msgstr "Comentários"

msgid ""
"A comment starts with a hash character (``#``) that is not part of a string "
"literal, and ends at the end of the physical line.  A comment signifies the "
"end of the logical line unless the implicit line joining rules are invoked. "
"Comments are ignored by the syntax."
msgstr ""
"Um comentário começa com um caractere cerquilha (``#``) que não faz parte de "
"um literal de string e termina no fim da linha física. Um comentário "
"significa o fim da linha lógica, a menos que as regras de junção implícita "
"de linhas sejam invocadas. Os comentários são ignorados pela sintaxe."

msgid "Encoding declarations"
msgstr "Declarações de codificação"

msgid ""
"If a comment in the first or second line of the Python script matches the "
"regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is processed "
"as an encoding declaration; the first group of this expression names the "
"encoding of the source code file. The encoding declaration must appear on a "
"line of its own. If it is the second line, the first line must also be a "
"comment-only line. The recommended forms of an encoding expression are ::"
msgstr ""
"Se um comentário na primeira ou segunda linha do script Python corresponder "
"à expressão regular ``coding[=:]\\s*([-\\w.]+)``, este comentário é "
"processado como uma declaração de codificação; o primeiro grupo desta "
"expressão nomeia a codificação do ficheiro de código-fonte. A declaração de "
"codificação deve aparecer numa linha própria. Se for a segunda linha, a "
"primeira linha também deve ser uma linha apenas de comentário. As formas "
"recomendadas de uma expressão de codificação são::"

msgid "# -*- coding: <encoding-name> -*-"
msgstr "# -*- coding: <nome-da-codificação> -*-"

msgid "which is recognized also by GNU Emacs, and ::"
msgstr "que também é reconhecido pelo GNU Emacs, e::"

msgid "# vim:fileencoding=<encoding-name>"
msgstr "# vim:fileencoding=<nome-da-codificação>"

msgid "which is recognized by Bram Moolenaar's VIM."
msgstr "que é reconhecido pelo VIM de Bram Moolenaar."

msgid ""
"If no encoding declaration is found, the default encoding is UTF-8.  If the "
"implicit or explicit encoding of a file is UTF-8, an initial UTF-8 byte-"
"order mark (``b'\\xef\\xbb\\xbf'``) is ignored rather than being a syntax "
"error."
msgstr ""
"Se nenhuma declaração de codificação for encontrada, a codificação "
"predefinida é UTF-8. Se a codificação implícita ou explícita de um ficheiro "
"for UTF-8, uma marca de ordem de bytes UTF-8 inicial "
"(``b'\\xef\\xbb\\xbf'``) é ignorada em vez de ser um erro de sintaxe."

msgid ""
"If an encoding is declared, the encoding name must be recognized by Python "
"(see :ref:`standard-encodings`). The encoding is used for all lexical "
"analysis, including string literals, comments and identifiers."
msgstr ""
"Se uma codificação for declarada, o nome da codificação deve ser reconhecido "
"pelo Python (consulte :ref:`standard-encodings`). A codificação é utilizada "
"para toda a análise léxica, incluindo literais de string, comentários e "
"identificadores."

msgid ""
"All lexical analysis, including string literals, comments and identifiers, "
"works on Unicode text decoded using the source encoding. Any Unicode code "
"point, except the NUL control character, can appear in Python source."
msgstr ""
"Toda a análise léxica, incluindo literais de string, comentários e "
"identificadores, funciona em texto Unicode descodificado utilizando a "
"codificação de origem. Qualquer ponto de código Unicode, exceto o caractere "
"de controlo NUL, pode aparecer no código-fonte Python."

msgid "Explicit line joining"
msgstr "Junção explícita de linhas"

msgid ""
"Two or more physical lines may be joined into logical lines using backslash "
"characters (``\\``), as follows: when a physical line ends in a backslash "
"that is not part of a string literal or comment, it is joined with the "
"following forming a single logical line, deleting the backslash and the "
"following end-of-line character.  For example::"
msgstr ""
"Duas ou mais linhas físicas podem ser unidas em linhas lógicas utilizando "
"caracteres de barra invertida (``\\``), da seguinte forma: quando uma linha "
"física termina numa barra invertida que não faz parte de um literal de "
"string ou comentário, é unida com a seguinte, formando uma única linha "
"lógica, eliminando a barra invertida e o carácter de fim de linha seguinte. "
"Por exemplo::"

msgid ""
"if 1900 < year < 2100 and 1 <= month <= 12 \\\n"
"   and 1 <= day <= 31 and 0 <= hour < 24 \\\n"
"   and 0 <= minute < 60 and 0 <= second < 60:   # Looks like a valid date\n"
"        return 1"
msgstr ""
"if 1900 < year < 2100 and 1 <= month <= 12 \\\n"
"   and 1 <= day <= 31 and 0 <= hour < 24 \\\n"
"   and 0 <= minute < 60 and 0 <= second < 60:   # Parece uma data válida\n"
"        return 1"

msgid ""
"A line ending in a backslash cannot carry a comment.  A backslash does not "
"continue a comment.  A backslash does not continue a token except for string "
"literals (i.e., tokens other than string literals cannot be split across "
"physical lines using a backslash).  A backslash is illegal elsewhere on a "
"line outside a string literal."
msgstr ""
"Uma linha que termina numa barra invertida não pode conter um comentário. "
"Uma barra invertida não continua um comentário. Uma barra invertida não "
"continua um token, exceto para literais de string (ou seja, tokens que não "
"sejam literais de string não podem ser divididos em linhas físicas "
"utilizando uma barra invertida). Uma barra invertida é ilegal noutro local "
"numa linha fora de um literal de string."

msgid "Implicit line joining"
msgstr "Junção implícita de linhas"

msgid ""
"Expressions in parentheses, square brackets or curly braces can be split "
"over more than one physical line without using backslashes. For example::"
msgstr ""
"Expressões entre parênteses, colchetes retos ou chavetas podem ser divididas "
"por mais de uma linha física sem utilizar barras invertidas. Por exemplo::"

msgid ""
"month_names = ['Januari', 'Februari', 'Maart',      # These are the\n"
"               'April',   'Mei',      'Juni',       # Dutch names\n"
"               'Juli',    'Augustus', 'September',  # for the months\n"
"               'Oktober', 'November', 'December']   # of the year"
msgstr ""
"month_names = ['Janeiro', 'Fevereiro', 'Março',      # Estes são os\n"
"               'Abril',   'Maio',      'Junho',       # nomes holandeses\n"
"               'Julho',    'Agosto',    'Setembro',    # para os meses\n"
"               'Outubro', 'Novembro', 'Dezembro']    # do ano"

msgid ""
"Implicitly continued lines can carry comments.  The indentation of the "
"continuation lines is not important.  Blank continuation lines are allowed. "
"There is no NEWLINE token between implicit continuation lines.  Implicitly "
"continued lines can also occur within triple-quoted strings (see below); in "
"that case they cannot carry comments."
msgstr ""
"As linhas continuadas implicitamente podem conter comentários. A indentação "
"das linhas de continuação não é importante. Linhas de continuação em branco "
"são permitidas. Não existe um token NEWLINE entre linhas de continuação "
"implícitas. Linhas continuadas implicitamente também podem ocorrer dentro de "
"strings com triplas aspas (ver abaixo); nesse caso, não podem conter "
"comentários."

msgid "Blank lines"
msgstr "Linhas em branco"

msgid ""
"A logical line that contains only spaces, tabs, formfeeds and possibly a "
"comment, is ignored (i.e., no :data:`~token.NEWLINE` token is generated). "
"During interactive input of statements, handling of a blank line may differ "
"depending on the implementation of the read-eval-print loop. In the standard "
"interactive interpreter, an entirely blank logical line (that is, one "
"containing not even whitespace or a comment) terminates a multi-line "
"statement."
msgstr ""
"Uma linha lógica que contém apenas espaços, tabulações, avanços de "
"formulário e possivelmente um comentário é ignorada (ou seja, nenhum token :"
"data:`~token.NEWLINE` é gerado). Durante a entrada interativa de instruções, "
"o tratamento de uma linha em branco pode diferir dependendo da implementação "
"do ciclo de leitura-avaliação-impressão. No interpretador interativo padrão, "
"uma linha lógica completamente em branco (ou seja, uma que não contém sequer "
"espaço em branco ou um comentário) termina uma instrução de várias linhas."

msgid "Indentation"
msgstr "Indentação"

msgid ""
"Leading whitespace (spaces and tabs) at the beginning of a logical line is "
"used to compute the indentation level of the line, which in turn is used to "
"determine the grouping of statements."
msgstr ""
"O espaço em branco inicial (espaços e tabulações) no início de uma linha "
"lógica é utilizado para calcular o nível de indentação da linha, que por sua "
"vez é utilizado para determinar o agrupamento de instruções."

msgid ""
"Tabs are replaced (from left to right) by one to eight spaces such that the "
"total number of characters up to and including the replacement is a multiple "
"of eight (this is intended to be the same rule as used by Unix).  The total "
"number of spaces preceding the first non-blank character then determines the "
"line's indentation.  Indentation cannot be split over multiple physical "
"lines using backslashes; the whitespace up to the first backslash determines "
"the indentation."
msgstr ""
"As tabulações são substituídas (da esquerda para a direita) por um a oito "
"espaços, de modo a que o número total de caracteres até e incluindo a "
"substituição seja um múltiplo de oito (isto é intencionalmente a mesma regra "
"utilizada pelo Unix). O número total de espaços que precedem o primeiro "
"caractere não em branco determina então a indentação da linha. A indentação "
"não pode ser dividida por várias linhas físicas utilizando barras "
"invertidas; o espaço em branco até à primeira barra invertida determina a "
"indentação."

msgid ""
"Indentation is rejected as inconsistent if a source file mixes tabs and "
"spaces in a way that makes the meaning dependent on the worth of a tab in "
"spaces; a :exc:`TabError` is raised in that case."
msgstr ""
"A indentação é rejeitada como inconsistente se um ficheiro de origem "
"misturar tabulações e espaços de uma forma que torne o significado "
"dependente do valor de uma tabulação em espaços; nesse caso, é levantado um :"
"exc:`TabError`."

msgid ""
"**Cross-platform compatibility note:** because of the nature of text editors "
"on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for "
"the indentation in a single source file.  It should also be noted that "
"different platforms may explicitly limit the maximum indentation level."
msgstr ""
"**Nota de compatibilidade multiplataforma:** devido à natureza dos editores "
"de texto em plataformas não-UNIX, não é aconselhável utilizar uma mistura de "
"espaços e tabulações para a indentação num único ficheiro de origem. Também "
"deve ser notado que diferentes plataformas podem limitar explicitamente o "
"nível máximo de indentação."

msgid ""
"A formfeed character may be present at the start of the line; it will be "
"ignored for the indentation calculations above.  Formfeed characters "
"occurring elsewhere in the leading whitespace have an undefined effect (for "
"instance, they may reset the space count to zero)."
msgstr ""
"Um caractere de avanço de formulário pode estar presente no início da linha; "
"será ignorado para os cálculos de indentação acima. Caracteres de avanço de "
"formulário que ocorram noutro local no espaço em branco inicial têm um "
"efeito indefinido (por exemplo, podem redefinir a contagem de espaços para "
"zero)."

msgid ""
"The indentation levels of consecutive lines are used to generate :data:"
"`~token.INDENT` and :data:`~token.DEDENT` tokens, using a stack, as follows."
msgstr ""
"Os níveis de indentação de linhas consecutivas são utilizados para gerar "
"tokens :data:`~token.INDENT` e :data:`~token.DEDENT`, utilizando uma pilha, "
"da seguinte forma."

msgid ""
"Before the first line of the file is read, a single zero is pushed on the "
"stack; this will never be popped off again.  The numbers pushed on the stack "
"will always be strictly increasing from bottom to top.  At the beginning of "
"each logical line, the line's indentation level is compared to the top of "
"the stack. If it is equal, nothing happens. If it is larger, it is pushed on "
"the stack, and one :data:`!INDENT` token is generated.  If it is smaller, it "
"*must* be one of the numbers occurring on the stack; all numbers on the "
"stack that are larger are popped off, and for each number popped off a :data:"
"`!DEDENT` token is generated. At the end of the file, a :data:`!DEDENT` "
"token is generated for each number remaining on the stack that is larger "
"than zero."
msgstr ""
"Antes da primeira linha do ficheiro ser lida, um zero único é empurrado para "
"a pilha; este nunca será retirado novamente. Os números empurrados para a "
"pilha serão sempre estritamente crescentes de baixo para cima. No início de "
"cada linha lógica, o nível de indentação da linha é comparado com o topo da "
"pilha. Se for igual, nada acontece. Se for maior, é empurrado para a pilha e "
"um token :data:`!INDENT` é gerado. Se for menor, deve ser um dos números que "
"ocorrem na pilha; todos os números na pilha que são maiores são retirados e, "
"para cada número retirado, um token :data:`!DEDENT` é gerado. No final do "
"ficheiro, um token :data:`!DEDENT` é gerado para cada número que permanece "
"na pilha e que é maior que zero."

msgid ""
"Here is an example of a correctly (though confusingly) indented piece of "
"Python code::"
msgstr ""
"Aqui está um exemplo de um pedaço de código Python corretamente (embora de "
"forma confusa) indentado::"

msgid ""
"def perm(l):\n"
"        # Compute the list of all permutations of l\n"
"    if len(l) <= 1:\n"
"                  return [l]\n"
"    r = []\n"
"    for i in range(len(l)):\n"
"             s = l[:i] + l[i+1:]\n"
"             p = perm(s)\n"
"             for x in p:\n"
"              r.append(l[i:i+1] + x)\n"
"    return r"
msgstr ""
"def perm(l):\n"
"        # Calcular a lista de todas as permutações de l\n"
"    if len(l) <= 1:\n"
"                  return [l]\n"
"    r = []\n"
"    for i in range(len(l)):\n"
"             s = l[:i] + l[i+1:]\n"
"             p = perm(s)\n"
"             for x in p:\n"
"              r.append(l[i:i+1] + x)\n"
"    return r"

msgid "The following example shows various indentation errors::"
msgstr "O exemplo seguinte mostra vários erros de indentação::"

msgid ""
" def perm(l):                       # error: first line indented\n"
"for i in range(len(l)):             # error: not indented\n"
"    s = l[:i] + l[i+1:]\n"
"        p = perm(l[:i] + l[i+1:])   # error: unexpected indent\n"
"        for x in p:\n"
"                r.append(l[i:i+1] + x)\n"
"            return r                # error: inconsistent dedent"
msgstr ""
" def perm(l):                       # erro: primeira linha indentada\n"
"for i in range(len(l)):             # erro: não indentado\n"
"    s = l[:i] + l[i+1:]\n"
"        p = perm(l[:i] + l[i+1:])   # erro: indentação inesperada\n"
"        for x in p:\n"
"                r.append(l[i:i+1] + x)\n"
"            return r                # erro: dedentação inconsistente"

msgid ""
"(Actually, the first three errors are detected by the parser; only the last "
"error is found by the lexical analyzer --- the indentation of ``return r`` "
"does not match a level popped off the stack.)"
msgstr ""
"(Na verdade, os três primeiros erros são detetados pelo analisador "
"sintático; apenas o último erro é encontrado pelo analisador léxico — a "
"indentação de ``return r`` não corresponde a um nível retirado da pilha.)"

msgid "Whitespace between tokens"
msgstr "Espaço em branco entre tokens"

msgid ""
"Except at the beginning of a logical line or in string literals, the "
"whitespace characters space, tab and formfeed can be used interchangeably to "
"separate tokens.  Whitespace is needed between two tokens only if their "
"concatenation could otherwise be interpreted as a different token. For "
"example, ``ab`` is one token, but ``a b`` is two tokens. However, ``+a`` and "
"``+ a`` both produce two tokens, ``+`` and ``a``, as ``+a`` is not a valid "
"token."
msgstr ""
"Exceto no início de uma linha lógica ou em literais de string, os caracteres "
"de espaço em branco (espaço, tabulação e avanço de formulário) podem ser "
"utilizados de forma intercambiável para separar tokens. O espaço em branco é "
"necessário entre dois tokens apenas se a sua concatenação pudesse ser "
"interpretada como um token diferente. Por exemplo, ``ab`` é um token, mas "
"``a b`` são dois tokens. No entanto, ``+a`` e ``+ a`` produzem ambos dois "
"tokens, ``+`` e ``a``, uma vez que ``+a`` não é um token válido."

msgid "End marker"
msgstr "Marcador de fim"

msgid ""
"At the end of non-interactive input, the lexical analyzer generates an :data:"
"`~token.ENDMARKER` token."
msgstr ""
"No fim da entrada não interativa, o analisador léxico gera um token :data:"
"`~token.ENDMARKER`."

msgid "Other tokens"
msgstr "Outros tokens"

msgid ""
"Besides :data:`~token.NEWLINE`, :data:`~token.INDENT` and :data:`~token."
"DEDENT`, the following categories of tokens exist: *identifiers* and "
"*keywords* (:data:`~token.NAME`), *literals* (such as :data:`~token.NUMBER` "
"and :data:`~token.STRING`), and other symbols (*operators* and "
"*delimiters*, :data:`~token.OP`). Whitespace characters (other than logical "
"line terminators, discussed earlier) are not tokens, but serve to delimit "
"tokens. Where ambiguity exists, a token comprises the longest possible "
"string that forms a legal token, when read from left to right."
msgstr ""
"Além de :data:`~token.NEWLINE`, :data:`~token.INDENT` e :data:`~token."
"DEDENT`, existem as seguintes categorias de tokens: *identificadores* e "
"*palavras-chave* (:data:`~token.NAME`), *literais* (como :data:`~token."
"NUMBER` e :data:`~token.STRING`), e outros símbolos (*operadores* e "
"*delimitadores*, :data:`~token.OP`). Os caracteres de espaço em branco (além "
"dos terminadores de linha lógica, discutidos anteriormente) não são tokens, "
"mas servem para delimitar tokens. Quando existe ambiguidade, um token é "
"composto pela string mais longa possível que forma um token legal, quando "
"lida da esquerda para a direita."

msgid "Names (identifiers and keywords)"
msgstr "Nomes (identificadores e palavras-chave)"

msgid ""
":data:`~token.NAME` tokens represent *identifiers*, *keywords*, and *soft "
"keywords*."
msgstr ""
"Os tokens :data:`~token.NAME` representam *identificadores*, *palavras-"
"chave* e *palavras-chave suaves*."

msgid ""
"Within the ASCII range (U+0001..U+007F), the valid characters for names "
"include the uppercase and lowercase letters (``A-Z`` and ``a-z``), the "
"underscore ``_`` and, except for the first character, the digits ``0`` "
"through ``9``."
msgstr ""
"Dentro do intervalo ASCII (U+0001..U+007F), os caracteres válidos para nomes "
"incluem as letras maiúsculas e minúsculas (``A-Z`` e ``a-z``), o sublinhado "
"``_`` e, exceto para o primeiro caractere, os dígitos ``0`` a ``9``."

msgid ""
"Names must contain at least one character, but have no upper length limit. "
"Case is significant."
msgstr ""
"Os nomes devem conter pelo menos um caractere, mas não têm limite superior "
"de comprimento. A distinção entre maiúsculas e minúsculas é significativa."

msgid ""
"Besides ``A-Z``, ``a-z``, ``_`` and ``0-9``, names can also use \"letter-"
"like\" and \"number-like\" characters from outside the ASCII range, as "
"detailed below."
msgstr ""
"Além de ``A-Z``, ``a-z``, ``_`` e ``0-9``, os nomes também podem utilizar "
"caracteres \"semelhantes a letras\" e \"semelhantes a números\" de fora do "
"intervalo ASCII, conforme detalhado abaixo."

msgid ""
"All identifiers are converted into the `normalization form`_ NFKC while "
"parsing; comparison of identifiers is based on NFKC."
msgstr ""
"Todos os identificadores são convertidos para a `normalization form`_  NFKC "
"durante a análise; a comparação de identificadores é baseada em NFKC."

msgid ""
"Formally, the first character of a normalized identifier must belong to the "
"set ``id_start``, which is the union of:"
msgstr ""
"Formalmente, o primeiro caractere de um identificador normalizado deve "
"pertencer ao conjunto ``id_start``, que é a união de:"

msgid "Unicode category ``<Lu>`` - uppercase letters (includes ``A`` to ``Z``)"
msgstr "Categoria Unicode ``<Lu>`` — letras maiúsculas (inclui ``A`` a ``Z``)"

msgid "Unicode category ``<Ll>`` - lowercase letters (includes ``a`` to ``z``)"
msgstr "Categoria Unicode ``<Ll>`` — letras minúsculas (inclui ``a`` a ``z``)"

msgid "Unicode category ``<Lt>`` - titlecase letters"
msgstr "Categoria Unicode ``<Lt>`` — letras em título"

msgid "Unicode category ``<Lm>`` - modifier letters"
msgstr "Categoria Unicode ``<Lm>`` — letras modificadoras"

msgid "Unicode category ``<Lo>`` - other letters"
msgstr "Categoria Unicode ``<Lo>`` — outras letras"

msgid "Unicode category ``<Nl>`` - letter numbers"
msgstr "Categoria Unicode ``<Nl>`` — números em letra"

msgid "{``\"_\"``} - the underscore"
msgstr "{``\"_\"``} — o sublinhado"

msgid ""
"``<Other_ID_Start>`` - an explicit set of characters in `PropList.txt`_ to "
"support backwards compatibility"
msgstr ""
"``<Other_ID_Start>`` — um conjunto explícito de caracteres em `PropList."
"txt`_ para suportar compatibilidade retroativa"

msgid ""
"The remaining characters must belong to the set ``id_continue``, which is "
"the union of:"
msgstr ""
"Os caracteres restantes devem pertencer ao conjunto ``id_continue``, que é a "
"união de:"

msgid "all characters in ``id_start``"
msgstr "todos os caracteres em ``id_start``"

msgid "Unicode category ``<Nd>`` - decimal numbers (includes ``0`` to ``9``)"
msgstr "Categoria Unicode ``<Nd>`` — números decimais (inclui ``0`` a ``9``)"

msgid "Unicode category ``<Pc>`` - connector punctuations"
msgstr "Categoria Unicode ``<Pc>`` — pontuações de conector"

msgid "Unicode category ``<Mn>`` - nonspacing marks"
msgstr "Categoria Unicode ``<Mn>`` — marcas sem espaço"

msgid "Unicode category ``<Mc>`` - spacing combining marks"
msgstr "Categoria Unicode ``<Mc>`` — marcas de combinação com espaço"

msgid ""
"``<Other_ID_Continue>`` - another explicit set of characters in `PropList."
"txt`_ to support backwards compatibility"
msgstr ""
"``<Other_ID_Continue>`` — outro conjunto explícito de caracteres em "
"`PropList.txt`_ para suportar compatibilidade retroativa"

msgid ""
"Unicode categories use the version of the Unicode Character Database as "
"included in the :mod:`unicodedata` module."
msgstr ""
"As categorias Unicode utilizam a versão da Base de Dados de Caracteres "
"Unicode conforme incluída no módulo :mod:`unicodedata`."

msgid ""
"These sets are based on the Unicode standard annex `UAX-31`_. See also :pep:"
"`3131` for further details."
msgstr ""
"Estes conjuntos são baseados no anexo do padrão Unicode `UAX-31`_. Consulte "
"também :pep:`3131` para mais detalhes."

msgid ""
"Even more formally, names are described by the following lexical definitions:"
msgstr ""
"De forma ainda mais formal, os nomes são descritos pelas seguintes "
"definições léxicas:"

msgid ""
"A non-normative listing of all valid identifier characters as defined by "
"Unicode is available in the `DerivedCoreProperties.txt`_ file in the Unicode "
"Character Database."
msgstr ""
"Uma listagem não normativa de todos os caracteres de identificador válidos, "
"conforme definido pelo Unicode, está disponível no ficheiro "
"`DerivedCoreProperties.txt`_ na Base de Dados de Caracteres Unicode."

msgid "Keywords"
msgstr "Palavras-chave"

msgid ""
"The following names are used as reserved words, or *keywords* of the "
"language, and cannot be used as ordinary identifiers.  They must be spelled "
"exactly as written here:"
msgstr ""
"Os seguintes nomes são utilizados como palavras reservadas, ou *palavras-"
"chave* da linguagem, e não podem ser utilizados como identificadores comuns. "
"Devem ser escritos exatamente como aqui:"

msgid ""
"False      await      else       import     pass\n"
"None       break      except     in         raise\n"
"True       class      finally    is         return\n"
"and        continue   for        lambda     try\n"
"as         def        from       nonlocal   while\n"
"assert     del        global     not        with\n"
"async      elif       if         or         yield"
msgstr ""
"False      await      else       import     pass\n"
"None       break      except     in         raise\n"
"True       class      finally    is         return\n"
"and        continue   for        lambda     try\n"
"as         def        from       nonlocal   while\n"
"assert     del        global     not        with\n"
"async      elif       if         or         yield"

msgid "Soft Keywords"
msgstr "Palavras-chave suaves"

msgid ""
"Some names are only reserved under specific contexts. These are known as "
"*soft keywords*:"
msgstr ""
"Alguns nomes são reservados apenas em contextos específicos. Estes são "
"conhecidos como *palavras-chave suaves*:"

msgid ""
"``match``, ``case``, and ``_``, when used in the :keyword:`match` statement."
msgstr ""
"``match``, ``case`` e ``_``, quando utilizados na instrução :keyword:`match`."

msgid "``type``, when used in the :keyword:`type` statement."
msgstr "``type``, quando utilizado na instrução :keyword:`type`."

msgid ""
"These syntactically act as keywords in their specific contexts, but this "
"distinction is done at the parser level, not when tokenizing."
msgstr ""
"Estes atuam sintaticamente como palavras-chave nos seus contextos "
"específicos, mas esta distinção é feita ao nível do analisador sintático, "
"não durante a tokenização."

msgid ""
"As soft keywords, their use in the grammar is possible while still "
"preserving compatibility with existing code that uses these names as "
"identifier names."
msgstr ""
"Como palavras-chave suaves, o seu uso na gramática é possível enquanto ainda "
"preserva a compatibilidade com o código existente que utiliza estes nomes "
"como nomes de identificadores."

msgid "``type`` is now a soft keyword."
msgstr "``type`` é agora uma palavra-chave suave."

msgid "Reserved classes of identifiers"
msgstr "Classes reservadas de identificadores"

msgid ""
"Certain classes of identifiers (besides keywords) have special meanings.  "
"These classes are identified by the patterns of leading and trailing "
"underscore characters:"
msgstr ""
"Certas classes de identificadores (além de palavras-chave) têm significados "
"especiais. Estas classes são identificadas pelos padrões de sublinhados "
"iniciais e finais:"

msgid "``_*``"
msgstr "``_*``"

msgid "Not imported by ``from module import *``."
msgstr "Não importado por ``from module import *``."

msgid "``_``"
msgstr "``_``"

msgid ""
"In a ``case`` pattern within a :keyword:`match` statement, ``_`` is a :ref:"
"`soft keyword <soft-keywords>` that denotes a :ref:`wildcard <wildcard-"
"patterns>`."
msgstr ""
"Num padrão ``case`` dentro de uma instrução :keyword:`match`, ``_`` é uma :"
"ref:`palavra-chave suave <soft-keywords>` que denota um :ref:`curinga "
"<wildcard-patterns>`."

msgid ""
"Separately, the interactive interpreter makes the result of the last "
"evaluation available in the variable ``_``. (It is stored in the :mod:"
"`builtins` module, alongside built-in functions like ``print``.)"
msgstr ""
"Separadamente, o interpretador interativo disponibiliza o resultado da "
"última avaliação na variável ``_``. (Está armazenado no módulo :mod:"
"`builtins`, juntamente com funções integradas como ``print``.)"

msgid ""
"Elsewhere, ``_`` is a regular identifier. It is often used to name "
"\"special\" items, but it is not special to Python itself."
msgstr ""
"Noutros locais, ``_`` é um identificador regular. É frequentemente utilizado "
"para nomear itens \"especiais\", mas não é especial para o Python em si."

msgid ""
"The name ``_`` is often used in conjunction with internationalization; refer "
"to the documentation for the :mod:`gettext` module for more information on "
"this convention."
msgstr ""
"O nome ``_`` é frequentemente utilizado em conjunto com internacionalização; "
"consulte a documentação do módulo :mod:`gettext` para mais informações sobre "
"esta convenção."

msgid "It is also commonly used for unused variables."
msgstr "Também é comumente utilizado para variáveis não utilizadas."

msgid "``__*__``"
msgstr "``__*__``"

msgid ""
"System-defined names, informally known as \"dunder\" names. These names are "
"defined by the interpreter and its implementation (including the standard "
"library). Current system names are discussed in the :ref:`specialnames` "
"section and elsewhere. More will likely be defined in future versions of "
"Python.  *Any* use of ``__*__`` names, in any context, that does not follow "
"explicitly documented use, is subject to breakage without warning."
msgstr ""
"Nomes definidos pelo sistema, informalmente conhecidos como nomes "
"\"dunder\". Estes nomes são definidos pelo interpretador e pela sua "
"implementação (incluindo a biblioteca padrão). Os nomes atuais do sistema "
"são discutidos na secção :ref:`specialnames` e noutros locais. "
"Provavelmente, mais serão definidos em versões futuras do Python. *Qualquer* "
"uso de nomes ``__*__``, em qualquer contexto, que não siga o uso "
"explicitamente documentado, está sujeito a quebras sem aviso prévio."

msgid "``__*``"
msgstr "``__*``"

msgid ""
"Class-private names.  Names in this category, when used within the context "
"of a class definition, are re-written to use a mangled form to help avoid "
"name clashes between \"private\" attributes of base and derived classes. See "
"section :ref:`atom-identifiers`."
msgstr ""
"Nomes privados de classe. Nomes nesta categoria, quando utilizados no "
"contexto de uma definição de classe, são reescritos para utilizar uma forma "
"modificada para ajudar a evitar conflitos de nomes entre atributos "
"\"privados\" de classes base e derivadas. Consulte a secção :ref:`atom-"
"identifiers`."

msgid "Literals"
msgstr "Literais"

msgid "Literals are notations for constant values of some built-in types."
msgstr ""
"Os literais são notações para valores constantes de alguns tipos integrados."

msgid ""
"In terms of lexical analysis, Python has :ref:`string, bytes <strings>` and :"
"ref:`numeric <numbers>` literals."
msgstr ""
"Em termos de análise léxica, o Python tem literais de :ref:`string, bytes "
"<strings>` e :ref:`numéricos <numbers>`."

msgid ""
"Other \"literals\" are lexically denoted using :ref:`keywords <keywords>` "
"(``None``, ``True``, ``False``) and the special :ref:`ellipsis token "
"<lexical-ellipsis>` (``...``)."
msgstr ""
"Outros \"literais\" são denotados lexicamente utilizando :ref:`palavras-"
"chave <keywords>` (``None``, ``True``, ``False``) e o token especial :ref:"
"`reticências <lexical-ellipsis>` (``...``)."

msgid "String and Bytes literals"
msgstr "Literais de String e Bytes"

msgid ""
"String literals are text enclosed in single quotes (``'``) or double quotes "
"(``\"``). For example:"
msgstr ""
"Os literais de string são texto delimitado por aspas simples (``'``) ou "
"aspas duplas (``\"``). Por exemplo:"

msgid ""
"\"spam\"\n"
"'eggs'"
msgstr ""
"\"spam\"\n"
"'eggs'"

msgid ""
"The quote used to start the literal also terminates it, so a string literal "
"can only contain the other quote (except with escape sequences, see below). "
"For example:"
msgstr ""
"A aspa utilizada para iniciar o literal também o termina, pelo que um "
"literal de string só pode conter a outra aspa (exceto com sequências de "
"escape, ver abaixo). Por exemplo:"

msgid ""
"'Say \"Hello\", please.'\n"
"\"Don't do that!\""
msgstr ""
"'Diga \"Olá\", por favor.'\n"
"\"Não faça isso!\""

msgid ""
"Except for this limitation, the choice of quote character (``'`` or ``\"``) "
"does not affect how the literal is parsed."
msgstr ""
"Exceto por esta limitação, a escolha do caractere de aspas (``'`` ou ``\"``) "
"não afeta a forma como o literal é analisado."

msgid ""
"Inside a string literal, the backslash (``\\``) character introduces an :dfn:"
"`escape sequence`, which has special meaning depending on the character "
"after the backslash. For example, ``\\\"`` denotes the double quote "
"character, and does *not* end the string:"
msgstr ""
"Dentro de um literal de string, o caractere de barra invertida (``\\``) "
"introduz uma :dfn:`sequência de escape`, que tem um significado especial "
"dependendo do caractere após a barra invertida. Por exemplo, ``\\\"`` denota "
"o caractere de aspas duplas e *não* termina a string:"

msgid ""
">>> print(\"Say \\\"Hello\\\" to everyone!\")\n"
"Say \"Hello\" to everyone!"
msgstr ""
">>> print(\"Diga \\\"Olá\\\" a todos!\")\n"
"Diga \"Olá\" a todos!"

msgid ""
"See :ref:`escape sequences <escape-sequences>` below for a full list of such "
"sequences, and more details."
msgstr ""
"Consulte :ref:`sequências de escape <escape-sequences>` abaixo para uma "
"lista completa destas sequências e mais detalhes."

msgid "Triple-quoted strings"
msgstr "Strings com triplas aspas"

msgid ""
"Strings can also be enclosed in matching groups of three single or double "
"quotes. These are generally referred to as :dfn:`triple-quoted strings`::"
msgstr ""
"As strings também podem ser delimitadas por grupos correspondentes de três "
"aspas simples ou duplas. Estes são geralmente referidos como :dfn:`strings "
"com triplas aspas`::"

msgid "\"\"\"This is a triple-quoted string.\"\"\""
msgstr "\"\"\"Esta é uma string com triplas aspas.\"\"\""

msgid ""
"In triple-quoted literals, unescaped quotes are allowed (and are retained), "
"except that three unescaped quotes in a row terminate the literal, if they "
"are of the same kind (``'`` or ``\"``) used at the start::"
msgstr ""
"Nos literais com triplas aspas, aspas não escapadas são permitidas (e são "
"retidas), exceto que três aspas não escapadas em sequência terminam o "
"literal, se forem do mesmo tipo (``'`` ou ``\"``) utilizado no início::"

msgid "\"\"\"This string has \"quotes\" inside.\"\"\""
msgstr "\"\"\"Esta string tem \"aspas\" dentro.\"\"\""

msgid "Unescaped newlines are also allowed and retained::"
msgstr "Novas linhas não escapadas também são permitidas e retidas::"

msgid ""
"'''This triple-quoted string\n"
"continues on the next line.'''"
msgstr ""
"'''Esta string com triplas aspas\n"
"continua na linha seguinte.'''"

msgid "String prefixes"
msgstr "Prefixos de string"

msgid ""
"String literals can have an optional :dfn:`prefix` that influences how the "
"content of the literal is parsed, for example:"
msgstr ""
"Os literais de string podem ter um :dfn:`prefixo` opcional que influencia a "
"forma como o conteúdo do literal é analisado, por exemplo:"

msgid ""
"b\"data\"\n"
"f'{result=}'"
msgstr ""
"b\"dados\"\n"
"f'{resultado=}'"

msgid "The allowed prefixes are:"
msgstr "Os prefixos permitidos são:"

msgid "``b``: :ref:`Bytes literal <bytes-literal>`"
msgstr "``b``: :ref:`Literal de bytes <bytes-literal>`"

msgid "``r``: :ref:`Raw string <raw-strings>`"
msgstr "``r``: :ref:`String bruta <raw-strings>`"

msgid "``f``: :ref:`Formatted string literal <f-strings>` (\"f-string\")"
msgstr "``f``: :ref:`Literal de string formatada <f-strings>` (\"f-string\")"

msgid "``t``: :ref:`Template string literal <t-strings>` (\"t-string\")"
msgstr "``t``: :ref:`Literal de string de modelo <t-strings>` (\"t-string\")"

msgid "``u``: No effect (allowed for backwards compatibility)"
msgstr "``u``: Sem efeito (permitido para compatibilidade retroativa)"

msgid "See the linked sections for details on each type."
msgstr "Consulte as secções ligadas para detalhes sobre cada tipo."

msgid ""
"Prefixes are case-insensitive (for example, '``B``' works the same as "
"'``b``'). The '``r``' prefix can be combined with '``f``', '``t``' or "
"'``b``', so '``fr``', '``rf``', '``tr``', '``rt``', '``br``', and '``rb``' "
"are also valid prefixes."
msgstr ""
"Os prefixos não são sensíveis a maiúsculas/minúsculas (por exemplo, '``B``' "
"funciona da mesma forma que '``b``'). O prefixo '``r``' pode ser combinado "
"com '``f``', '``t``' ou '``b``', pelo que '``fr``', '``rf``', '``tr``', "
"'``rt``', '``br``' e '``rb``' também são prefixos válidos."

msgid ""
"The ``'rb'`` prefix of raw bytes literals has been added as a synonym of "
"``'br'``."
msgstr ""
"O prefixo ``'rb'`` de literais de bytes brutos foi adicionado como sinónimo "
"de ``'br'``."

msgid ""
"Support for the unicode legacy literal (``u'value'``) was reintroduced to "
"simplify the maintenance of dual Python 2.x and 3.x codebases. See :pep:"
"`414` for more information."
msgstr ""
"O suporte para o literal legado unicode (``u'value'``) foi reintroduzido "
"para simplificar a manutenção de bases de código Python 2.x e 3.x. Consulte :"
"pep:`414` para mais informações."

msgid "Formal grammar"
msgstr "Gramática formal"

msgid ""
"String literals, except :ref:`\"f-strings\" <f-strings>` and :ref:`\"t-"
"strings\" <t-strings>`, are described by the following lexical definitions."
msgstr ""
"Os literais de string, exceto :ref:`\"f-strings\" <f-strings>` e :ref:`\"t-"
"strings\" <t-strings>`, são descritos pelas seguintes definições léxicas."

msgid ""
"These definitions use :ref:`negative lookaheads <lexical-lookaheads>` (``!"
"``) to indicate that an ending quote ends the literal."
msgstr ""
"Estas definições utilizam :ref:`negative lookaheads <lexical-lookaheads>` "
"(``!``) para indicar que uma aspa final termina o literal."

msgid ""
"Note that as in all lexical definitions, whitespace is significant. In "
"particular, the prefix (if any) must be immediately followed by the starting "
"quote."
msgstr ""
"Note que, como em todas as definições léxicas, o espaço em branco é "
"significativo. Em particular, o prefixo (se existir) deve ser imediatamente "
"seguido pela aspa inicial."

msgid "Escape sequences"
msgstr "Sequências de escape"

msgid ""
"Unless an '``r``' or '``R``' prefix is present, escape sequences in string "
"and bytes literals are interpreted according to rules similar to those used "
"by Standard C.  The recognized escape sequences are:"
msgstr ""
"A menos que esteja presente um prefixo '``r``' ou '``R``', as sequências de "
"escape em literais de string e bytes são interpretadas de acordo com regras "
"semelhantes às utilizadas pelo C padrão. As sequências de escape "
"reconhecidas são:"

msgid "Escape Sequence"
msgstr "Sequência de Escape"

msgid "Meaning"
msgstr "Significado"

msgid "``\\``\\ <newline>"
msgstr "``\\``\\ <nova linha>"

msgid ":ref:`string-escape-ignore`"
msgstr ":ref:`string-escape-ignore`"

msgid "``\\\\``"
msgstr "``\\\\``"

msgid ":ref:`Backslash <string-escape-escaped-char>`"
msgstr ":ref:`Barra invertida <string-escape-escaped-char>`"

msgid "``\\'``"
msgstr "``\\'``"

msgid ":ref:`Single quote <string-escape-escaped-char>`"
msgstr ":ref:`Aspa simples <string-escape-escaped-char>`"

msgid "``\\\"``"
msgstr "``\\\"``"

msgid ":ref:`Double quote <string-escape-escaped-char>`"
msgstr ":ref:`Aspa dupla <string-escape-escaped-char>`"

msgid "``\\a``"
msgstr "``\\a``"

msgid "ASCII Bell (BEL)"
msgstr "Campainha ASCII (BEL)"

msgid "``\\b``"
msgstr "``\\b``"

msgid "ASCII Backspace (BS)"
msgstr "Retrocesso ASCII (BS)"

msgid "``\\f``"
msgstr "``\\f``"

msgid "ASCII Formfeed (FF)"
msgstr "Avanço de formulário ASCII (FF)"

msgid "``\\n``"
msgstr "``\\n``"

msgid "ASCII Linefeed (LF)"
msgstr "Alimentação de linha ASCII (LF)"

msgid "``\\r``"
msgstr "``\\r``"

msgid "ASCII Carriage Return (CR)"
msgstr "Retorno de carro ASCII (CR)"

msgid "``\\t``"
msgstr "``\\t``"

msgid "ASCII Horizontal Tab (TAB)"
msgstr "Tabulação horizontal ASCII (TAB)"

msgid "``\\v``"
msgstr "``\\v``"

msgid "ASCII Vertical Tab (VT)"
msgstr "Tabulação vertical ASCII (VT)"

msgid ":samp:`\\\\\\\\{ooo}`"
msgstr ":samp:`\\\\\\\\{ooo}`"

msgid ":ref:`string-escape-oct`"
msgstr ":ref:`string-escape-oct`"

msgid ":samp:`\\\\x{hh}`"
msgstr ":samp:`\\\\x{hh}`"

msgid ":ref:`string-escape-hex`"
msgstr ":ref:`string-escape-hex`"

msgid ":samp:`\\\\N\\\\{{name}\\\\}`"
msgstr ":samp:`\\\\N\\\\{{name}\\\\}`"

msgid ":ref:`string-escape-named`"
msgstr ":ref:`string-escape-named`"

msgid ":samp:`\\\\u{xxxx}`"
msgstr ":samp:`\\\\u{xxxx}`"

msgid ":ref:`Hexadecimal Unicode character <string-escape-long-hex>`"
msgstr ":ref:`Caractere Unicode hexadecimal <string-escape-long-hex>`"

msgid ":samp:`\\\\U{xxxxxxxx}`"
msgstr ":samp:`\\\\U{xxxxxxxx}`"

msgid "Ignored end of line"
msgstr "Fim de linha ignorado"

msgid "A backslash can be added at the end of a line to ignore the newline::"
msgstr ""
"Uma barra invertida pode ser adicionada no final de uma linha para ignorar a "
"nova linha::"

msgid ""
">>> 'This string will not include \\\n"
"... backslashes or newline characters.'\n"
"'This string will not include backslashes or newline characters.'"
msgstr ""
">>> 'Esta string não incluirá \\\n"
"... barras invertidas ou caracteres de nova linha.'\n"
"'Esta string não incluirá barras invertidas ou caracteres de nova linha.'"

msgid ""
"The same result can be achieved using :ref:`triple-quoted strings "
"<strings>`, or parentheses and :ref:`string literal concatenation <string-"
"concatenation>`."
msgstr ""
"O mesmo resultado pode ser alcançado utilizando :ref:`strings com triplas "
"aspas <strings>`, ou parênteses e :ref:`concatenação de literais de string "
"<string-concatenation>`."

msgid "Escaped characters"
msgstr "Caracteres escapados"

msgid ""
"To include a backslash in a non-:ref:`raw <raw-strings>` Python string "
"literal, it must be doubled. The ``\\\\`` escape sequence denotes a single "
"backslash character::"
msgstr ""
"Para incluir uma barra invertida num literal de string Python não :ref:"
"`bruto <raw-strings>`, deve ser duplicada. A sequência de escape ``\\\\`` "
"denota um único caractere de barra invertida::"

msgid ""
">>> print('C:\\\\Program Files')\n"
"C:\\Program Files"
msgstr ""
">>> print('C:\\\\Program Files')\n"
"C:\\Program Files"

msgid ""
"Similarly, the ``\\'`` and ``\\\"`` sequences denote the single and double "
"quote character, respectively::"
msgstr ""
"Da mesma forma, as sequências ``\\'`` e ``\\\"`` denotam os caracteres de "
"aspa simples e dupla, respetivamente::"

msgid ""
">>> print('\\' and \\\"')\n"
"' and \""
msgstr ""
">>> print('\\' e \\\"')\n"
"' e \""

msgid "Octal character"
msgstr "Caractere octal"

msgid ""
"The sequence :samp:`\\\\\\\\{ooo}` denotes a *character* with the octal "
"(base 8) value *ooo*::"
msgstr ""
"A sequência :samp:`\\\\\\\\{ooo}` denota um *caractere* com o valor octal "
"(base 8) *ooo*::"

msgid ""
">>> '\\120'\n"
"'P'"
msgstr ""
">>> '\\120'\n"
"'P'"

msgid "Up to three octal digits (0 through 7) are accepted."
msgstr "São aceites até três dígitos octais (0 a 7)."

msgid ""
"In a bytes literal, *character* means a *byte* with the given value. In a "
"string literal, it means a Unicode character with the given value."
msgstr ""
"Num literal de bytes, *character* significa um *byte* com o valor dado. Num "
"literal de string, significa um caractere Unicode com o valor dado."

msgid ""
"Octal escapes with value larger than ``0o377`` (255) produce a :exc:"
"`DeprecationWarning`."
msgstr ""
"Escapes octais com valor superior a ``0o377`` (255) produzem um :exc:"
"`DeprecationWarning`."

msgid ""
"Octal escapes with value larger than ``0o377`` (255) produce a :exc:"
"`SyntaxWarning`. In a future Python version they will raise a :exc:"
"`SyntaxError`."
msgstr ""
"Escapes octais com valor superior a ``0o377`` (255) produzem um :exc:"
"`SyntaxWarning`. Numa versão futura do Python, irão levantar um :exc:"
"`SyntaxError`."

msgid "Hexadecimal character"
msgstr "Caractere hexadecimal"

msgid ""
"The sequence :samp:`\\\\x{hh}` denotes a *character* with the hex (base 16) "
"value *hh*::"
msgstr ""
"A sequência :samp:`\\\\x{hh}` denota um *caractere* com o valor hexadecimal "
"(base 16) *hh*::"

msgid ""
">>> '\\x50'\n"
"'P'"
msgstr ""
">>> '\\x50'\n"
"'P'"

msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr ""
"Ao contrário do C padrão, são necessários exatamente dois dígitos "
"hexadecimais."

msgid "Named Unicode character"
msgstr "Caractere Unicode nomeado"

msgid ""
"The sequence :samp:`\\\\N\\\\{{name}\\\\}` denotes a Unicode character with "
"the given *name*::"
msgstr ""
"A sequência :samp:`\\\\N\\\\{{name}\\\\}` denota um caractere Unicode com o "
"*nome* dado::"

msgid ""
">>> '\\N{LATIN CAPITAL LETTER P}'\n"
"'P'\n"
">>> '\\N{SNAKE}'\n"
"'🐍'"
msgstr ""
">>> '\\N{LATIN CAPITAL LETTER P}'\n"
"'P'\n"
">>> '\\N{SNAKE}'\n"
"'🐍'"

msgid "This sequence cannot appear in :ref:`bytes literals <bytes-literal>`."
msgstr ""
"Esta sequência não pode aparecer em :ref:`literais de bytes <bytes-"
"literal>`. "

msgid ""
"Support for `name aliases <https://www.unicode.org/Public/16.0.0/ucd/"
"NameAliases.txt>`__ has been added."
msgstr ""
"Foi adicionado suporte para `aliases de nomes <https://www.unicode.org/"
"Public/16.0.0/ucd/NameAliases.txt>`__."

msgid "Hexadecimal Unicode characters"
msgstr "Caracteres Unicode hexadecimais"

msgid ""
"These sequences :samp:`\\\\u{xxxx}` and :samp:`\\\\U{xxxxxxxx}` denote the "
"Unicode character with the given hex (base 16) value. Exactly four digits "
"are required for ``\\u``; exactly eight digits are required for ``\\U``. The "
"latter can encode any Unicode character."
msgstr ""
"Estas sequências :samp:`\\\\u{xxxx}` e :samp:`\\\\U{xxxxxxxx}` denotam o "
"caractere Unicode com o valor hexadecimal (base 16) dado. São necessários "
"exatamente quatro dígitos para ``\\u``; são necessários exatamente oito "
"dígitos para ``\\U``. Esta última pode codificar qualquer caractere Unicode."

msgid ""
">>> '\\u1234'\n"
"'ሴ'\n"
">>> '\\U0001f40d'\n"
"'🐍'"
msgstr ""
">>> '\\u1234'\n"
"'ሴ'\n"
">>> '\\U0001f40d'\n"
"'🐍'"

msgid "These sequences cannot appear in :ref:`bytes literals <bytes-literal>`."
msgstr ""
"Estas sequências não podem aparecer em :ref:`literais de bytes <bytes-"
"literal>`. "

msgid "Unrecognized escape sequences"
msgstr "Sequências de escape não reconhecidas"

msgid ""
"Unlike in Standard C, all unrecognized escape sequences are left in the "
"string unchanged, that is, *the backslash is left in the result*::"
msgstr ""
"Ao contrário do C padrão, todas as sequências de escape não reconhecidas são "
"deixadas na string inalteradas, ou seja, *a barra invertida é deixada no "
"resultado*::"

msgid ""
">>> print('\\q')\n"
"\\q\n"
">>> list('\\q')\n"
"['\\\\', 'q']"
msgstr ""
">>> print('\\q')\n"
"\\q\n"
">>> list('\\q')\n"
"['\\\\', 'q']"

msgid ""
"Note that for bytes literals, the escape sequences only recognized in string "
"literals (``\\N...``, ``\\u...``, ``\\U...``) fall into the category of "
"unrecognized escapes."
msgstr ""
"Note que, para literais de bytes, as sequências de escape reconhecidas "
"apenas em literais de string (``\\N...``, ``\\u...``, ``\\U...``) caem na "
"categoria de escapes não reconhecidos."

msgid "Unrecognized escape sequences produce a :exc:`DeprecationWarning`."
msgstr ""
"Sequências de escape não reconhecidas produzem um :exc:`DeprecationWarning`."

msgid ""
"Unrecognized escape sequences produce a :exc:`SyntaxWarning`. In a future "
"Python version they will raise a :exc:`SyntaxError`."
msgstr ""
"Sequências de escape não reconhecidas produzem um :exc:`SyntaxWarning`. Numa "
"versão futura do Python, irão levantar um :exc:`SyntaxError`."

msgid "Bytes literals"
msgstr "Literais de bytes"

msgid ""
":dfn:`Bytes literals` are always prefixed with '``b``' or '``B``'; they "
"produce an instance of the :class:`bytes` type instead of the :class:`str` "
"type. They may only contain ASCII characters; bytes with a numeric value of "
"128 or greater must be expressed with escape sequences (typically :ref:"
"`string-escape-hex` or :ref:`string-escape-oct`):"
msgstr ""
"Os :dfn:`literais de bytes` são sempre prefixados com '``b``' ou '``B``'; "
"produzem uma instância do tipo :class:`bytes` em vez do tipo :class:`str`. "
"Só podem conter caracteres ASCII; bytes com um valor numérico de 128 ou "
"superior devem ser expressos com sequências de escape (tipicamente :ref:"
"`string-escape-hex` ou :ref:`string-escape-oct`):"

msgid ""
">>> b'\\x89PNG\\r\\n\\x1a\\n'\n"
"b'\\x89PNG\\r\\n\\x1a\\n'\n"
">>> list(b'\\x89PNG\\r\\n\\x1a\\n')\n"
"[137, 80, 78, 71, 13, 10, 26, 10]"
msgstr ""
">>> b'\\x89PNG\\r\\n\\x1a\\n'\n"
"b'\\x89PNG\\r\\n\\x1a\\n'\n"
">>> list(b'\\x89PNG\\r\\n\\x1a\\n')\n"
"[137, 80, 78, 71, 13, 10, 26, 10]"

msgid ""
"Similarly, a zero byte must be expressed using an escape sequence (typically "
"``\\0`` or ``\\x00``)."
msgstr ""
"Da mesma forma, um byte zero deve ser expresso utilizando uma sequência de "
"escape (tipicamente ``\\0`` ou ``\\x00``)."

msgid "Raw string literals"
msgstr "Literais de string brutos"

msgid ""
"Both string and bytes literals may optionally be prefixed with a letter "
"'``r``' or '``R``'; such constructs are called :dfn:`raw string literals` "
"and :dfn:`raw bytes literals` respectively and treat backslashes as literal "
"characters. As a result, in raw string literals, :ref:`escape sequences "
"<escape-sequences>` are not treated specially:"
msgstr ""
"Tanto literais de string como de bytes podem ser opcionalmente prefixados "
"com uma letra '``r``' ou '``R``'; tais construções são chamadas :dfn:"
"`literais de string brutos` e :dfn:`literais de bytes brutos`, "
"respetivamente, e tratam as barras invertidas como caracteres literais. Como "
"resultado, em literais de string brutos, as :ref:`sequências de escape "
"<escape-sequences>` não são tratadas de forma especial:"

msgid ""
">>> r'\\d{4}-\\d{2}-\\d{2}'\n"
"'\\\\d{4}-\\\\d{2}-\\\\d{2}'"
msgstr ""
">>> r'\\d{4}-\\d{2}-\\d{2}'\n"
"'\\\\d{4}-\\\\d{2}-\\\\d{2}'"

msgid ""
"Even in a raw literal, quotes can be escaped with a backslash, but the "
"backslash remains in the result; for example, ``r\"\\\"\"`` is a valid "
"string literal consisting of two characters: a backslash and a double quote; "
"``r\"\\\"`` is not a valid string literal (even a raw string cannot end in "
"an odd number of backslashes).  Specifically, *a raw literal cannot end in a "
"single backslash* (since the backslash would escape the following quote "
"character).  Note also that a single backslash followed by a newline is "
"interpreted as those two characters as part of the literal, *not* as a line "
"continuation."
msgstr ""
"Mesmo num literal bruto, as aspas podem ser escapadas com uma barra "
"invertida, mas a barra invertida permanece no resultado; por exemplo, ``r\"\\"
"\"\"`` é um literal de string válido composto por dois caracteres: uma barra "
"invertida e uma aspa dupla; ``r\"\\\"`` não é um literal de string válido "
"(mesmo uma string bruta não pode terminar num número ímpar de barras "
"invertidas). Especificamente, *um literal bruto não pode terminar numa única "
"barra invertida* (uma vez que a barra invertida escaparia o caractere de "
"aspas seguinte). Note também que uma única barra invertida seguida de uma "
"nova linha é interpretada como esses dois caracteres como parte do literal, "
"*não* como uma continuação de linha."

msgid "f-strings"
msgstr "f-strings"

msgid ""
"A :dfn:`formatted string literal` or :dfn:`f-string` is a string literal "
"that is prefixed with '``f``' or '``F``'.  These strings may contain "
"replacement fields, which are expressions delimited by curly braces ``{}``. "
"While other string literals always have a constant value, formatted strings "
"are really expressions evaluated at run time."
msgstr ""
"Um :dfn:`literal de string formatada` ou :dfn:`f-string` é um literal de "
"string prefixado com '``f``' ou '``F``'. Estas strings podem conter campos "
"de substituição, que são expressões delimitadas por chavetas ``{}``. "
"Enquanto outros literais de string têm sempre um valor constante, as strings "
"formatadas são realmente expressões avaliadas em tempo de execução."

msgid ""
"Escape sequences are decoded like in ordinary string literals (except when a "
"literal is also marked as a raw string).  After decoding, the grammar for "
"the contents of the string is:"
msgstr ""
"As sequências de escape são descodificadas como em literais de string comuns "
"(exceto quando um literal também está marcado como uma string bruta). Após a "
"descodificação, a gramática para o conteúdo da string é:"

msgid ""
"The parts of the string outside curly braces are treated literally, except "
"that any doubled curly braces ``'{{'`` or ``'}}'`` are replaced with the "
"corresponding single curly brace.  A single opening curly bracket ``'{'`` "
"marks a replacement field, which starts with a Python expression. To display "
"both the expression text and its value after evaluation, (useful in "
"debugging), an equal sign ``'='`` may be added after the expression. A "
"conversion field, introduced by an exclamation point ``'!'`` may follow.  A "
"format specifier may also be appended, introduced by a colon ``':'``. A "
"replacement field ends with a closing curly bracket ``'}'``."
msgstr ""
"As partes da string fora das chavetas são tratadas literalmente, exceto que "
"quaisquer chavetas duplas ``'{{'`` ou ``'}}'`` são substituídas pela chaveta "
"simples correspondente. Uma chaveta de abertura simples ``'{'`` marca um "
"campo de substituição, que começa com uma expressão Python. Para mostrar "
"tanto o texto da expressão como o seu valor após avaliação (útil em "
"depuração), um sinal de igual ``'='`` pode ser adicionado após a expressão. "
"Um campo de conversão, introduzido por um ponto de exclamação ``'!'`` pode "
"seguir. Um especificador de formato também pode ser anexado, introduzido por "
"dois pontos ``':'``. Um campo de substituição termina com uma chaveta de "
"fecho ``'}'``."

msgid ""
"Expressions in formatted string literals are treated like regular Python "
"expressions surrounded by parentheses, with a few exceptions. An empty "
"expression is not allowed, and both :keyword:`lambda`  and assignment "
"expressions ``:=`` must be surrounded by explicit parentheses. Each "
"expression is evaluated in the context where the formatted string literal "
"appears, in order from left to right.  Replacement expressions can contain "
"newlines in both single-quoted and triple-quoted f-strings and they can "
"contain comments.  Everything that comes after a ``#`` inside a replacement "
"field is a comment (even closing braces and quotes). In that case, "
"replacement fields must be closed in a different line."
msgstr ""
"As expressões em literais de string formatadas são tratadas como expressões "
"Python regulares rodeadas por parênteses, com algumas exceções. Uma "
"expressão vazia não é permitida, e tanto :keyword:`lambda` como expressões "
"de atribuição ``:=`` devem ser rodeadas por parênteses explícitos. Cada "
"expressão é avaliada no contexto onde o literal de string formatada aparece, "
"da esquerda para a direita. As expressões de substituição podem conter novas "
"linhas em f-strings com aspas simples e triplas e podem conter comentários. "
"Tudo o que vem após um ``#`` dentro de um campo de substituição é um "
"comentário (mesmo chavetas de fecho e aspas). Nesse caso, os campos de "
"substituição devem ser fechados numa linha diferente."

msgid ""
">>> f\"abc{a # This is a comment }\"\n"
"... + 3}\"\n"
"'abc5'"
msgstr ""
">>> f\"abc{a # Isto é um comentário }\"\n"
"... + 3}\"\n"
"'abc5'"

msgid ""
"Prior to Python 3.7, an :keyword:`await` expression and comprehensions "
"containing an :keyword:`async for` clause were illegal in the expressions in "
"formatted string literals due to a problem with the implementation."
msgstr ""
"Antes do Python 3.7, uma expressão :keyword:`await` e comprehensions "
"contendo uma cláusula :keyword:`async for` eram ilegais nas expressões em "
"literais de string formatadas devido a um problema com a implementação."

msgid ""
"Prior to Python 3.12, comments were not allowed inside f-string replacement "
"fields."
msgstr ""
"Antes do Python 3.12, os comentários não eram permitidos dentro dos campos "
"de substituição de f-strings."

msgid ""
"When the equal sign ``'='`` is provided, the output will have the expression "
"text, the ``'='`` and the evaluated value. Spaces after the opening brace "
"``'{'``, within the expression and after the ``'='`` are all retained in the "
"output. By default, the ``'='`` causes the :func:`repr` of the expression to "
"be provided, unless there is a format specified. When a format is specified "
"it defaults to the :func:`str` of the expression unless a conversion ``'!"
"r'`` is declared."
msgstr ""
"Quando o sinal de igual ``'='`` é fornecido, a saída terá o texto da "
"expressão, o ``'='`` e o valor avaliado. Os espaços após a chaveta de "
"abertura ``'{'``, dentro da expressão e após o ``'='`` são todos retidos na "
"saída. Por predefinição, o ``'='`` faz com que a :func:`repr` da expressão "
"seja fornecida, a menos que haja um formato especificado. Quando um formato "
"é especificado, o predefinido é a :func:`str` da expressão, a menos que uma "
"conversão ``'!r'`` seja declarada."

msgid "The equal sign ``'='``."
msgstr "O sinal de igual ``'='``."

msgid ""
"If a conversion is specified, the result of evaluating the expression is "
"converted before formatting.  Conversion ``'!s'`` calls :func:`str` on the "
"result, ``'!r'`` calls :func:`repr`, and ``'!a'`` calls :func:`ascii`."
msgstr ""
"Se uma conversão for especificada, o resultado da avaliação da expressão é "
"convertido antes da formatação. A conversão ``'!s'`` chama :func:`str` no "
"resultado, ``'!r'`` chama :func:`repr`, e ``'!a'`` chama :func:`ascii`."

msgid ""
"The result is then formatted using the :func:`format` protocol.  The format "
"specifier is passed to the :meth:`~object.__format__` method of the "
"expression or conversion result.  An empty string is passed when the format "
"specifier is omitted.  The formatted result is then included in the final "
"value of the whole string."
msgstr ""
"O resultado é então formatado utilizando o protocolo :func:`format`. O "
"especificador de formato é passado ao método :meth:`~object.__format__` da "
"expressão ou resultado da conversão. Uma string vazia é passada quando o "
"especificador de formato é omitido. O resultado formatado é então incluído "
"no valor final de toda a string."

msgid ""
"Top-level format specifiers may include nested replacement fields. These "
"nested fields may include their own conversion fields and :ref:`format "
"specifiers <formatspec>`, but may not include more deeply nested replacement "
"fields. The :ref:`format specifier mini-language <formatspec>` is the same "
"as that used by the :meth:`str.format` method."
msgstr ""
"Os especificadores de formato de nível superior podem incluir campos de "
"substituição aninhados. Estes campos aninhados podem incluir os seus "
"próprios campos de conversão e :ref:`especificadores de formato "
"<formatspec>`, mas não podem incluir campos de substituição mais "
"profundamente aninhados. A :ref:`mini-linguagem de especificadores de "
"formato <formatspec>` é a mesma utilizada pelo método :meth:`str.format`."

msgid ""
"Formatted string literals may be concatenated, but replacement fields cannot "
"be split across literals."
msgstr ""

msgid "Some examples of formatted string literals::"
msgstr "Alguns exemplos de literais de string formatados::"

msgid ""
">>> name = \"Fred\"\n"
">>> f\"He said his name is {name!r}.\"\n"
"\"He said his name is 'Fred'.\"\n"
">>> f\"He said his name is {repr(name)}.\"  # repr() is equivalent to !r\n"
"\"He said his name is 'Fred'.\"\n"
">>> width = 10\n"
">>> precision = 4\n"
">>> value = decimal.Decimal(\"12.34567\")\n"
">>> f\"result: {value:{width}.{precision}}\"  # nested fields\n"
"'result:      12.35'\n"
">>> today = datetime(year=2017, month=1, day=27)\n"
">>> f\"{today:%B %d, %Y}\"  # using date format specifier\n"
"'January 27, 2017'\n"
">>> f\"{today=:%B %d, %Y}\" # using date format specifier and debugging\n"
"'today=January 27, 2017'\n"
">>> number = 1024\n"
">>> f\"{number:#0x}\"  # using integer format specifier\n"
"'0x400'\n"
">>> foo = \"bar\"\n"
">>> f\"{ foo = }\" # preserves whitespace\n"
"\" foo = 'bar'\"\n"
">>> line = \"The mill's closed\"\n"
">>> f\"{line = }\"\n"
"'line = \"The mill\\'s closed\"'\n"
">>> f\"{line = :20}\"\n"
"\"line = The mill's closed   \"\n"
">>> f\"{line = !r:20}\"\n"
"'line = \"The mill\\'s closed\" '"
msgstr ""
">>> nome = \"Fred\"\n"
">>> f\"Ele disse que o seu nome é {nome!r}.\"\n"
"\"Ele disse que o seu nome é 'Fred'.\"\n"
">>> f\"Ele disse que o seu nome é {repr(nome)}.\"  # repr() é equivalente a !"
"r\n"
"\"Ele disse que o seu nome é 'Fred'.\"\n"
">>> largura = 10\n"
">>> precisao = 4\n"
">>> valor = decimal.Decimal(\"12.34567\")\n"
">>> f\"resultado: {valor:{largura}.{precisao}}\"  # campos aninhados\n"
"'resultado:      12.35'\n"
">>> hoje = datetime(year=2017, month=1, day=27)\n"
">>> f\"{hoje:%B %d, %Y}\"  # usando especificador de formato de data\n"
"'27 de Janeiro, 2017'\n"
">>> f\"{hoje=:%B %d, %Y}\" # usando especificador de formato de data e "
"depuração\n"
"'hoje=27 de Janeiro, 2017'\n"
">>> numero = 1024\n"
">>> f\"{numero:#0x}\"  # usando especificador de formato de inteiro\n"
"'0x400'\n"
">>> foo = \"bar\"\n"
">>> f\"{ foo = }\" # preserva espaços em branco\n"
"\" foo = 'bar'\"\n"
">>> linha = \"The mill's closed\"\n"
">>> f\"{linha = }\"\n"
"'linha = \"The mill\\'s closed\"'\n"
">>> f\"{linha = :20}\"\n"
"\"linha = The mill's closed   \"\n"
">>> f\"{linha = !r:20}\"\n"
"'linha = \"The mill\\'s closed\" '"

msgid ""
"Reusing the outer f-string quoting type inside a replacement field is "
"permitted::"
msgstr ""
"Reutilizar o tipo de aspas da f-string externa dentro de um campo de "
"substituição é permitido::"

msgid ""
">>> a = dict(x=2)\n"
">>> f\"abc {a[\"x\"]} def\"\n"
"'abc 2 def'"
msgstr ""
">>> a = dict(x=2)\n"
">>> f\"abc {a[\"x\"]} def\"\n"
"'abc 2 def'"

msgid ""
"Prior to Python 3.12, reuse of the same quoting type of the outer f-string "
"inside a replacement field was not possible."
msgstr ""
"Antes do Python 3.12, a reutilização do mesmo tipo de aspas da f-string "
"externa dentro de um campo de substituição não era possível."

msgid ""
"Backslashes are also allowed in replacement fields and are evaluated the "
"same way as in any other context::"
msgstr ""
"As barras invertidas também são permitidas em campos de substituição e são "
"avaliadas da mesma forma que em qualquer outro contexto::"

msgid ""
">>> a = [\"a\", \"b\", \"c\"]\n"
">>> print(f\"List a contains:\\n{\"\\n\".join(a)}\")\n"
"List a contains:\n"
"a\n"
"b\n"
"c"
msgstr ""
">>> a = [\"a\", \"b\", \"c\"]\n"
">>> print(f\"A lista a contém:\\n{\"\\n\".join(a)}\")\n"
"Lista a contém:\n"
"a\n"
"b\n"
"c"

msgid ""
"Prior to Python 3.12, backslashes were not permitted inside an f-string "
"replacement field."
msgstr ""
"Antes do Python 3.12, as barras invertidas não eram permitidas dentro de um "
"campo de substituição de f-string."

msgid ""
"Formatted string literals cannot be used as docstrings, even if they do not "
"include expressions."
msgstr ""
"Os literais de string formatados não podem ser utilizados como docstrings, "
"mesmo que não incluam expressões."

msgid ""
">>> def foo():\n"
"...     f\"Not a docstring\"\n"
"...\n"
">>> foo.__doc__ is None\n"
"True"
msgstr ""
">>> def foo():\n"
"...     f\"Não é uma docstring\"\n"
"...\n"
">>> foo.__doc__ is None\n"
"True"

msgid ""
"See also :pep:`498` for the proposal that added formatted string literals, "
"and :meth:`str.format`, which uses a related format string mechanism."
msgstr ""
"Consulte também :pep:`498` para a proposta que adicionou literais de string "
"formatados, e :meth:`str.format`, que utiliza um mecanismo de string de "
"formato relacionado."

msgid "t-strings"
msgstr "t-strings"

msgid ""
"A :dfn:`template string literal` or :dfn:`t-string` is a string literal that "
"is prefixed with '``t``' or '``T``'. These strings follow the same syntax "
"and evaluation rules as :ref:`formatted string literals <f-strings>`, with "
"the following differences:"
msgstr ""
"Um :dfn:`literal de string de modelo` ou :dfn:`t-string` é um literal de "
"string prefixado com '``t``' ou '``T``'. Estas strings seguem a mesma "
"sintaxe e regras de avaliação que :ref:`literais de string formatados <f-"
"strings>`, com as seguintes diferenças:"

msgid ""
"Rather than evaluating to a ``str`` object, template string literals "
"evaluate to a :class:`string.templatelib.Template` object."
msgstr ""
"Em vez de avaliarem para um objeto ``str``, os literais de string de modelo "
"avaliam para um objeto :class:`string.templatelib.Template`."

msgid ""
"The :func:`format` protocol is not used. Instead, the format specifier and "
"conversions (if any) are passed to a new :class:`~string.templatelib."
"Interpolation` object that is created for each evaluated expression. It is "
"up to code that processes the resulting :class:`~string.templatelib."
"Template` object to decide how to handle format specifiers and conversions."
msgstr ""
"O protocolo :func:`format` não é utilizado. Em vez disso, o especificador de "
"formato e conversões (se houver) são passados para um novo objeto :class:"
"`~string.templatelib.Interpolation` que é criado para cada expressão "
"avaliada. Cabe ao código que processa o objeto :class:`~string.templatelib."
"Template` resultante decidir como lidar com especificadores de formato e "
"conversões."

msgid ""
"Format specifiers containing nested replacement fields are evaluated "
"eagerly, prior to being passed to the :class:`~string.templatelib."
"Interpolation` object. For instance, an interpolation of the form ``{amount:."
"{precision}f}`` will evaluate the inner expression ``{precision}`` to "
"determine the value of the ``format_spec`` attribute. If ``precision`` were "
"to be ``2``, the resulting format specifier would be ``'.2f'``."
msgstr ""
"Os especificadores de formato que contêm campos de substituição aninhados "
"são avaliados imediatamente, antes de serem passados para o objeto :class:"
"`~string.templatelib.Interpolation`. Por exemplo, uma interpolação da forma "
"``{amount:.{precision}f}`` avaliará a expressão interna ``{precision}`` para "
"determinar o valor do atributo ``format_spec``. Se ``precision`` for ``2``, "
"o especificador de formato resultante seria ``'.2f'``."

msgid ""
"When the equals sign ``'='`` is provided in an interpolation expression, the "
"text of the expression is appended to the literal string that precedes the "
"relevant interpolation. This includes the equals sign and any surrounding "
"whitespace. The :class:`!Interpolation` instance for the expression will be "
"created as normal, except that :attr:`~string.templatelib.Interpolation."
"conversion` will be set to '``r``' (:func:`repr`) by default. If an explicit "
"conversion or format specifier are provided, this will override the default "
"behaviour."
msgstr ""
"Quando o sinal de igual ``'='`` é fornecido numa expressão de interpolação, "
"o texto da expressão é anexado à string literal que precede a interpolação "
"relevante. Isto inclui o sinal de igual e qualquer espaço em branco "
"circundante. A instância :class:`!Interpolation` para a expressão será "
"criada normalmente, exceto que :attr:`~string.templatelib.Interpolation."
"conversion` será definido como '``r``' (:func:`repr`) por predefinição. Se "
"uma conversão explícita ou um especificador de formato forem fornecidos, "
"isto substituirá o comportamento predefinido."

msgid "Numeric literals"
msgstr "Literais numéricos"

msgid ""
":data:`~token.NUMBER` tokens represent numeric literals, of which there are "
"three types: integers, floating-point numbers, and imaginary numbers."
msgstr ""
"Os tokens :data:`~token.NUMBER` representam literais numéricos, dos quais "
"existem três tipos: inteiros, números de vírgula flutuante e números "
"imaginários."

msgid ""
"The numeric value of a numeric literal is the same as if it were passed as a "
"string to the :class:`int`, :class:`float` or :class:`complex` class "
"constructor, respectively. Note that not all valid inputs for those "
"constructors are also valid literals."
msgstr ""
"O valor numérico de um literal numérico é o mesmo que se fosse passado como "
"uma string para o construtor das classes :class:`int`, :class:`float` ou :"
"class:`complex`, respetivamente. Note que nem todas as entradas válidas para "
"esses construtores são também literais válidos."

msgid ""
"Numeric literals do not include a sign; a phrase like ``-1`` is actually an "
"expression composed of the unary operator '``-``' and the literal ``1``."
msgstr ""
"Os literais numéricos não incluem um sinal; uma frase como ``-1`` é na "
"verdade uma expressão composta pelo operador unário '``-``' e o literal "
"``1``."

msgid "Integer literals"
msgstr "Literais inteiros"

msgid "Integer literals denote whole numbers. For example::"
msgstr "Os literais inteiros denotam números inteiros. Por exemplo::"

msgid ""
"7\n"
"3\n"
"2147483647"
msgstr ""
"7\n"
"3\n"
"2147483647"

msgid ""
"There is no limit for the length of integer literals apart from what can be "
"stored in available memory::"
msgstr ""
"Não há limite para o comprimento dos literais inteiros, além do que pode ser "
"armazenado na memória disponível::"

msgid "7922816251426433759354395033679228162514264337593543950336"
msgstr "7922816251426433759354395033679228162514264337593543950336"

msgid ""
"Underscores can be used to group digits for enhanced readability, and are "
"ignored for determining the numeric value of the literal. For example, the "
"following literals are equivalent::"
msgstr ""
"Os sublinhados podem ser utilizados para agrupar dígitos para melhorar a "
"legibilidade e são ignorados para determinar o valor numérico do literal. "
"Por exemplo, os seguintes literais são equivalentes::"

msgid ""
"100_000_000_000\n"
"100000000000\n"
"1_00_00_00_00_000"
msgstr ""
"100_000_000_000\n"
"100000000000\n"
"1_00_00_00_00_000"

msgid ""
"Underscores can only occur between digits. For example, ``_123``, ``321_``, "
"and ``123__321`` are *not* valid literals."
msgstr ""
"Os sublinhados só podem ocorrer entre dígitos. Por exemplo, ``_123``, "
"``321_`` e ``123__321`` *não* são literais válidos."

msgid ""
"Integers can be specified in binary (base 2), octal (base 8), or hexadecimal "
"(base 16) using the prefixes ``0b``, ``0o`` and ``0x``, respectively. "
"Hexadecimal digits 10 through 15 are represented by letters ``A``-``F``, "
"case-insensitive.  For example::"
msgstr ""
"Os inteiros podem ser especificados em binário (base 2), octal (base 8) ou "
"hexadecimal (base 16) utilizando os prefixos ``0b``, ``0o`` e ``0x``, "
"respetivamente. Os dígitos hexadecimais de 10 a 15 são representados pelas "
"letras ``A``-``F``, sem distinção de maiúsculas/minúsculas. Por exemplo::"

msgid ""
"0b100110111\n"
"0b_1110_0101\n"
"0o177\n"
"0o377\n"
"0xdeadbeef\n"
"0xDead_Beef"
msgstr ""
"0b100110111\n"
"0b_1110_0101\n"
"0o177\n"
"0o377\n"
"0xdeadbeef\n"
"0xDead_Beef"

msgid ""
"An underscore can follow the base specifier. For example, ``0x_1f`` is a "
"valid literal, but ``0_x1f`` and ``0x__1f`` are not."
msgstr ""
"Um sublinhado pode seguir o especificador de base. Por exemplo, ``0x_1f`` é "
"um literal válido, mas ``0_x1f`` e ``0x__1f`` não são."

msgid ""
"Leading zeros in a non-zero decimal number are not allowed. For example, "
"``0123`` is not a valid literal. This is for disambiguation with C-style "
"octal literals, which Python used before version 3.0."
msgstr ""
"Zeros à esquerda em números decimais não nulos não são permitidos. Por "
"exemplo, ``0123`` não é um literal válido. Isto serve para desambiguação com "
"literais octais no estilo C, que o Python utilizava antes da versão 3.0."

msgid ""
"Formally, integer literals are described by the following lexical "
"definitions:"
msgstr ""
"Formalmente, os literais inteiros são descritos pelas seguintes definições "
"léxicas:"

msgid "Underscores are now allowed for grouping purposes in literals."
msgstr ""
"Os sublinhados são agora permitidos para fins de agrupamento em literais."

msgid "Floating-point literals"
msgstr "Literais de vírgula flutuante"

msgid ""
"Floating-point (float) literals, such as ``3.14`` or ``1.5``, denote :ref:"
"`approximations of real numbers <datamodel-float>`."
msgstr ""
"Os literais de vírgula flutuante (float), como ``3.14`` ou ``1.5``, denotam :"
"ref:`aproximações de números reais <datamodel-float>`."

msgid ""
"They consist of *integer* and *fraction* parts, each composed of decimal "
"digits. The parts are separated by a decimal point, ``.``::"
msgstr ""
"Eles consistem em partes *inteiras* e *fracionárias*, cada uma composta por "
"dígitos decimais. As partes são separadas por um ponto decimal, ``.``::"

msgid ""
"2.71828\n"
"4.0"
msgstr ""
"2.71828\n"
"4.0"

msgid ""
"Unlike in integer literals, leading zeros are allowed. For example, "
"``077.010`` is legal, and denotes the same number as ``77.01``."
msgstr ""
"Ao contrário dos literais inteiros, zeros à esquerda são permitidos. Por "
"exemplo, ``077.010`` é legal e denota o mesmo número que ``77.01``."

msgid ""
"As in integer literals, single underscores may occur between digits to help "
"readability::"
msgstr ""
"Como nos literais inteiros, sublinhados únicos podem ocorrer entre dígitos "
"para ajudar na legibilidade::"

msgid ""
"96_485.332_123\n"
"3.14_15_93"
msgstr ""
"96_485.332_123\n"
"3.14_15_93"

msgid "Either of these parts, but not both, can be empty. For example::"
msgstr ""
"Qualquer uma destas partes, mas não ambas, pode estar vazia. Por exemplo::"

msgid ""
"10.  # (equivalent to 10.0)\n"
".001  # (equivalent to 0.001)"
msgstr ""
"10.  # (equivalente a 10.0)\n"
".001  # (equivalente a 0.001)"

msgid ""
"Optionally, the integer and fraction may be followed by an *exponent*: the "
"letter ``e`` or ``E``, followed by an optional sign, ``+`` or ``-``, and a "
"number in the same format as the integer and fraction parts. The ``e`` or "
"``E`` represents \"times ten raised to the power of\"::"
msgstr ""
"Opcionalmente, a parte inteira e fracionária podem ser seguidas por um "
"*expoente*: a letra ``e`` ou ``E``, seguida por um sinal opcional, ``+`` ou "
"``-``, e um número no mesmo formato que as partes inteira e fracionária. O "
"``e`` ou ``E`` representa \"vezes dez elevado à potência de\"::"

msgid ""
"1.0e3  # (represents 1.0×10³, or 1000.0)\n"
"1.166e-5  # (represents 1.166×10⁻⁵, or 0.00001166)\n"
"6.02214076e+23  # (represents 6.02214076×10²³, or 602214076000000000000000.)"
msgstr ""

msgid ""
"In floats with only integer and exponent parts, the decimal point may be "
"omitted::"
msgstr ""
"Em floats com apenas partes inteiras e expoentes, o ponto decimal pode ser "
"omitido::"

msgid ""
"1e3  # (equivalent to 1.e3 and 1.0e3)\n"
"0e0  # (equivalent to 0.)"
msgstr ""
"1e3  # (equivalente a 1.e3 e 1.0e3)\n"
"0e0  # (equivalente a 0.)"

msgid ""
"Formally, floating-point literals are described by the following lexical "
"definitions:"
msgstr ""
"Formalmente, os literais de vírgula flutuante são descritos pelas seguintes "
"definições léxicas:"

msgid "Imaginary literals"
msgstr "Literais imaginários"

msgid ""
"Python has :ref:`complex number <typesnumeric>` objects, but no complex "
"literals. Instead, *imaginary literals* denote complex numbers with a zero "
"real part."
msgstr ""
"O Python tem objetos de :ref:`números complexos <typesnumeric>`, mas não tem "
"literais complexos. Em vez disso, os *literais imaginários* denotam números "
"complexos com uma parte real zero."

msgid ""
"For example, in math, the complex number 3+4.2\\ *i* is written as the real "
"number 3 added to the imaginary number 4.2\\ *i*. Python uses a similar "
"syntax, except the imaginary unit is written as ``j`` rather than *i*::"
msgstr ""
"Por exemplo, em matemática, o número complexo 3+4.2\\ *i* é escrito como o "
"número real 3 adicionado ao número imaginário 4.2\\ *i*. O Python utiliza "
"uma sintaxe semelhante, exceto que a unidade imaginária é escrita como ``j`` "
"em vez de *i*::"

msgid "3+4.2j"
msgstr "3+4.2j"

msgid ""
"This is an expression composed of the :ref:`integer literal <integers>` "
"``3``, the :ref:`operator <operators>` '``+``', and the :ref:`imaginary "
"literal <imaginary>` ``4.2j``. Since these are three separate tokens, "
"whitespace is allowed between them::"
msgstr ""
"Esta é uma expressão composta pelo :ref:`literal inteiro <integers>` ``3``, "
"o :ref:`operador <operators>` '``+``', e o :ref:`literal imaginário "
"<imaginary>` ``4.2j``. Uma vez que estes são três tokens separados, o espaço "
"em branco é permitido entre eles::"

msgid "3 + 4.2j"
msgstr "3 + 4.2j"

msgid ""
"No whitespace is allowed *within* each token. In particular, the ``j`` "
"suffix, may not be separated from the number before it."
msgstr ""
"Nenhum espaço em branco é permitido *dentro* de cada token. Em particular, o "
"sufixo ``j`` não pode ser separado do número que o precede."

msgid ""
"The number before the ``j`` has the same syntax as a floating-point literal. "
"Thus, the following are valid imaginary literals::"
msgstr ""
"O número antes do ``j`` tem a mesma sintaxe que um literal de vírgula "
"flutuante. Assim, os seguintes são literais imaginários válidos::"

msgid ""
"4.2j\n"
"3.14j\n"
"10.j\n"
".001j\n"
"1e100j\n"
"3.14e-10j\n"
"3.14_15_93j"
msgstr ""
"4.2j\n"
"3.14j\n"
"10.j\n"
".001j\n"
"1e100j\n"
"3.14e-10j\n"
"3.14_15_93j"

msgid ""
"Unlike in a floating-point literal the decimal point can be omitted if the "
"imaginary number only has an integer part. The number is still evaluated as "
"a floating-point number, not an integer::"
msgstr ""
"Ao contrário de um literal de vírgula flutuante, o ponto decimal pode ser "
"omitido se o número imaginário tiver apenas uma parte inteira. O número "
"ainda é avaliado como um número de vírgula flutuante, não como um inteiro::"

msgid ""
"10j\n"
"0j\n"
"1000000000000000000000000j   # equivalent to 1e+24j"
msgstr ""
"10j\n"
"0j\n"
"1000000000000000000000000j   # equivalente a 1e+24j"

msgid ""
"The ``j`` suffix is case-insensitive. That means you can use ``J`` instead::"
msgstr ""
"O sufixo ``j`` não é sensível a maiúsculas/minúsculas. Isso significa que "
"pode utilizar ``J`` em vez disso::"

msgid "3.14J   # equivalent to 3.14j"
msgstr "3.14J   # equivalente a 3.14j"

msgid ""
"Formally, imaginary literals are described by the following lexical "
"definition:"
msgstr ""
"Formalmente, os literais imaginários são descritos pela seguinte definição "
"léxica:"

msgid "Operators and delimiters"
msgstr "Operadores e delimitadores"

msgid ""
"The following grammar defines :dfn:`operator` and :dfn:`delimiter` tokens, "
"that is, the generic :data:`~token.OP` token type. A :ref:`list of these "
"tokens and their names <token_operators_delimiters>` is also available in "
"the :mod:`!token` module documentation."
msgstr ""
"A seguinte gramática define os tokens :dfn:`operador` e :dfn:`delimitador`, "
"ou seja, o tipo de token genérico :data:`~token.OP`. Uma :ref:`lista destes "
"tokens e seus nomes <token_operators_delimiters>` também está disponível na "
"documentação do módulo :mod:`!token`."

msgid ""
"Generally, *operators* are used to combine :ref:`expressions <expressions>`, "
"while *delimiters* serve other purposes. However, there is no clear, formal "
"distinction between the two categories."
msgstr ""
"Geralmente, os *operadores* são usados para combinar :ref:`expressões "
"<expressions>`, enquanto os *delimitadores* servem outros propósitos. No "
"entanto, não existe uma distinção clara e formal entre as duas categorias."

msgid ""
"Some tokens can serve as either operators or delimiters, depending on usage. "
"For example, ``*`` is both the multiplication operator and a delimiter used "
"for sequence unpacking, and ``@`` is both the matrix multiplication and a "
"delimiter that introduces decorators."
msgstr ""
"Alguns tokens podem servir como operadores ou delimitadores, dependendo do "
"uso. Por exemplo, ``*`` é tanto o operador de multiplicação como um "
"delimitador usado para desempacotamento de sequências, e ``@`` é tanto a "
"multiplicação de matrizes como um delimitador que introduz decoradores."

msgid ""
"For some tokens, the distinction is unclear. For example, some people "
"consider ``.``, ``(``, and ``)`` to be delimiters, while others see the :py:"
"func:`getattr` operator and the function call operator(s)."
msgstr ""
"Para alguns tokens, a distinção não é clara. Por exemplo, algumas pessoas "
"consideram ``.``, ``(`` e ``)`` como delimitadores, enquanto outras veem o "
"operador :py:func:`getattr` e o(s) operador(es) de chamada de função."

msgid ""
"Some of Python's operators, like ``and``, ``or``, and ``not in``, use :ref:"
"`keyword <keywords>` tokens rather than \"symbols\" (operator tokens)."
msgstr ""
"Alguns dos operadores do Python, como ``and``, ``or`` e ``not in``, usam "
"tokens de :ref:`palavras-chave <keywords>` em vez de \"símbolos\" (tokens de "
"operadores)."

msgid ""
"A sequence of three consecutive periods (``...``) has a special meaning as "
"an :py:data:`Ellipsis` literal."
msgstr ""

msgid "lexical analysis"
msgstr "análise léxica"

msgid "parser"
msgstr "analisador sintático"

msgid "token"
msgstr "*token*"

msgid "line structure"
msgstr "estrutura de linha"

msgid "logical line"
msgstr "linha lógica"

msgid "physical line"
msgstr "linha física"

msgid "line joining"
msgstr "junção de linha"

msgid "NEWLINE token"
msgstr "token NEWLINE"

msgid "comment"
msgstr "comentário"

msgid "hash character"
msgstr "caractere cerquilha"

msgid "# (hash)"
msgstr "# (cerquilha)"

msgid "source character set"
msgstr "conjunto de caracteres de origem"

msgid "encoding declarations (source file)"
msgstr "declarações de codificação (ficheiro de origem)"

msgid "source encoding declaration"
msgstr "declaração de codificação de origem"

msgid "line continuation"
msgstr "continuação de linha"

msgid "backslash character"
msgstr "caractere de barra invertida"

msgid "blank line"
msgstr "linha em branco"

msgid "indentation"
msgstr "indentação"

msgid "leading whitespace"
msgstr "espaço em branco inicial"

msgid "grouping"
msgstr "agrupamento"

msgid "statement grouping"
msgstr "agrupamento de instruções"

msgid "INDENT token"
msgstr "token INDENT"

msgid "DEDENT token"
msgstr "token DEDENT"

msgid "identifier"
msgstr "identificador"

msgid "name"
msgstr "nome"

msgid "keyword"
msgstr "palavra-chave"

msgid "reserved word"
msgstr "palavra reservada"

msgid "soft keyword"
msgstr "palavra-chave suave"

msgid "_, identifiers"
msgstr "_, identificadores"

msgid "__, identifiers"
msgstr "__, identificadores"

msgid "literal"
msgstr "literal"

msgid "constant"
msgstr "constante"

msgid "string literal"
msgstr "literal de string"

msgid "bytes literal"
msgstr "literal de bytes"

msgid "ASCII"
msgstr "ASCII"

msgid "' (single quote)"
msgstr "' (aspa simples)"

msgid "\" (double quote)"
msgstr "\" (aspa dupla)"

msgid "triple-quoted string"
msgstr "string com triplas aspas"

msgid "\"\"\""
msgstr "\"\"\""

msgid "'''"
msgstr "'''"

msgid "u'"
msgstr "u'"

msgid "u\""
msgstr "u\""

msgid "escape sequence"
msgstr "sequência de escape"

msgid "Standard C"
msgstr "C padrão"

msgid "C"
msgstr "C"

msgid "\\ (backslash)"
msgstr "\\ (barra invertida)"

msgid "\\\\"
msgstr "\\\\"

msgid "\\a"
msgstr "\\a"

msgid "\\b"
msgstr "\\b"

msgid "\\f"
msgstr "\\f"

msgid "\\n"
msgstr "\\n"

msgid "\\r"
msgstr "\\r"

msgid "\\t"
msgstr "\\t"

msgid "\\v"
msgstr "\\v"

msgid "\\x"
msgstr "\\x"

msgid "\\u"
msgstr "\\u"

msgid "\\U"
msgstr "\\U"

msgid "unrecognized escape sequence"
msgstr "sequência de escape não reconhecida"

msgid "b'"
msgstr "b'"

msgid "b\""
msgstr "b\""

msgid "r'"
msgstr "r'"

msgid "raw string literal"
msgstr "literal de string bruta"

msgid "r\""
msgstr "r\""

msgid "formatted string literal"
msgstr "literal de string formatada"

msgid "interpolated string literal"
msgstr "literal de string interpolada"

msgid "string"
msgstr "string"

msgid "formatted literal"
msgstr "literal formatada"

msgid "interpolated literal"
msgstr "literal interpolada"

msgid "f-string"
msgstr "f-string"

msgid "fstring"
msgstr "f-string"

msgid "f'"
msgstr "f'"

msgid "f\""
msgstr "f\""

msgid "{} (curly brackets)"
msgstr "{} (chavetas)"

msgid "in formatted string literal"
msgstr "em literal de string formatada"

msgid "! (exclamation)"
msgstr "! (ponto de exclamação)"

msgid ": (colon)"
msgstr ": (dois pontos)"

msgid "= (equals)"
msgstr "= (igual)"

msgid "for help in debugging using string literals"
msgstr "para ajuda na depuração usando literais de string"

msgid "number"
msgstr "número"

msgid "numeric literal"
msgstr "literal numérico"

msgid "integer literal"
msgstr "literal inteiro"

msgid "floating-point literal"
msgstr "literal de vírgula flutuante"

msgid "hexadecimal literal"
msgstr "literal hexadecimal"

msgid "octal literal"
msgstr "literal octal"

msgid "binary literal"
msgstr "literal binário"

msgid "decimal literal"
msgstr "literal decimal"

msgid "imaginary literal"
msgstr "literal imaginário"

msgid "complex literal"
msgstr "literal complexo"

msgid "0b"
msgstr "0b"

msgid "0o"
msgstr "0o"

msgid "0x"
msgstr "0x"

msgid "_ (underscore)"
msgstr "_ (sublinhado)"

msgid "in numeric literal"
msgstr "em literal numérico"

msgid ". (dot)"
msgstr ". (ponto)"

msgid "e"
msgstr "e"

msgid "j"
msgstr "j"

msgid "operators"
msgstr "operadores"

msgid "delimiters"
msgstr "delimitadores"
