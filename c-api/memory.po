# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# NyaPuma <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-25 14:15+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: NyaPuma <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

msgid "Memory Management"
msgstr "Gestão de Memória"

msgid "Overview"
msgstr "Visão Geral"

msgid ""
"Memory management in Python involves a private heap containing all Python "
"objects and data structures. The management of this private heap is ensured "
"internally by the *Python memory manager*.  The Python memory manager has "
"different components which deal with various dynamic storage management "
"aspects, like sharing, segmentation, preallocation or caching."
msgstr ""
"A gestão de memória em Python envolve um *heap* privado que contém todos os "
"objetos e estruturas de dados Python. A gestão deste *heap* privado é "
"garantida internamente pelo *gestor de memória do Python*. O gestor de "
"memória do Python tem diferentes componentes que lidam com vários aspetos da "
"gestão dinâmica de armazenamento, como partilha, segmentação, pré-alocação "
"ou cache."

msgid ""
"At the lowest level, a raw memory allocator ensures that there is enough "
"room in the private heap for storing all Python-related data by interacting "
"with the memory manager of the operating system. On top of the raw memory "
"allocator, several object-specific allocators operate on the same heap and "
"implement distinct memory management policies adapted to the peculiarities "
"of every object type. For example, integer objects are managed differently "
"within the heap than strings, tuples or dictionaries because integers imply "
"different storage requirements and speed/space tradeoffs. The Python memory "
"manager thus delegates some of the work to the object-specific allocators, "
"but ensures that the latter operate within the bounds of the private heap."
msgstr ""
"Ao nível mais baixo, um alocador de memória bruta garante que existe espaço "
"suficiente no *heap* privado para armazenar todos os dados relacionados com "
"Python, interagindo com o gestor de memória do sistema operativo. Por cima "
"do alocador de memória bruta, vários alocadores específicos de objetos "
"operam no mesmo *heap* e implementam políticas distintas de gestão de "
"memória, adaptadas às particularidades de cada tipo de objeto. Por exemplo, "
"os objetos inteiros são geridos de forma diferente no *heap* em relação a "
"cadeias de caracteres, tuplos ou dicionários, porque os inteiros implicam "
"requisitos de armazenamento e compromissos de velocidade/espaço distintos. O "
"gestor de memória do Python delega, assim, parte do trabalho aos alocadores "
"específicos de objetos, mas garante que estes operam dentro dos limites do "
"*heap* privado."

msgid ""
"It is important to understand that the management of the Python heap is "
"performed by the interpreter itself and that the user has no control over "
"it, even if they regularly manipulate object pointers to memory blocks "
"inside that heap.  The allocation of heap space for Python objects and other "
"internal buffers is performed on demand by the Python memory manager through "
"the Python/C API functions listed in this document."
msgstr ""
"É importante compreender que a gestão do *heap* do Python é realizada pelo "
"próprio intérprete e que o utilizador não tem controlo sobre ela, mesmo que "
"manipule regularmente ponteiros de objetos para blocos de memória dentro "
"desse *heap*. A alocação de espaço no *heap* para objetos Python e outros "
"buffers internos é realizada sob pedido pelo gestor de memória do Python, "
"através das funções da API C/Python listadas neste documento."

msgid ""
"To avoid memory corruption, extension writers should never try to operate on "
"Python objects with the functions exported by the C library: :c:func:"
"`malloc`, :c:func:`calloc`, :c:func:`realloc` and :c:func:`free`.  This will "
"result in  mixed calls between the C allocator and the Python memory manager "
"with fatal consequences, because they implement different algorithms and "
"operate on different heaps.  However, one may safely allocate and release "
"memory blocks with the C library allocator for individual purposes, as shown "
"in the following example::"
msgstr ""
"Para evitar corrupção de memória, os programadores de extensões nunca devem "
"tentar operar em objetos Python com as funções exportadas pela biblioteca "
"C: :c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` e :c:func:`free`. "
"Isto resultará em chamadas misturadas entre o alocador C e o gestor de "
"memória do Python, com consequências fatais, porque implementam algoritmos "
"diferentes e operam em *heaps* distintos. No entanto, pode-se alocar e "
"libertar blocos de memória com o alocador da biblioteca C para fins "
"individuais, como mostrado no exemplo seguinte::"

msgid ""
"PyObject *res;\n"
"char *buf = (char *) malloc(BUFSIZ); /* for I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"...Do some I/O operation involving buf...\n"
"res = PyBytes_FromString(buf);\n"
"free(buf); /* malloc'ed */\n"
"return res;"
msgstr ""
"PyObject *res;\n"
"char *buf = (char *) malloc(BUFSIZ); /* para I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"...Efetuar alguma operação de I/O envolvendo buf...\n"
"res = PyBytes_FromString(buf);\n"
"free(buf); /* alocado com malloc */\n"
"return res;"

msgid ""
"In this example, the memory request for the I/O buffer is handled by the C "
"library allocator. The Python memory manager is involved only in the "
"allocation of the bytes object returned as a result."
msgstr ""
"Neste exemplo, o pedido de memória para o buffer de I/O é tratado pelo "
"alocador da biblioteca C. O gestor de memória do Python está envolvido "
"apenas na alocação do objeto bytes retornado como resultado."

msgid ""
"In most situations, however, it is recommended to allocate memory from the "
"Python heap specifically because the latter is under control of the Python "
"memory manager. For example, this is required when the interpreter is "
"extended with new object types written in C. Another reason for using the "
"Python heap is the desire to *inform* the Python memory manager about the "
"memory needs of the extension module. Even when the requested memory is used "
"exclusively for internal, highly specific purposes, delegating all memory "
"requests to the Python memory manager causes the interpreter to have a more "
"accurate image of its memory footprint as a whole. Consequently, under "
"certain circumstances, the Python memory manager may or may not trigger "
"appropriate actions, like garbage collection, memory compaction or other "
"preventive procedures. Note that by using the C library allocator as shown "
"in the previous example, the allocated memory for the I/O buffer escapes "
"completely the Python memory manager."
msgstr ""
"Na maioria das situações, no entanto, é recomendado alocar memória a partir "
"do *heap* do Python, especificamente porque este está sob controlo do gestor "
"de memória do Python. Por exemplo, isto é necessário quando o intérprete é "
"estendido com novos tipos de objetos escritos em C. Outra razão para usar o "
"*heap* do Python é o desejo de *informar* o gestor de memória do Python "
"sobre as necessidades de memória do módulo de extensão. Mesmo quando a "
"memória solicitada é usada exclusivamente para fins internos e altamente "
"específicos, delegar todos os pedidos de memória ao gestor de memória do "
"Python faz com que o intérprete tenha uma imagem mais precisa da sua pegada "
"de memória como um todo. Consequentemente, em certas circunstâncias, o "
"gestor de memória do Python pode ou não desencadear ações apropriadas, como "
"recolha de lixo, compactação de memória ou outros procedimentos preventivos. "
"Note que, ao usar o alocador da biblioteca C, como mostrado no exemplo "
"anterior, a memória alocada para o buffer de I/O escapa completamente ao "
"gestor de memória do Python."

msgid ""
"The :envvar:`PYTHONMALLOC` environment variable can be used to configure the "
"memory allocators used by Python."
msgstr ""
"A variável de ambiente :envvar:`PYTHONMALLOC` pode ser usada para configurar "
"os alocadores de memória usados pelo Python."

msgid ""
"The :envvar:`PYTHONMALLOCSTATS` environment variable can be used to print "
"statistics of the :ref:`pymalloc memory allocator <pymalloc>` every time a "
"new pymalloc object arena is created, and on shutdown."
msgstr ""
"A variável de ambiente :envvar:`PYTHONMALLOCSTATS` pode ser usada para "
"imprimir estatísticas do alocador de memória :ref:`pymalloc <pymalloc>` "
"sempre que uma nova arena de objetos pymalloc é criada e no encerramento."

msgid "Allocator Domains"
msgstr "Domínios de Alocação"

msgid ""
"All allocating functions belong to one of three different \"domains\" (see "
"also :c:type:`PyMemAllocatorDomain`). These domains represent different "
"allocation strategies and are optimized for different purposes. The specific "
"details on how every domain allocates memory or what internal functions each "
"domain calls is considered an implementation detail, but for debugging "
"purposes a simplified table can be found at :ref:`default-memory-"
"allocators`. The APIs used to allocate and free a block of memory must be "
"from the same domain. For example, :c:func:`PyMem_Free` must be used to free "
"memory allocated using :c:func:`PyMem_Malloc`."
msgstr ""

msgid "The three allocation domains are:"
msgstr "Os três domínios de alocação são:"

msgid ""
"Raw domain: intended for allocating memory for general-purpose memory "
"buffers where the allocation *must* go to the system allocator or where the "
"allocator can operate without an :term:`attached thread state`. The memory "
"is requested directly from the system. See :ref:`Raw Memory Interface <raw-"
"memoryinterface>`."
msgstr ""
"Domínio Raw: destinado à alocação de memória para buffers de memória de uso "
"geral, onde a alocação *deve* ser feita pelo alocador do sistema ou onde o "
"alocador pode operar sem um :term:`estado de thread associado`. A memória é "
"solicitada diretamente ao sistema. Veja :ref:`Interface de Memória Raw <raw-"
"memoryinterface>`."

msgid ""
"\"Mem\" domain: intended for allocating memory for Python buffers and "
"general-purpose memory buffers where the allocation must be performed with "
"an :term:`attached thread state`. The memory is taken from the Python "
"private heap. See :ref:`Memory Interface <memoryinterface>`."
msgstr ""
"Domínio \"Mem\": destinado à alocação de memória para buffers Python e "
"buffers de memória de uso geral, onde a alocação deve ser realizada com um :"
"term:`estado de thread associado`. A memória é obtida do *heap* privado do "
"Python. Veja :ref:`Interface de Memória <memoryinterface>`."

msgid ""
"Object domain: intended for allocating memory for Python objects. The memory "
"is taken from the Python private heap. See :ref:`Object allocators "
"<objectinterface>`."
msgstr ""
"Domínio de Objetos: destinado à alocação de memória para objetos Python. A "
"memória é obtida do *heap* privado do Python. Veja :ref:`Alocadores de "
"Objetos <objectinterface>`."

msgid ""
"The :term:`free-threaded <free threading>` build requires that only Python "
"objects are allocated using the \"object\" domain and that all Python "
"objects are allocated using that domain. This differs from the prior Python "
"versions, where this was only a best practice and not a hard requirement."
msgstr ""
"A compilação :term:`free-threaded <free threading>` exige que apenas objetos "
"Python sejam alocados usando o domínio \"objeto\" e que todos os objetos "
"Python sejam alocados usando esse domínio. Isto difere das versões "
"anteriores do Python, onde isto era apenas uma boa prática e não um "
"requisito obrigatório."

msgid ""
"For example, buffers (non-Python objects) should be allocated using :c:func:"
"`PyMem_Malloc`, :c:func:`PyMem_RawMalloc`, or :c:func:`malloc`, but not :c:"
"func:`PyObject_Malloc`."
msgstr ""
"Por exemplo, buffers (objetos não-Python) devem ser alocados usando :c:func:"
"`PyMem_Malloc`, :c:func:`PyMem_RawMalloc`, ou :c:func:`malloc`, mas não :c:"
"func:`PyObject_Malloc`."

msgid "See :ref:`Memory Allocation APIs <free-threaded-memory-allocation>`."
msgstr ""
"Veja :ref:`APIs de Alocação de Memória <free-threaded-memory-allocation>`...."

msgid "Raw Memory Interface"
msgstr "Interface de Memória Raw"

msgid ""
"The following function sets are wrappers to the system allocator. These "
"functions are thread-safe, so a :term:`thread state` does not need to be :"
"term:`attached <attached thread state>`."
msgstr ""
"Os seguintes conjuntos de funções são *wrappers* para o alocador do sistema. "
"Estas funções são *thread-safe*, pelo que não é necessário que um :term:"
"`estado de thread` esteja :term:`associado <attached thread state>`."

msgid ""
"The :ref:`default raw memory allocator <default-memory-allocators>` uses the "
"following functions: :c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` "
"and :c:func:`!free`; call ``malloc(1)`` (or ``calloc(1, 1)``) when "
"requesting zero bytes."
msgstr ""
"O :ref:`alocador de memória raw predefinido <default-memory-allocators>` usa "
"as seguintes funções: :c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` "
"e :c:func:`!free`; chamar ``malloc(1)`` (ou ``calloc(1, 1)``) ao solicitar "
"zero bytes."

msgid ""
"Allocates *n* bytes and returns a pointer of type :c:expr:`void*` to the "
"allocated memory, or ``NULL`` if the request fails."
msgstr ""
"Aloca *n* bytes e retorna um ponteiro do tipo :c:expr:`void*` para a memória "
"alocada, ou ``NULL`` se o pedido falhar."

msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyMem_RawMalloc(1)`` had been called instead. The memory will not "
"have been initialized in any way."
msgstr ""
"Solicitar zero bytes retorna um ponteiro não-``NULL`` distinto, se possível, "
"como se ``PyMem_RawMalloc(1)`` tivesse sido chamado. A memória não será "
"inicializada de nenhuma forma."

msgid ""
"Allocates *nelem* elements each whose size in bytes is *elsize* and returns "
"a pointer of type :c:expr:`void*` to the allocated memory, or ``NULL`` if "
"the request fails. The memory is initialized to zeros."
msgstr ""
"Aloca *nelem* elementos, cada um com tamanho em bytes de *elsize*, e retorna "
"um ponteiro do tipo :c:expr:`void*` para a memória alocada, ou ``NULL`` se o "
"pedido falhar. A memória é inicializada a zeros."

msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyMem_RawCalloc(1, 1)`` had been "
"called instead."
msgstr ""
"Solicitar zero elementos ou elementos com tamanho de zero bytes retorna um "
"ponteiro não-``NULL`` distinto, se possível, como se ``PyMem_RawCalloc(1, "
"1)`` tivesse sido chamado."

msgid ""
"Resizes the memory block pointed to by *p* to *n* bytes. The contents will "
"be unchanged to the minimum of the old and the new sizes."
msgstr ""
"Redimensiona o bloco de memória apontado por *p* para *n* bytes. O conteúdo "
"será inalterado até ao mínimo dos tamanhos antigo e novo."

msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyMem_RawMalloc(n)``; else "
"if *n* is equal to zero, the memory block is resized but is not freed, and "
"the returned pointer is non-``NULL``."
msgstr ""
"Se *p* for ``NULL``, a chamada é equivalente a ``PyMem_RawMalloc(n)``; caso "
"contrário, se *n* for igual a zero, o bloco de memória é redimensionado, mas "
"não libertado, e o ponteiro retornado é não-``NULL``."

msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to :c:"
"func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` or :c:func:"
"`PyMem_RawCalloc`."
msgstr ""
"A menos que *p* seja ``NULL``, deve ter sido retornado por uma chamada "
"anterior a :c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` ou :c:func:"
"`PyMem_RawCalloc`."

msgid ""
"If the request fails, :c:func:`PyMem_RawRealloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Se o pedido falhar, :c:func:`PyMem_RawRealloc` retorna ``NULL`` e *p* "
"permanece um ponteiro válido para a área de memória anterior."

msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a "
"previous call to :c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` or :c:"
"func:`PyMem_RawCalloc`.  Otherwise, or if ``PyMem_RawFree(p)`` has been "
"called before, undefined behavior occurs."
msgstr ""
"Liberta o bloco de memória apontado por *p*, que deve ter sido retornado por "
"uma chamada anterior a :c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` "
"ou :c:func:`PyMem_RawCalloc`. Caso contrário, ou se ``PyMem_RawFree(p)`` "
"tiver sido chamado anteriormente, ocorre comportamento indefinido."

msgid "If *p* is ``NULL``, no operation is performed."
msgstr "Se *p* for ``NULL``, nenhuma operação é realizada."

msgid "Memory Interface"
msgstr "Interface de Memória"

msgid ""
"The following function sets, modeled after the ANSI C standard, but "
"specifying behavior when requesting zero bytes, are available for allocating "
"and releasing memory from the Python heap."
msgstr ""
"Os seguintes conjuntos de funções, modelados segundo o padrão ANSI C, mas "
"especificando o comportamento ao solicitar zero bytes, estão disponíveis "
"para alocar e libertar memória do *heap* do Python."

msgid ""
"The :ref:`default memory allocator <default-memory-allocators>` uses the :"
"ref:`pymalloc memory allocator <pymalloc>`."
msgstr ""
"O :ref:`alocador de memória predefinido <default-memory-allocators>` usa o :"
"ref:`alocador de memória pymalloc <pymalloc>`."

msgid ""
"There must be an :term:`attached thread state` when using these functions."
msgstr ""
"Deve existir um :term:`estado de thread associado` ao usar estas funções."

msgid ""
"The default allocator is now pymalloc instead of system :c:func:`malloc`."
msgstr ""
"O alocador predefinido é agora o pymalloc em vez do :c:func:`malloc` do "
"sistema."

msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyMem_Malloc(1)`` had been called instead. The memory will not have "
"been initialized in any way."
msgstr ""
"Solicitar zero bytes retorna um ponteiro não-``NULL`` distinto, se possível, "
"como se ``PyMem_Malloc(1)`` tivesse sido chamado. A memória não será "
"inicializada de nenhuma forma."

msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyMem_Calloc(1, 1)`` had been "
"called instead."
msgstr ""
"Solicitar zero elementos ou elementos com tamanho de zero bytes retorna um "
"ponteiro não-``NULL`` distinto, se possível, como se ``PyMem_Calloc(1, 1)`` "
"tivesse sido chamado."

msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyMem_Malloc(n)``; else if "
"*n* is equal to zero, the memory block is resized but is not freed, and the "
"returned pointer is non-``NULL``."
msgstr ""
"Se *p* for ``NULL``, a chamada é equivalente a ``PyMem_Malloc(n)``; caso "
"contrário, se *n* for igual a zero, o bloco de memória é redimensionado, mas "
"não libertado, e o ponteiro retornado é não-``NULL``."

msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to :c:"
"func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` or :c:func:`PyMem_Calloc`."
msgstr ""
"A menos que *p* seja ``NULL``, deve ter sido retornado por uma chamada "
"anterior a :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` ou :c:func:"
"`PyMem_Calloc`."

msgid ""
"If the request fails, :c:func:`PyMem_Realloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Se o pedido falhar, :c:func:`PyMem_Realloc` retorna ``NULL`` e *p* permanece "
"um ponteiro válido para a área de memória anterior."

msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a "
"previous call to :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` or :c:func:"
"`PyMem_Calloc`.  Otherwise, or if ``PyMem_Free(p)`` has been called before, "
"undefined behavior occurs."
msgstr ""
"Liberta o bloco de memória apontado por *p*, que deve ter sido retornado por "
"uma chamada anterior a :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` ou :c:"
"func:`PyMem_Calloc`. Caso contrário, ou se ``PyMem_Free(p)`` tiver sido "
"chamado anteriormente, ocorre comportamento indefinido."

msgid ""
"The following type-oriented macros are provided for convenience.  Note  that "
"*TYPE* refers to any C type."
msgstr ""
"As seguintes macros orientadas a tipos são fornecidas por conveniência. Note "
"que *TYPE* refere-se a qualquer tipo C."

msgid ""
"Same as :c:func:`PyMem_Malloc`, but allocates ``(n * sizeof(TYPE))`` bytes "
"of memory.  Returns a pointer cast to ``TYPE*``.  The memory will not have "
"been initialized in any way."
msgstr ""
"Semelhante a :c:func:`PyMem_Malloc`, mas aloca ``(n * sizeof(TYPE))`` bytes "
"de memória. Retorna um ponteiro convertido para ``TYPE*``. A memória não "
"será inicializada de nenhuma forma."

msgid ""
"Same as :c:func:`PyMem_Realloc`, but the memory block is resized to ``(n * "
"sizeof(TYPE))`` bytes.  Returns a pointer cast to ``TYPE*``. On return, *p* "
"will be a pointer to the new memory area, or ``NULL`` in the event of "
"failure."
msgstr ""
"Semelhante a :c:func:`PyMem_Realloc`, mas o bloco de memória é "
"redimensionado para ``(n * sizeof(TYPE))`` bytes. Retorna um ponteiro "
"convertido para ``TYPE*``. Ao retornar, *p* será um ponteiro para a nova "
"área de memória, ou ``NULL`` em caso de falha."

msgid ""
"This is a C preprocessor macro; *p* is always reassigned.  Save the original "
"value of *p* to avoid losing memory when handling errors."
msgstr ""
"Esta é uma macro do pré-processador C; *p* é sempre reatribuído. Guarde o "
"valor original de *p* para evitar perder memória ao tratar erros."

msgid "Same as :c:func:`PyMem_Free`."
msgstr "Semelhante a :c:func:`PyMem_Free`."

msgid ""
"In addition, the following macro sets are provided for calling the Python "
"memory allocator directly, without involving the C API functions listed "
"above. However, note that their use does not preserve binary compatibility "
"across Python versions and is therefore deprecated in extension modules."
msgstr ""
"Além disso, os seguintes conjuntos de macros são fornecidos para chamar "
"diretamente o alocador de memória do Python, sem envolver as funções da API "
"C listadas acima. No entanto, note que o seu uso não preserva a "
"compatibilidade binária entre versões do Python e, portanto, está obsoleto "
"em módulos de extensão."

msgid "``PyMem_MALLOC(size)``"
msgstr "``PyMem_MALLOC(size)``"

msgid "``PyMem_NEW(type, size)``"
msgstr "``PyMem_NEW(type, size)``"

msgid "``PyMem_REALLOC(ptr, size)``"
msgstr "``PyMem_REALLOC(ptr, size)``"

msgid "``PyMem_RESIZE(ptr, type, size)``"
msgstr "``PyMem_RESIZE(ptr, type, size)``"

msgid "``PyMem_FREE(ptr)``"
msgstr "``PyMem_FREE(ptr)``"

msgid "``PyMem_DEL(ptr)``"
msgstr "``PyMem_DEL(ptr)``"

msgid "Object allocators"
msgstr "Alocadores de Objetos"

msgid ""
"There is no guarantee that the memory returned by these allocators can be "
"successfully cast to a Python object when intercepting the allocating "
"functions in this domain by the methods described in the :ref:`Customize "
"Memory Allocators <customize-memory-allocators>` section."
msgstr ""
"Não há garantia de que a memória retornada por estes alocadores possa ser "
"convertida com sucesso para um objeto Python ao interceptar as funções de "
"alocação neste domínio pelos métodos descritos na secção :ref:`Personalizar "
"Alocadores de Memória <customize-memory-allocators>`."

msgid ""
"The :ref:`default object allocator <default-memory-allocators>` uses the :"
"ref:`pymalloc memory allocator <pymalloc>`."
msgstr ""
"O :ref:`alocador de objetos predefinido <default-memory-allocators>` usa o :"
"ref:`alocador de memória pymalloc <pymalloc>`."

msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyObject_Malloc(1)`` had been called instead. The memory will not "
"have been initialized in any way."
msgstr ""
"Solicitar zero bytes retorna um ponteiro não-``NULL`` distinto, se possível, "
"como se ``PyObject_Malloc(1)`` tivesse sido chamado. A memória não será "
"inicializada de nenhuma forma."

msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyObject_Calloc(1, 1)`` had been "
"called instead."
msgstr ""
"Solicitar zero elementos ou elementos com tamanho de zero bytes retorna um "
"ponteiro não-``NULL`` distinto, se possível, como se ``PyObject_Calloc(1, "
"1)`` tivesse sido chamado."

msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyObject_Malloc(n)``; else "
"if *n* is equal to zero, the memory block is resized but is not freed, and "
"the returned pointer is non-``NULL``."
msgstr ""
"Se *p* for ``NULL``, a chamada é equivalente a ``PyObject_Malloc(n)``; caso "
"contrário, se *n* for igual a zero, o bloco de memória é redimensionado, mas "
"não libertado, e o ponteiro retornado é não-``NULL``."

msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to :c:"
"func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` or :c:func:"
"`PyObject_Calloc`."
msgstr ""
"A menos que *p* seja ``NULL``, deve ter sido retornado por uma chamada "
"anterior a :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` ou :c:func:"
"`PyObject_Calloc`."

msgid ""
"If the request fails, :c:func:`PyObject_Realloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Se o pedido falhar, :c:func:`PyObject_Realloc` retorna ``NULL`` e *p* "
"permanece um ponteiro válido para a área de memória anterior."

msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a "
"previous call to :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` or :c:"
"func:`PyObject_Calloc`.  Otherwise, or if ``PyObject_Free(p)`` has been "
"called before, undefined behavior occurs."
msgstr ""
"Liberta o bloco de memória apontado por *p*, que deve ter sido retornado por "
"uma chamada anterior a :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` "
"ou :c:func:`PyObject_Calloc`. Caso contrário, ou se ``PyObject_Free(p)`` "
"tiver sido chamado anteriormente, ocorre comportamento indefinido."

msgid ""
"Do not call this directly to free an object's memory; call the type's :c:"
"member:`~PyTypeObject.tp_free` slot instead."
msgstr ""
"Não chame isto diretamente para libertar a memória de um objeto; em vez "
"disso, chame o slot :c:member:`~PyTypeObject.tp_free` do tipo."

msgid ""
"Do not use this for memory allocated by :c:macro:`PyObject_GC_New` or :c:"
"macro:`PyObject_GC_NewVar`; use :c:func:`PyObject_GC_Del` instead."
msgstr ""
"Não utilize isto para memória alocada por :c:macro:`PyObject_GC_New` ou :c:"
"macro:`PyObject_GC_NewVar`; use :c:func:`PyObject_GC_Del` em vez disso."

msgid ""
":c:func:`PyObject_GC_Del` is the equivalent of this function for memory "
"allocated by types that support garbage collection."
msgstr ""
":c:func:`PyObject_GC_Del` é o equivalente desta função para memória alocada "
"por tipos que suportam recolha de lixo."

msgid ":c:func:`PyObject_Malloc`"
msgstr ":c:func:`PyObject_Malloc`"

msgid ":c:func:`PyObject_Realloc`"
msgstr ":c:func:`PyObject_Realloc`"

msgid ":c:func:`PyObject_Calloc`"
msgstr ":c:func:`PyObject_Calloc`"

msgid ":c:macro:`PyObject_New`"
msgstr ":c:macro:`PyObject_New`"

msgid ":c:macro:`PyObject_NewVar`"
msgstr ":c:macro:`PyObject_NewVar`"

msgid ":c:func:`PyType_GenericAlloc`"
msgstr ":c:func:`PyType_GenericAlloc`"

msgid ":c:member:`~PyTypeObject.tp_free`"
msgstr ":c:member:`~PyTypeObject.tp_free`"

msgid "Default Memory Allocators"
msgstr "Alocadores de Memória Predefinidos"

msgid "Default memory allocators:"
msgstr "Alocadores de memória predefinidos:"

msgid "Configuration"
msgstr "Configuração"

msgid "Name"
msgstr "Nome"

msgid "PyMem_RawMalloc"
msgstr "PyMem_RawMalloc"

msgid "PyMem_Malloc"
msgstr "PyMem_Malloc"

msgid "PyObject_Malloc"
msgstr "PyObject_Malloc"

msgid "Release build"
msgstr "Compilação de lançamento"

msgid "``\"pymalloc\"``"
msgstr "``\"pymalloc\"``"

msgid "``malloc``"
msgstr "``malloc``"

msgid "``pymalloc``"
msgstr "``pymalloc``"

msgid "Debug build"
msgstr "Compilação de depuração"

msgid "``\"pymalloc_debug\"``"
msgstr "``\"pymalloc_debug\"``"

msgid "``malloc`` + debug"
msgstr "``malloc`` + depuração"

msgid "``pymalloc`` + debug"
msgstr "``pymalloc`` + depuração"

msgid "Release build, without pymalloc"
msgstr "Compilação de lançamento, sem pymalloc"

msgid "``\"malloc\"``"
msgstr "``\"malloc\"``"

msgid "Debug build, without pymalloc"
msgstr "Compilação de depuração, sem pymalloc"

msgid "``\"malloc_debug\"``"
msgstr "``\"malloc_debug\"``"

msgid "Legend:"
msgstr "Legenda:"

msgid "Name: value for :envvar:`PYTHONMALLOC` environment variable."
msgstr "Nome: valor para a variável de ambiente :envvar:`PYTHONMALLOC`."

msgid ""
"``malloc``: system allocators from the standard C library, C functions: :c:"
"func:`malloc`, :c:func:`calloc`, :c:func:`realloc` and :c:func:`free`."
msgstr ""
"``malloc``: alocadores do sistema da biblioteca C padrão, funções C: :c:func:"
"`malloc`, :c:func:`calloc`, :c:func:`realloc` e :c:func:`free`."

msgid "``pymalloc``: :ref:`pymalloc memory allocator <pymalloc>`."
msgstr "``pymalloc``: :ref:`alocador de memória pymalloc <pymalloc>`."

msgid ""
"``mimalloc``: :ref:`mimalloc memory allocator <mimalloc>`.  The pymalloc "
"allocator will be used if mimalloc support isn't available."
msgstr ""
"``mimalloc``: :ref:`alocador de memória mimalloc <mimalloc>`. O alocador "
"pymalloc será usado se o suporte para mimalloc não estiver disponível."

msgid ""
"\"+ debug\": with :ref:`debug hooks on the Python memory allocators <pymem-"
"debug-hooks>`."
msgstr ""
"\"+ depuração\": com :ref:`ganchos de depuração nos alocadores de memória do "
"Python <pymem-debug-hooks>`."

msgid "\"Debug build\": :ref:`Python build in debug mode <debug-build>`."
msgstr ""
"\"Compilação de depuração\": :ref:`compilação do Python em modo de depuração "
"<debug-build>`. "

msgid "Customize Memory Allocators"
msgstr "Personalizar Alocadores de Memória"

msgid ""
"Structure used to describe a memory block allocator. The structure has the "
"following fields:"
msgstr ""
"Estrutura usada para descrever um alocador de blocos de memória. A estrutura "
"tem os seguintes campos:"

msgid "Field"
msgstr "Campo"

msgid "Meaning"
msgstr "Significado"

msgid "``void *ctx``"
msgstr "``void *ctx``"

msgid "user context passed as first argument"
msgstr "contexto do utilizador passado como primeiro argumento"

msgid "``void* malloc(void *ctx, size_t size)``"
msgstr "``void* malloc(void *ctx, size_t size)``"

msgid "allocate a memory block"
msgstr "alocar um bloco de memória"

msgid "``void* calloc(void *ctx, size_t nelem, size_t elsize)``"
msgstr "``void* calloc(void *ctx, size_t nelem, size_t elsize)``"

msgid "allocate a memory block initialized with zeros"
msgstr "alocar um bloco de memória inicializado com zeros"

msgid "``void* realloc(void *ctx, void *ptr, size_t new_size)``"
msgstr "``void* realloc(void *ctx, void *ptr, size_t new_size)``"

msgid "allocate or resize a memory block"
msgstr "alocar ou redimensionar um bloco de memória"

msgid "``void free(void *ctx, void *ptr)``"
msgstr "``void free(void *ctx, void *ptr)``"

msgid "free a memory block"
msgstr "libertar um bloco de memória"

msgid ""
"The :c:type:`!PyMemAllocator` structure was renamed to :c:type:"
"`PyMemAllocatorEx` and a new ``calloc`` field was added."
msgstr ""
"A estrutura :c:type:`!PyMemAllocator` foi renomeada para :c:type:"
"`PyMemAllocatorEx` e foi adicionado um novo campo ``calloc``."

msgid "Enum used to identify an allocator domain. Domains:"
msgstr "Enum usado para identificar um domínio de alocação. Domínios:"

msgid "Functions:"
msgstr "Funções:"

msgid ":c:func:`PyMem_RawMalloc`"
msgstr ":c:func:`PyMem_RawMalloc`"

msgid ":c:func:`PyMem_RawRealloc`"
msgstr ":c:func:`PyMem_RawRealloc`"

msgid ":c:func:`PyMem_RawCalloc`"
msgstr ":c:func:`PyMem_RawCalloc`"

msgid ":c:func:`PyMem_RawFree`"
msgstr ":c:func:`PyMem_RawFree`"

msgid ":c:func:`PyMem_Malloc`,"
msgstr ":c:func:`PyMem_Malloc`,"

msgid ":c:func:`PyMem_Realloc`"
msgstr ":c:func:`PyMem_Realloc`"

msgid ":c:func:`PyMem_Calloc`"
msgstr ":c:func:`PyMem_Calloc`"

msgid ":c:func:`PyMem_Free`"
msgstr ":c:func:`PyMem_Free`"

msgid ":c:func:`PyObject_Free`"
msgstr ":c:func:`PyObject_Free`"

msgid "Get the memory block allocator of the specified domain."
msgstr "Obter o alocador de blocos de memória do domínio especificado."

msgid "Set the memory block allocator of the specified domain."
msgstr "Definir o alocador de blocos de memória do domínio especificado."

msgid ""
"The new allocator must return a distinct non-``NULL`` pointer when "
"requesting zero bytes."
msgstr ""
"O novo alocador deve retornar um ponteiro não-``NULL`` distinto ao solicitar "
"zero bytes."

msgid ""
"For the :c:macro:`PYMEM_DOMAIN_RAW` domain, the allocator must be thread-"
"safe: a :term:`thread state` is not :term:`attached <attached thread state>` "
"when the allocator is called."
msgstr ""
"Para o domínio :c:macro:`PYMEM_DOMAIN_RAW`, o alocador deve ser *thread-"
"safe*: um :term:`estado de thread` não está :term:`associado <attached "
"thread state>` quando o alocador é chamado."

msgid ""
"For the remaining domains, the allocator must also be thread-safe: the "
"allocator may be called in different interpreters that do not share a :term:"
"`GIL`."
msgstr ""
"Para os domínios restantes, o alocador também deve ser *thread-safe*: o "
"alocador pode ser chamado em diferentes intérpretes que não partilham um :"
"term:`GIL`."

msgid ""
"If the new allocator is not a hook (does not call the previous allocator), "
"the :c:func:`PyMem_SetupDebugHooks` function must be called to reinstall the "
"debug hooks on top on the new allocator."
msgstr ""
"Se o novo alocador não for um *hook* (não chama o alocador anterior), a "
"função :c:func:`PyMem_SetupDebugHooks` deve ser chamada para reinstalar os "
"*hooks* de depuração no novo alocador."

msgid ""
"See also :c:member:`PyPreConfig.allocator` and :ref:`Preinitialize Python "
"with PyPreConfig <c-preinit>`."
msgstr ""
"Veja também :c:member:`PyPreConfig.allocator` e :ref:`Pré-inicializar o "
"Python com PyPreConfig <c-preinit>`."

msgid ":c:func:`PyMem_SetAllocator` does have the following contract:"
msgstr ":c:func:`PyMem_SetAllocator` tem o seguinte contrato:"

msgid ""
"It can be called after :c:func:`Py_PreInitialize` and before :c:func:"
"`Py_InitializeFromConfig` to install a custom memory allocator. There are no "
"restrictions over the installed allocator other than the ones imposed by the "
"domain (for instance, the Raw Domain allows the allocator to be called "
"without an :term:`attached thread state`). See :ref:`the section on "
"allocator domains <allocator-domains>` for more information."
msgstr ""
"Pode ser chamada após :c:func:`Py_PreInitialize` e antes de :c:func:"
"`Py_InitializeFromConfig` para instalar um alocador de memória "
"personalizado. Não há restrições sobre o alocador instalado além daquelas "
"impostas pelo domínio (por exemplo, o Domínio Raw permite que o alocador "
"seja chamado sem um :term:`estado de thread associado`). Veja :ref:`a secção "
"sobre domínios de alocação <allocator-domains>` para mais informações."

msgid ""
"If called after Python has finish initializing (after :c:func:"
"`Py_InitializeFromConfig` has been called) the allocator **must** wrap the "
"existing allocator. Substituting the current allocator for some other "
"arbitrary one is **not supported**."
msgstr ""
"Se chamada após o Python ter terminado a inicialização (após :c:func:"
"`Py_InitializeFromConfig` ter sido chamada), o alocador **deve** encapsular "
"o alocador existente. Substituir o alocador atual por outro arbitrário **não "
"é suportado**."

msgid "All allocators must be thread-safe."
msgstr "Todos os alocadores devem ser *thread-safe*."

msgid ""
"Setup :ref:`debug hooks in the Python memory allocators <pymem-debug-hooks>` "
"to detect memory errors."
msgstr ""
"Configurar :ref:`*hooks* de depuração nos alocadores de memória do Python "
"<pymem-debug-hooks>` para detetar erros de memória."

msgid "Debug hooks on the Python memory allocators"
msgstr "*Hooks* de depuração nos alocadores de memória do Python"

msgid ""
"When :ref:`Python is built in debug mode <debug-build>`, the :c:func:"
"`PyMem_SetupDebugHooks` function is called at the :ref:`Python "
"preinitialization <c-preinit>` to setup debug hooks on Python memory "
"allocators to detect memory errors."
msgstr ""
"Quando o :ref:`Python é compilado em modo de depuração <debug-build>`, a "
"função :c:func:`PyMem_SetupDebugHooks` é chamada durante a :ref:`pré-"
"inicialização do Python <c-preinit>` para configurar *hooks* de depuração "
"nos alocadores de memória do Python e detetar erros de memória."

msgid ""
"The :envvar:`PYTHONMALLOC` environment variable can be used to install debug "
"hooks on a Python compiled in release mode (ex: ``PYTHONMALLOC=debug``)."
msgstr ""
"A variável de ambiente :envvar:`PYTHONMALLOC` pode ser usada para instalar "
"*hooks* de depuração num Python compilado em modo de lançamento (ex: "
"``PYTHONMALLOC=debug``)."

msgid ""
"The :c:func:`PyMem_SetupDebugHooks` function can be used to set debug hooks "
"after calling :c:func:`PyMem_SetAllocator`."
msgstr ""
"A função :c:func:`PyMem_SetupDebugHooks` pode ser usada para definir *hooks* "
"de depuração após chamar :c:func:`PyMem_SetAllocator`."

msgid ""
"These debug hooks fill dynamically allocated memory blocks with special, "
"recognizable bit patterns. Newly allocated memory is filled with the byte "
"``0xCD`` (``PYMEM_CLEANBYTE``), freed memory is filled with the byte "
"``0xDD`` (``PYMEM_DEADBYTE``). Memory blocks are surrounded by \"forbidden "
"bytes\" filled with the byte ``0xFD`` (``PYMEM_FORBIDDENBYTE``). Strings of "
"these bytes are unlikely to be valid addresses, floats, or ASCII strings."
msgstr ""
"Estes *hooks* de depuração preenchem blocos de memória alocados "
"dinamicamente com padrões de bits especiais e reconhecíveis. A memória recém-"
"alocada é preenchida com o byte ``0xCD`` (``PYMEM_CLEANBYTE``), a memória "
"libertada é preenchida com o byte ``0xDD`` (``PYMEM_DEADBYTE``). Os blocos "
"de memória são rodeados por \"bytes proibidos\" preenchidos com o byte "
"``0xFD`` (``PYMEM_FORBIDDENBYTE``). Cadeias destes bytes são improváveis de "
"serem endereços, floats ou cadeias ASCII válidos."

msgid "Runtime checks:"
msgstr "Verificações em tempo de execução:"

msgid ""
"Detect API violations. For example, detect if :c:func:`PyObject_Free` is "
"called on a memory block allocated by :c:func:`PyMem_Malloc`."
msgstr ""
"Detetar violações da API. Por exemplo, detetar se :c:func:`PyObject_Free` é "
"chamada num bloco de memória alocado por :c:func:`PyMem_Malloc`."

msgid "Detect write before the start of the buffer (buffer underflow)."
msgstr "Detetar escrita antes do início do buffer (*buffer underflow*)."

msgid "Detect write after the end of the buffer (buffer overflow)."
msgstr "Detetar escrita após o fim do buffer (*buffer overflow*)."

msgid ""
"Check that there is an :term:`attached thread state` when allocator "
"functions of :c:macro:`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`) "
"and :c:macro:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) domains are "
"called."
msgstr ""
"Verificar se existe um :term:`estado de thread associado` quando as funções "
"de alocação dos domínios :c:macro:`PYMEM_DOMAIN_OBJ` (ex: :c:func:"
"`PyObject_Malloc`) e :c:macro:`PYMEM_DOMAIN_MEM` (ex: :c:func:"
"`PyMem_Malloc`) são chamadas."

msgid ""
"On error, the debug hooks use the :mod:`tracemalloc` module to get the "
"traceback where a memory block was allocated. The traceback is only "
"displayed if :mod:`tracemalloc` is tracing Python memory allocations and the "
"memory block was traced."
msgstr ""
"Em caso de erro, os *hooks* de depuração usam o módulo :mod:`tracemalloc` "
"para obter o *traceback* de onde um bloco de memória foi alocado. O "
"*traceback* só é apresentado se o :mod:`tracemalloc` estiver a traçar "
"alocações de memória do Python e o bloco de memória tiver sido traçado."

msgid ""
"Let *S* = ``sizeof(size_t)``. ``2*S`` bytes are added at each end of each "
"block of *N* bytes requested.  The memory layout is like so, where p "
"represents the address returned by a malloc-like or realloc-like function "
"(``p[i:j]`` means the slice of bytes from ``*(p+i)`` inclusive up to "
"``*(p+j)`` exclusive; note that the treatment of negative indices differs "
"from a Python slice):"
msgstr ""
"Seja *S* = ``sizeof(size_t)``. ``2*S`` bytes são adicionados em cada "
"extremidade de cada bloco de *N* bytes solicitados. O *layout* da memória é "
"como segue, onde p representa o endereço retornado por uma função do tipo "
"malloc ou realloc (``p[i:j]`` significa a fatia de bytes de ``*(p+i)`` "
"inclusive até ``*(p+j)`` exclusivo; note que o tratamento de índices "
"negativos difere de uma fatia Python):"

msgid "``p[-2*S:-S]``"
msgstr "``p[-2*S:-S]``"

msgid ""
"Number of bytes originally asked for.  This is a size_t, big-endian (easier "
"to read in a memory dump)."
msgstr ""
"Número de bytes originalmente solicitados. Isto é um size_t, em *big-endian* "
"(mais fácil de ler num *dump* de memória)."

msgid "``p[-S]``"
msgstr "``p[-S]``"

msgid "API identifier (ASCII character):"
msgstr "Identificador da API (caractere ASCII):"

msgid "``'r'`` for :c:macro:`PYMEM_DOMAIN_RAW`."
msgstr "``'r'`` para :c:macro:`PYMEM_DOMAIN_RAW`."

msgid "``'m'`` for :c:macro:`PYMEM_DOMAIN_MEM`."
msgstr "``'m'`` para :c:macro:`PYMEM_DOMAIN_MEM`."

msgid "``'o'`` for :c:macro:`PYMEM_DOMAIN_OBJ`."
msgstr "``'o'`` para :c:macro:`PYMEM_DOMAIN_OBJ`."

msgid "``p[-S+1:0]``"
msgstr "``p[-S+1:0]``"

msgid "Copies of PYMEM_FORBIDDENBYTE.  Used to catch under- writes and reads."
msgstr ""
"Cópias de PYMEM_FORBIDDENBYTE. Usado para detetar escritas e leituras abaixo "
"do limite."

msgid "``p[0:N]``"
msgstr "``p[0:N]``"

msgid ""
"The requested memory, filled with copies of PYMEM_CLEANBYTE, used to catch "
"reference to uninitialized memory.  When a realloc-like function is called "
"requesting a larger memory block, the new excess bytes are also filled with "
"PYMEM_CLEANBYTE.  When a free-like function is called, these are overwritten "
"with PYMEM_DEADBYTE, to catch reference to freed memory.  When a realloc- "
"like function is called requesting a smaller memory block, the excess old "
"bytes are also filled with PYMEM_DEADBYTE."
msgstr ""
"A memória solicitada, preenchida com cópias de PYMEM_CLEANBYTE, usada para "
"detetar referências a memória não inicializada. Quando uma função do tipo "
"realloc é chamada solicitando um bloco de memória maior, os novos bytes em "
"excesso também são preenchidos com PYMEM_CLEANBYTE. Quando uma função do "
"tipo free é chamada, estes são sobrescritos com PYMEM_DEADBYTE, para detetar "
"referências a memória libertada. Quando uma função do tipo realloc é chamada "
"solicitando um bloco de memória menor, os bytes antigos em excesso também "
"são preenchidos com PYMEM_DEADBYTE."

msgid "``p[N:N+S]``"
msgstr "``p[N:N+S]``"

msgid "Copies of PYMEM_FORBIDDENBYTE.  Used to catch over- writes and reads."
msgstr ""
"Cópias de PYMEM_FORBIDDENBYTE. Usado para detetar escritas e leituras acima "
"do limite."

msgid "``p[N+S:N+2*S]``"
msgstr "``p[N+S:N+2*S]``"

msgid ""
"Only used if the ``PYMEM_DEBUG_SERIALNO`` macro is defined (not defined by "
"default)."
msgstr ""
"Apenas usado se a macro ``PYMEM_DEBUG_SERIALNO`` estiver definida (não "
"definida por predefinição)."

msgid ""
"A serial number, incremented by 1 on each call to a malloc-like or realloc-"
"like function.  Big-endian :c:type:`size_t`.  If \"bad memory\" is detected "
"later, the serial number gives an excellent way to set a breakpoint on the "
"next run, to capture the instant at which this block was passed out.  The "
"static function bumpserialno() in obmalloc.c is the only place the serial "
"number is incremented, and exists so you can set such a breakpoint easily."
msgstr ""
"Um número de série, incrementado em 1 em cada chamada a uma função do tipo "
"malloc ou realloc. :c:type:`size_t` em *big-endian*. Se for detetada "
"\"memória corrompida\" mais tarde, o número de série fornece uma excelente "
"forma de definir um *breakpoint* na próxima execução, para capturar o "
"instante em que este bloco foi passado. A função estática bumpserialno() em "
"obmalloc.c é o único local onde o número de série é incrementado, e existe "
"para que possa definir facilmente tal *breakpoint*."

msgid ""
"A realloc-like or free-like function first checks that the "
"PYMEM_FORBIDDENBYTE bytes at each end are intact.  If they've been altered, "
"diagnostic output is written to stderr, and the program is aborted via "
"Py_FatalError().  The other main failure mode is provoking a memory error "
"when a program reads up one of the special bit patterns and tries to use it "
"as an address.  If you get in a debugger then and look at the object, you're "
"likely to see that it's entirely filled with PYMEM_DEADBYTE (meaning freed "
"memory is getting used) or PYMEM_CLEANBYTE (meaning uninitialized memory is "
"getting used)."
msgstr ""
"Uma função do tipo realloc ou free verifica primeiro se os bytes "
"PYMEM_FORBIDDENBYTE em cada extremidade estão intactos. Se tiverem sido "
"alterados, é escrita saída de diagnóstico para stderr, e o programa é "
"abortado via Py_FatalError(). O outro modo principal de falha é provocar um "
"erro de memória quando um programa lê um dos padrões de bits especiais e "
"tenta usá-lo como um endereço. Se entrar num depurador nesse momento e "
"observar o objeto, é provável que veja que está completamente preenchido com "
"PYMEM_DEADBYTE (significando que memória libertada está a ser usada) ou "
"PYMEM_CLEANBYTE (significando que memória não inicializada está a ser usada)."

msgid ""
"The :c:func:`PyMem_SetupDebugHooks` function now also works on Python "
"compiled in release mode.  On error, the debug hooks now use :mod:"
"`tracemalloc` to get the traceback where a memory block was allocated. The "
"debug hooks now also check if there is an :term:`attached thread state` when "
"functions of :c:macro:`PYMEM_DOMAIN_OBJ` and :c:macro:`PYMEM_DOMAIN_MEM` "
"domains are called."
msgstr ""
"A função :c:func:`PyMem_SetupDebugHooks` agora também funciona em Python "
"compilado em modo de lançamento. Em caso de erro, os *hooks* de depuração "
"agora usam :mod:`tracemalloc` para obter o *traceback* de onde um bloco de "
"memória foi alocado. Os *hooks* de depuração agora também verificam se "
"existe um :term:`estado de thread associado` quando funções dos domínios :c:"
"macro:`PYMEM_DOMAIN_OBJ` e :c:macro:`PYMEM_DOMAIN_MEM` são chamadas."

msgid ""
"Byte patterns ``0xCB`` (``PYMEM_CLEANBYTE``), ``0xDB`` (``PYMEM_DEADBYTE``) "
"and ``0xFB`` (``PYMEM_FORBIDDENBYTE``) have been replaced with ``0xCD``, "
"``0xDD`` and ``0xFD`` to use the same values than Windows CRT debug "
"``malloc()`` and ``free()``."
msgstr ""
"Os padrões de bytes ``0xCB`` (``PYMEM_CLEANBYTE``), ``0xDB`` "
"(``PYMEM_DEADBYTE``) e ``0xFB`` (``PYMEM_FORBIDDENBYTE``) foram substituídos "
"por ``0xCD``, ``0xDD`` e ``0xFD`` para usar os mesmos valores que o "
"``malloc()`` e ``free()`` de depuração da CRT do Windows."

msgid "The pymalloc allocator"
msgstr "O alocador pymalloc"

msgid ""
"Python has a *pymalloc* allocator optimized for small objects (smaller or "
"equal to 512 bytes) with a short lifetime. It uses memory mappings called "
"\"arenas\" with a fixed size of either 256 KiB on 32-bit platforms or 1 MiB "
"on 64-bit platforms. It falls back to :c:func:`PyMem_RawMalloc` and :c:func:"
"`PyMem_RawRealloc` for allocations larger than 512 bytes."
msgstr ""
"O Python tem um alocador *pymalloc* otimizado para objetos pequenos (menores "
"ou iguais a 512 bytes) com um tempo de vida curto. Utiliza mapeamentos de "
"memória chamados \"arenas\" com um tamanho fixo de 256 KiB em plataformas de "
"32 bits ou 1 MiB em plataformas de 64 bits. Recorre a :c:func:"
"`PyMem_RawMalloc` e :c:func:`PyMem_RawRealloc` para alocações maiores que "
"512 bytes."

msgid ""
"*pymalloc* is the :ref:`default allocator <default-memory-allocators>` of "
"the :c:macro:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) and :c:macro:"
"`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`) domains."
msgstr ""
"O *pymalloc* é o :ref:`alocador predefinido <default-memory-allocators>` dos "
"domínios :c:macro:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) e :c:macro:"
"`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`)."

msgid "The arena allocator uses the following functions:"
msgstr "O alocador de arenas usa as seguintes funções:"

msgid ":c:func:`!VirtualAlloc` and :c:func:`!VirtualFree` on Windows,"
msgstr ":c:func:`!VirtualAlloc` e :c:func:`!VirtualFree` no Windows,"

msgid ":c:func:`!mmap` and :c:func:`!munmap` if available,"
msgstr ":c:func:`!mmap` e :c:func:`!munmap` se disponíveis,"

msgid ":c:func:`malloc` and :c:func:`free` otherwise."
msgstr ":c:func:`malloc` e :c:func:`free` caso contrário."

msgid ""
"This allocator is disabled if Python is configured with the :option:`--"
"without-pymalloc` option. It can also be disabled at runtime using the :"
"envvar:`PYTHONMALLOC` environment variable (ex: ``PYTHONMALLOC=malloc``)."
msgstr ""
"Este alocador está desativado se o Python for configurado com a opção :"
"option:`--without-pymalloc`. Também pode ser desativado em tempo de execução "
"usando a variável de ambiente :envvar:`PYTHONMALLOC` (ex: "
"``PYTHONMALLOC=malloc``)."

msgid ""
"Typically, it makes sense to disable the pymalloc allocator when building "
"Python with AddressSanitizer (:option:`--with-address-sanitizer`) which "
"helps uncover low level bugs within the C code."
msgstr ""
"Normalmente, faz sentido desativar o alocador pymalloc ao compilar o Python "
"com AddressSanitizer (:option:`--with-address-sanitizer`), que ajuda a "
"descobrir erros de baixo nível no código C."

msgid "Customize pymalloc Arena Allocator"
msgstr "Personalizar o Alocador de Arenas do pymalloc"

msgid ""
"Structure used to describe an arena allocator. The structure has three "
"fields:"
msgstr ""
"Estrutura usada para descrever um alocador de arenas. A estrutura tem três "
"campos:"

msgid "``void* alloc(void *ctx, size_t size)``"
msgstr "``void* alloc(void *ctx, size_t size)``"

msgid "allocate an arena of size bytes"
msgstr "alocar uma arena de tamanho *bytes*"

msgid "``void free(void *ctx, void *ptr, size_t size)``"
msgstr "``void free(void *ctx, void *ptr, size_t size)``"

msgid "free an arena"
msgstr "libertar uma arena"

msgid "Get the arena allocator."
msgstr "Obter o alocador de arenas."

msgid "Set the arena allocator."
msgstr "Definir o alocador de arenas."

msgid "The mimalloc allocator"
msgstr "O alocador mimalloc"

msgid ""
"Python supports the mimalloc allocator when the underlying platform support "
"is available. mimalloc \"is a general purpose allocator with excellent "
"performance characteristics. Initially developed by Daan Leijen for the "
"runtime systems of the Koka and Lean languages.\""
msgstr ""
"O Python suporta o alocador mimalloc quando o suporte da plataforma "
"subjacente estiver disponível. O mimalloc \"é um alocador de uso geral com "
"excelentes características de desempenho. Desenvolvido inicialmente por Daan "
"Leijen para os sistemas de execução das linguagens Koka e Lean.\""

msgid "tracemalloc C API"
msgstr "API C do tracemalloc"

msgid "Track an allocated memory block in the :mod:`tracemalloc` module."
msgstr "Rastrear um bloco de memória alocado no módulo :mod:`tracemalloc`."

msgid ""
"Return ``0`` on success, return ``-1`` on error (failed to allocate memory "
"to store the trace). Return ``-2`` if tracemalloc is disabled."
msgstr ""
"Retorna ``0`` em caso de sucesso, ``-1`` em caso de erro (falha ao alocar "
"memória para armazenar o rastreio). Retorna ``-2`` se o tracemalloc estiver "
"desativado."

msgid "If memory block is already tracked, update the existing trace."
msgstr ""
"Se o bloco de memória já estiver a ser rastreado, atualizar o rastreio "
"existente."

msgid ""
"Untrack an allocated memory block in the :mod:`tracemalloc` module. Do "
"nothing if the block was not tracked."
msgstr ""
"Deixar de rastrear um bloco de memória alocado no módulo :mod:`tracemalloc`. "
"Não fazer nada se o bloco não estiver a ser rastreado."

msgid "Return ``-2`` if tracemalloc is disabled, otherwise return ``0``."
msgstr ""
"Retorna ``-2`` se o tracemalloc estiver desativado, caso contrário retorna "
"``0``."

msgid "Examples"
msgstr "Exemplos"

msgid ""
"Here is the example from section :ref:`memoryoverview`, rewritten so that "
"the I/O buffer is allocated from the Python heap by using the first function "
"set::"
msgstr ""
"Aqui está o exemplo da secção :ref:`memoryoverview`, reescrito de forma a "
"que o buffer de I/O seja alocado a partir do *heap* do Python usando o "
"primeiro conjunto de funções::"

msgid ""
"PyObject *res;\n"
"char *buf = (char *) PyMem_Malloc(BUFSIZ); /* for I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"/* ...Do some I/O operation involving buf... */\n"
"res = PyBytes_FromString(buf);\n"
"PyMem_Free(buf); /* allocated with PyMem_Malloc */\n"
"return res;"
msgstr ""
"PyObject *res;\n"
"char *buf = (char *) PyMem_Malloc(BUFSIZ); /* para I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"/* ...Efetuar alguma operação de I/O envolvendo buf... */\n"
"res = PyBytes_FromString(buf);\n"
"PyMem_Free(buf); /* alocado com PyMem_Malloc */\n"
"return res;"

msgid "The same code using the type-oriented function set::"
msgstr "O mesmo código usando o conjunto de funções orientadas a tipos::"

msgid ""
"PyObject *res;\n"
"char *buf = PyMem_New(char, BUFSIZ); /* for I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"/* ...Do some I/O operation involving buf... */\n"
"res = PyBytes_FromString(buf);\n"
"PyMem_Free(buf); /* allocated with PyMem_New */\n"
"return res;"
msgstr ""
"PyObject *res;\n"
"char *buf = PyMem_New(char, BUFSIZ); /* para I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"/* ...Efetuar alguma operação de I/O envolvendo buf... */\n"
"res = PyBytes_FromString(buf);\n"
"PyMem_Free(buf); /* alocado com PyMem_New */\n"
"return res;"

msgid ""
"Note that in the two examples above, the buffer is always manipulated via "
"functions belonging to the same set. Indeed, it is required to use the same "
"memory API family for a given memory block, so that the risk of mixing "
"different allocators is reduced to a minimum. The following code sequence "
"contains two errors, one of which is labeled as *fatal* because it mixes two "
"different allocators operating on different heaps. ::"
msgstr ""
"Note que nos dois exemplos acima, o buffer é sempre manipulado através de "
"funções pertencentes ao mesmo conjunto. De facto, é necessário usar a mesma "
"família de API de memória para um determinado bloco de memória, de forma a "
"reduzir ao mínimo o risco de misturar alocadores diferentes. A seguinte "
"sequência de código contém dois erros, um dos quais é rotulado como *fatal* "
"porque mistura dois alocadores que operam em *heaps* diferentes.::"

msgid ""
"char *buf1 = PyMem_New(char, BUFSIZ);\n"
"char *buf2 = (char *) malloc(BUFSIZ);\n"
"char *buf3 = (char *) PyMem_Malloc(BUFSIZ);\n"
"...\n"
"PyMem_Del(buf3);  /* Wrong -- should be PyMem_Free() */\n"
"free(buf2);       /* Right -- allocated via malloc() */\n"
"free(buf1);       /* Fatal -- should be PyMem_Free()  */"
msgstr ""
"char *buf1 = PyMem_New(char, BUFSIZ);\n"
"char *buf2 = (char *) malloc(BUFSIZ);\n"
"char *buf3 = (char *) PyMem_Malloc(BUFSIZ);\n"
"...\n"
"PyMem_Del(buf3);  /* Errado -- deveria ser PyMem_Free() */\n"
"free(buf2);       /* Correto -- alocado via malloc() */\n"
"free(buf1);       /* Fatal -- deveria ser PyMem_Free()  */"

msgid ""
"In addition to the functions aimed at handling raw memory blocks from the "
"Python heap, objects in Python are allocated and released with :c:macro:"
"`PyObject_New`, :c:macro:`PyObject_NewVar` and :c:func:`PyObject_Free`."
msgstr ""
"Além das funções destinadas a manipular blocos de memória brutos do *heap* "
"do Python, os objetos em Python são alocados e libertados com :c:macro:"
"`PyObject_New`, :c:macro:`PyObject_NewVar` e :c:func:`PyObject_Free`."

msgid ""
"These will be explained in the next chapter on defining and implementing new "
"object types in C."
msgstr ""
"Estas serão explicadas no próximo capítulo sobre a definição e implementação "
"de novos tipos de objetos em C."

msgid "malloc (C function)"
msgstr "malloc (função C)"

msgid "calloc (C function)"
msgstr "calloc (função C)"

msgid "realloc (C function)"
msgstr "realloc (função C)"

msgid "free (C function)"
msgstr "free (função C)"
